<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>正则表达式re模块用法</title>
    <url>/posts/da405e24/</url>
    <content><![CDATA[<blockquote>
<p>re(Regular Expression)/正则表达式是一个内置的文本处理模块，在进行数据处理（筛选、替换）以及网页数据抓取时十分常用</p>
</blockquote>
<p>该模块的主要功能是基于给定的表达式<strong>匹配</strong><u>字符串</u>中的某些内容，<code>import re</code></p>
<p>本文参考官方文档，学习以下几点内容：<u>1-正则表达式的语法；2-常用函数及参数；3-案例及常用表达式</u></p>
<span id="more"></span>
<p>先介绍函数，再介绍写法</p>
<h2 id="函数方法"><a class="markdownIt-Anchor" href="#函数方法"></a> 函数方法</h2>
<blockquote>
<p>flages是在匹配时的附加参数，获得更加准确及干净的匹配结果，如可以选择<strong>不考虑换行，忽略大小写等</strong></p>
</blockquote>
<h3 id="方法及对象"><a class="markdownIt-Anchor" href="#方法及对象"></a> 方法及对象</h3>
<p><code>re.compile(pattern, flags=0)</code>：将表达式编译为<strong>正则表达式对象</strong>以供后续使用/<strong>复用</strong></p>
<ul>
<li>输入pattern为表达式字符串，返回对象类型为 &lt;class ‘re.Pattern’&gt;，可以直接进行检索也可作为其他函数的pattern输入</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pattern_ = re.<span class="built_in">compile</span>(pattern)</span><br><span class="line">result = re.match(pattern_, string)<span class="comment">#实际上就等价于re.match(pattern, string)</span></span><br><span class="line"><span class="comment"># 其他参见pattern_.search();pattern_.match();pattern_.split();pattern_.findall();...</span></span><br></pre></td></tr></table></figure>
<p><code>re.findall(pattern, string, flags=0)</code>：常用，返回全部匹配结果，以<strong>列表list</strong>返回</p>
<ul>
<li>通过在表达式中加括号可以实现元组分组，两个示例</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">re.findall(<span class="string">r&#x27;[a-zA-Z]+&#x27;</span>, <span class="string">&#x27;Which453foot378（*&amp;…… or378 378hand378 fell378 fastest&#x27;</span>)</span><br><span class="line"><span class="comment"># 返回其中的单词 [&#x27;which&#x27;, &#x27;foot&#x27;, &#x27;or&#x27;, &#x27;hand&#x27;, &#x27;fell&#x27;, &#x27;fastest&#x27;]</span></span><br><span class="line">re.findall(<span class="string">r&#x27;(\w+)=(\d+)&#x27;</span>, <span class="string">&#x27;set width=20 and height=10&#x27;</span>)</span><br><span class="line">[(<span class="string">&#x27;width&#x27;</span>, <span class="string">&#x27;20&#x27;</span>), (<span class="string">&#x27;height&#x27;</span>, <span class="string">&#x27;10&#x27;</span>)]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>re.finditer(pattern, string, flags=0)</code>：同上，但是返回结果为一个迭代器</li>
</ul>
<p><code>re.search(pattern, string, flags=0)</code>: 整个字符串匹配并返回满足pattern的的<strong>第一个</strong>位置，可以为空</p>
<ul>
<li>返回对象类型是&lt;class ‘re.Match’&gt;，如果没有匹配到，则返回None ；</li>
</ul>
<p><code>re.match(pattern, string, flags=0)</code>: 匹配字符串开头是否满足pattern并返回，不常用</p>
<p><code>re.split(pattern, string, maxsplit=0, flags=0)</code>：匹配表达式分割string，如匹配逗号分开单词</p>
<ul>
<li>可以视为str.split(char, num)的加强版，maxsplit设置分割次数，默认全部分割</li>
<li>如果pattern中包含了括号则会同时返回匹配到的内容及切分后的结果，示例：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">re.split(<span class="string">r&#x27;\W+&#x27;</span>, <span class="string">&#x27;Words, words, words.&#x27;</span>)</span><br><span class="line"><span class="comment"># [&#x27;Words&#x27;, &#x27;words&#x27;, &#x27;words&#x27;, &#x27;&#x27;]</span></span><br><span class="line">re.split(<span class="string">r&#x27;(\W+)&#x27;</span>, <span class="string">&#x27;Words, words, words.&#x27;</span>)</span><br><span class="line"><span class="comment"># [&#x27;Words&#x27;, &#x27;, &#x27;, &#x27;words&#x27;, &#x27;, &#x27;, &#x27;words&#x27;, &#x27;.&#x27;, &#x27;&#x27;]</span></span><br></pre></td></tr></table></figure>
<p><code>re.sub(pattern, repl, string, count=0, flags=0)</code>：查找并<strong>替换</strong>string中pattern匹配的内容</p>
<ul>
<li>
<p>repl是替换为的新的内容，也可以是一个函数</p>
</li>
<li>
<p>可以视为str.replace(‘…’, ‘…’)的加强版，<code>re.``subn()</code>类似，但是会同时返回替换/匹配成功的次数</p>
</li>
</ul>
<h3 id="flags参数"><a class="markdownIt-Anchor" href="#flags参数"></a> flags参数</h3>
<blockquote>
<p>一次只能设一个</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">表达式flags=</th>
<th style="text-align:center">全称</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">re.A</td>
<td style="text-align:center">ASCII</td>
<td style="text-align:center">让 \w, \W, \b, \B, \d, \D, \s 和 \S 只匹配ASCII，而不是Unicode</td>
</tr>
<tr>
<td style="text-align:center">re.I</td>
<td style="text-align:center">IGNORECASE</td>
<td style="text-align:center">忽略大小写匹配</td>
</tr>
<tr>
<td style="text-align:center">re.S</td>
<td style="text-align:center">DOTALL</td>
<td style="text-align:center">最常用，让 <code>'.'</code> 特殊字符匹配任何字符，包括换行符</td>
</tr>
<tr>
<td style="text-align:center">re.M</td>
<td style="text-align:center">MULTILINE</td>
<td style="text-align:center">当之前只能匹配字符串开头结尾的的可以拓展到多行的开头结尾</td>
</tr>
<tr>
<td style="text-align:center">re.X</td>
<td style="text-align:center">VERBOSE</td>
<td style="text-align:center">编写友好，写表达式时可以进行分段和添加注释</td>
</tr>
</tbody>
</table>
<h2 id="正则表达式语法"><a class="markdownIt-Anchor" href="#正则表达式语法"></a> 正则表达式语法</h2>
<blockquote>
<p>最重要的是完成准确的正则表达式的书写，通常的形式是  r’raw…’</p>
</blockquote>
<p>正则表达式的几个点</p>
<ol>
<li>可以拼接组合，如‘a-zA-Z’会一起匹配大小写字母，A|B 或匹配，优先A</li>
<li>可以包含普通或者特殊字符，</li>
<li>元字符有<code>. ^ $ * + ? &#123; &#125; [ ] \ | ( )</code>，它们不匹配自己</li>
<li>反斜杠<code>\</code>用于和其他字母组合表示特殊匹配形式</li>
<li>重复修饰符 (<code>*</code>, <code>+</code>, <code>?</code>, <code>&#123;m,n&#125;</code>，字面意思，重复匹配</li>
<li>关于转义符的解释：<code>r&quot;\n&quot;</code> 表示包含 <code>'\'</code> 和 <code>'n'</code> 两个字符的字符串，而 <code>&quot;\n&quot;</code> 则表示只包含一个换行符的字符串,<code>r&quot;.*?&quot;</code>匹配特殊序列而不是匹配<code>?</code>本身。</li>
</ol>
<p>语法-<a href="https://docs.python.org/zh-cn/3/library/re.html#regular-expression-syntax">详细参考</a>，此处仅介绍部分</p>
<ul>
<li><code>.</code>：匹配除了换行的任意字符。如果指定了标签<strong>re.S</strong>，它将匹配包括换行符的任意字符。</li>
<li><code>[]</code>:表示一个字符集合，如[amk]匹配三个字母，<code>[0-5][0-9]</code>匹配00-59
<ul>
<li>特殊字符在集合中会失去其特殊意义，如<code>[(+*)]</code> 只会匹配这几个字面字符之一 <code>'('</code>, <code>'+'</code>, <code>'*'</code>, or <code>')'</code>。</li>
<li>[^…]，匹配不在 [] 中的字符</li>
</ul>
</li>
<li><code>()</code>: 匹配括号内的表达式，也表示一个组</li>
</ul>
<p>重复匹配符</p>
<ul>
<li><code>*</code>: 对它前面的正则式匹配0到任意次重复， 尽量多的匹配字符串。</li>
<li><code>+</code>: 对它前面的正则式匹配1到任意次重复。</li>
<li><code>?</code>: 对它前面的正则式匹配0到1次重复。 <code>ab?</code> 会匹配 <code>'a'</code> 或者 <code>'ab'</code></li>
<li><code>*?, +?, ??</code></li>
<li><code>&#123;m&#125;</code></li>
<li><code>&#123;mn&#125;</code>对正则式进行 m 到 n 次匹配，在 m 和 n 之间取尽量多。</li>
<li><code>&#123;m,n&#125;?</code>：同上，但是非贪婪模式，及尽可能少</li>
</ul>
<p>匹配数字字母及下划线等符号</p>
<ul>
<li><code>\d</code>：匹配数字想当于[0-9]；<code>\D</code>匹配非数字相当于<code>[^0-9]</code></li>
<li><code>\s</code>: 匹配任意空白字符（换行符等），等价于 [\t\n\r\f]，<code>\S</code>取反</li>
<li><code>\w</code>: 匹配字母数字及下划线，大写<code>\W</code>则取反</li>
</ul>
<p>其他：<code>\A \z</code>等匹配字符串的开头结尾</p>
<h2 id="案例及常用"><a class="markdownIt-Anchor" href="#案例及常用"></a> 案例及常用</h2>
<p>任意匹配：<code>.*?</code></p>
<p>匹配url: <code>[a-zA-z]+://[^\s]*</code></p>
<h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2>
<p>源代码位置：<a href="https://github.com/python/cpython/tree/3.10/Lib/re.py">Lib/re.py</a></p>
<p>官方文档: <a href="https://docs.python.org/zh-cn/3/library/re.html#functions">api</a></p>
]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
        <tag>爬虫</tag>
        <tag>文本处理</tag>
      </tags>
  </entry>
  <entry>
    <title>时间序列(1)：LOESS(STL)时间序列分解</title>
    <url>/posts/6e05178d/</url>
    <content><![CDATA[<p>近期处理定位请求时间序列的过程中用到了STL时间序列分解，趋势分析及变点检测方法，在Python和R中都进行了实践，小结一下参数设置和其他个人体会。内容包括：</p>
<p>1-时间序列建模/成分提取及异常分析思路；2-STL调参及代码(python and R);</p>
<span id="more"></span>
<h2 id="引言"><a class="markdownIt-Anchor" href="#引言"></a> 引言</h2>
<blockquote>
<p>时间序列中的”异常”？</p>
<p>此处的时间序列包含成分：周期成分(seasonal)、趋势成分(trend)及其他部分(remainded/)</p>
</blockquote>
<p>周期：如一个商场的总人口每天24小时的规律变化</p>
<p>趋势：最小单元一般是一个周期，及尺度会大于周期。比如商场周一到周末会有一个变化/减少的趋势线</p>
<p>理论上，如果规律完美，原始时间序列减去周期及趋势应该能得到一条水平线，恒为0，但实际上很少会这样，能够得到一个在0或者某个值附近波动的变化，这样都可以称为理想的白噪音了，也即是这个过程没有任何问题，但实际上：</p>
<ul>
<li>各种不确定性的内部外部因素都可能产生异常，导致某天某些时候数据突变，甚至是整个趋势的变化，这就是通常在研究中我们需要关注的点并结合问题进行进一步的分析。</li>
<li>有的异常或者个别的异常可能并不带来负面影响，那他就是可容忍的，因此我们需要设置一些<strong>阈值</strong>，通过一些方法来排除掉，<strong>从而找到我们真正需要关心的那些变化</strong></li>
</ul>
<p>在异常分析时这是比较常规的方式：</p>
<ol>
<li>对序列进行<strong>建模/拟合</strong>(时间序列分解实际也是这样的)，模型总是理想的</li>
<li>分离常态并去除规律性的部分（周期或趋势或二者均去除）。趋势的去除和周期的尺度和时间长度密切相关，因此需要结合实际问题和情况考虑趋势是否需要去除</li>
<li>根据问题，设定条件，判别真正的<strong>异常</strong></li>
</ol>
<h2 id="stl时序分解"><a class="markdownIt-Anchor" href="#stl时序分解"></a> stl时序分解</h2>
<blockquote>
<p>STL(“Seasonal and Trend decomposition using Loess”) 是一种用于分解时间序列的通用且稳健的方法。</p>
</blockquote>
<blockquote>
<p>Loess 是一种估计非线性关系的方法。STL 方法由RB Cleveland等人 ( <a href="https://otexts.com/fpp2/stl.html#ref-Cleveland1990">1990</a> )开发。</p>
</blockquote>
<h3 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h3>
<p>STL时间序列分解将序列分解为周期成分(seasonal)、趋势成分(trend)及其他部分(remainded/)，这几个成分可以是相加的也可以是相乘的（及加法模型和乘法模型），乘法也就意味着随着时间的推移不同成为有累积叠加作用</p>
<h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3>
<h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2>
<ul>
<li>
<p>预测： 方法与实践: <a href="https://otexts.com/fppcn/stl.html">在线书籍</a></p>
</li>
<li>
<p>python statsmodel包:<a href="https://www.statsmodels.org/devel/examples/notebooks/generated/stl_decomposition.html#">stl_decomposition</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>时空数据处理分析</category>
      </categories>
      <tags>
        <tag>时间序列分解</tag>
        <tag>Python</tag>
        <tag>statsmodels</tag>
        <tag>R</tag>
      </tags>
  </entry>
  <entry>
    <title>DLL文件及conda模块加载失败</title>
    <url>/posts/69110d48/</url>
    <content><![CDATA[<p>近期debug，同学在引入包(rasterio)的过程中频繁遇到<code>DLL load failed while importing _version: 找不到指定的程序</code>的问题，大部分情况都是因为包依赖的冲突/不适配问题</p>
<span id="more"></span>
<p>一般重新安装或者重新配置环境解决。</p>
<p>经分析此处大概也是Python环境中包的依赖版本及路径的冲突问题，一开始新建了3.9的环境能够运行，但是偶尔能用，未进一步深究，直接建议安装了3.9的miniconda替换了旧的3.7的Anaconda（该版本有点旧了）,此处大概是因为基础环境中的3.7版本GDAL与新环境的冲突。旧版本的GDAL还需要自己设置路径。</p>
<h2 id="dll文件"><a class="markdownIt-Anchor" href="#dll文件"></a> DLL文件</h2>
<blockquote>
<p>Dynamic-link_library 动态链接库，也即是<strong>库</strong></p>
</blockquote>
<p><a href="https://en.wikipedia.org/wiki/Dynamic-link_library">wiki</a>：是Microsoft在Microsoft Windows和OS/2操作系统中实现的共享库概念，与exe一样，DLL可以包含任意组合的代码、数据和资源。</p>
<ul>
<li>动态链接：程序在执行时从共享库中调用代码片段dll。The same architectural concept that allowed GDI to load different device drivers is that which allowed the <strong><a href="https://en.wikipedia.org/wiki/Windows_shell">Windows shell</a> to load different Windows programs</strong>, and for these programs to invoke API calls from the shared USER and GDI libraries. That concept was “dynamic linking”.</li>
<li>共享：不同的应用程序可以调用同一个DLL即DLL 中的代码通常在所有使用 DLL 的进程之间共享</li>
<li>好处：DLL 为共享代码和数据提供了一种机制，允许共享代码/数据的开发人员升级功能，而无需重新链接或重新编译应用程序。</li>
</ul>
<p>与静态库一样，DLL 的导入库由.lib文件扩展名注明</p>
<h2 id="conda版本及包问题"><a class="markdownIt-Anchor" href="#conda版本及包问题"></a> Conda版本及包问题</h2>
<blockquote>
<p>不同包来源和依赖库版本不同，加上维护群体和更新快慢差异，因此直接安装多个包可能存在冲突。</p>
</blockquote>
<blockquote>
<p>这也是为什么建议通过pip conda之类的工具来进行包的管理，即有人帮我们做了一道版本的”审查”。建议是尽量使用主流的一些包，安装时优先使用conda-forge，如果还有问题先试试新建环境，一般能走通，或者也可以找到源码自己改写。</p>
</blockquote>
<p>个人习惯使用<a href="https://docs.conda.io/en/latest/miniconda.html#:~:text=Miniconda%20is%20a%20free%20minimal,zlib%20and%20a%20few%20others.">miniconda</a>3.9版本或者3.8作为基础环境进行环境管理，然后根据不同的工作新建常用的一些环境进行环境分离（而且新环境坏了也可以直接删掉重来），比如我个人会常建空间处理、文本处理、爬虫等几个环境进行使用，而不使用base，另外有特殊版本需求的任务可以新建如2.7 3.6 环境等</p>
<ul>
<li>之前写过Python入门、包以及conda环境管理，后续改改上传一下</li>
</ul>
<p>安装包的时候建议通过谷歌搜索conda package名找到最佳安装命令(conda/或者在github)，及优先使用<a href="https://anaconda.org/"> conda-forge</a>安装，没有的包则直接通过pip安装关于为什么建议使用conda-forge和不同包分法渠道的区别还可以看看这里<a href="https://conda-forge.org/docs/user/introduction.html">官网</a>,<a href="https://stackoverflow.com/questions/39857289/should-conda-or-conda-forge-be-used-for-python-environments">帖2</a></p>
<ul>
<li>设置默认渠道的方式：<code>conda config --add channels conda-forge</code></li>
<li>包来源渠道channels设置文件一般在用户文件处，如我的是C:/Users/huangs/.condarc</li>
</ul>
<h2 id="部分参考"><a class="markdownIt-Anchor" href="#部分参考"></a> 部分参考</h2>
<ul>
<li>
<p><a href="https://docs.conda.io/en/latest/miniconda.html#:~:text=Miniconda%20is%20a%20free%20minimal,zlib%20and%20a%20few%20others.">Miniconda</a></p>
</li>
<li>
<p><a href="https://conda-forge.org/docs/user/introduction.html">https://conda-forge.org/docs/user/introduction.html</a></p>
</li>
<li>
<p><a href="https://blog.csdn.net/qq_41683065/article/details/99710373">csdn</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>conda环境管理</tag>
      </tags>
  </entry>
  <entry>
    <title>矢栅处理(杂)：geopandas常用函数小结</title>
    <url>/posts/57d7f29/</url>
    <content><![CDATA[<center>汇总一下常用的几行geopandas代码便于复用</center>
<span id="more"></span>
<blockquote>
<p>geopandas一般用于处理数据量不大的文件，文件大的空间操作较慢、</p>
<p>另外，理论上esri shapefile的文件大小上限为2Gb</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> geopandas <span class="keyword">as</span> gpd</span><br><span class="line"><span class="keyword">from</span> geopandas <span class="keyword">import</span> sjoin</span><br></pre></td></tr></table></figure>
<p>创建，读取or写出</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 读</span></span><br><span class="line">shapefilepath = <span class="string">&quot;..shp&quot;</span></span><br><span class="line">gdf = gpd.read_file(shapefilepath, encoding = <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">gdf = gpd.read_file(shapefilepath, encoding = <span class="string">&#x27;gbk&#x27;</span>)</span><br><span class="line"><span class="comment"># 通过df并添加集合创建</span></span><br><span class="line">df = pd.read_csv(filepath)</span><br><span class="line">gdf = gpd.GeoDataFrame(df, geometry=gpd.points_from_xy(df.lng, df.lat), crs=<span class="string">&quot;EPSG:4326&quot;</span>)</span><br><span class="line">gdf = gpd.GeoDataFrame(df, geometry=geometries, crs=<span class="string">&quot;EPSG:4326&quot;</span>)</span><br><span class="line"><span class="comment"># 写</span></span><br><span class="line">res0.to_file(outshapefile, encoding = <span class="string">&#x27;utf-8&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>空间连接-<a href="https://geopandas.org/en/latest/docs/user_guide/mergingdata.html">ref</a>, predicate可选参数</p>
<ul>
<li>intersects、contains、within、touches、crosses、overlaps</li>
<li>how: left、right、inner，<a href="https://hscyber.github.io/posts/18b022c/">连接方式</a>含义</li>
<li>如果pandas的版本较旧，predicate参数名称为<code>op</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">res = sjoin(left_df=gdf_points, right_df=gdf_polygon, predicate=<span class="string">&#x27;within&#x27;</span>, how=<span class="string">&#x27;inner&#x27;</span>)</span><br><span class="line">res = sjoin(left_df=gdf_polygon, right_df=gdf_points, predicate=<span class="string">&#x27;contains&#x27;</span>, how=<span class="string">&#x27;inner&#x27;</span>)</span><br><span class="line">res = sjoin(left_df=gdf_polygon1, right_df=gdf_polygon2, predicate=<span class="string">&#x27;intersects&#x27;</span>, how=<span class="string">&#x27;inner&#x27;</span>)</span><br><span class="line">res = sjoin(left_df=gdf_polygon1, right_df=gdf_polygon2, op=<span class="string">&#x27;intersects&#x27;</span>, how=<span class="string">&#x27;inner&#x27;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>时空数据处理分析</category>
      </categories>
      <tags>
        <tag>geopandas</tag>
        <tag>spatialjoin</tag>
      </tags>
  </entry>
  <entry>
    <title>Pandas(杂)：表格的各种连接方式</title>
    <url>/posts/18b022c/</url>
    <content><![CDATA[<center>简单记录一下数据库或表格连接的类型，建议通过行数辨别</center>
<span id="more"></span>
<p>在<code>pd.merge(); df.join(); gpd.sjoin()</code>等函数中会用到，只有存在共同字段的列才能连接。否则拼接应该采用<code>pd.concat()</code><a href="https://pandas.pydata.org/docs/reference/api/pandas.concat.html">函数</a></p>
<ol>
<li>
<p>内连接 (inner join)，一般默认，只保留匹配到的结果</p>
</li>
<li>
<p>左(外)连接 (left join)，以左侧表的连接键唯一值数量为准，左表行数不变</p>
</li>
<li>
<p>右(外)连接 (right join)，右表行数不变</p>
</li>
<li>
<p>全连接 (full join)，在pandas中没有：在数据库中指返回左右表的所有行，缺失处补空值。行数=左表的行数+右表的行数-公共连接行</p>
</li>
</ol>
<p>举例，下面左表<strong>5行</strong>2列，右表-<strong>4行</strong>两列，公共列为fid，fid<strong>公共行数为3行</strong>，结果</p>
<ul>
<li>
<p>内连接返回三行，[‘a’, ‘b’,‘c’]，未匹配的丢弃</p>
</li>
<li>
<p>左连接返回5行，[1,2,3,4,5]，无值则补null</p>
</li>
<li>
<p>右连接返回3行，[3,4,5,7]，无值则补null</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">data1 = &#123;</span><br><span class="line">    <span class="string">&#x27;fid&#x27;</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span>:[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line">data2 = &#123;</span><br><span class="line">    <span class="string">&#x27;fid&#x27;</span>:[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>],</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span>:[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;e&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line">df1 = pd.DataFrame(data1)</span><br><span class="line">df2 = pd.DataFrame(data2)</span><br><span class="line"><span class="comment"># 查看输出</span></span><br><span class="line">pd.merge(left=df1, right=df2, on=<span class="string">&#x27;fid&#x27;</span>, how=<span class="string">&#x27;left&#x27;</span>)</span><br><span class="line">pd.merge(left=df1, right=df2, on=<span class="string">&#x27;fid&#x27;</span>, how=<span class="string">&#x27;right&#x27;</span>)</span><br><span class="line">pd.merge(left=df1, right=df2, on=<span class="string">&#x27;fid&#x27;</span>, how=<span class="string">&#x27;inner&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>分别输出：</p>
<img src="/posts/18b022c/image-20220722223231092.png" class alt="image-20220722223231092">
]]></content>
      <categories>
        <category>Pandas数据处理分析</category>
      </categories>
      <tags>
        <tag>join</tag>
        <tag>Pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>image test</title>
    <url>/posts/2852138d/</url>
    <content><![CDATA[<p>typora图片插入格式设置 <code>![](相对文件夹/图片名)</code></p>
<span id="more"></span>
<img src="/posts/2852138d/test.png" class alt="image">
]]></content>
      <categories>
        <category>Hexo框架</category>
      </categories>
  </entry>
  <entry>
    <title>Python处理Json文件</title>
    <url>/posts/3c868742/</url>
    <content><![CDATA[<p>本文小结JSON相关的一些知识点和读写方式，涉及内容</p>
<p>①. 序列化与反序列化；	②.Json数据格式转换及其读写；	③. 出错案例/非标准JSON文件处理</p>
<p>首先：<code>import json</code></p>
<span id="more"></span>
<h2 id="序列化与json文件"><a class="markdownIt-Anchor" href="#序列化与json文件"></a> 序列化与JSON文件</h2>
<blockquote>
<p>序列化<a href="https://en.wikipedia.org/wiki/Serialization">Serialization</a>，广泛地讲就是将内存中创建/生成的数据对象存为文件的过程</p>
<p>平时读写txt csv excel shapefile pickle json geojson都可以视为(反)序列化的过程</p>
</blockquote>
<h3 id="json文件"><a class="markdownIt-Anchor" href="#json文件"></a> JSON文件</h3>
<p>JSON全称是“JavaScript Object Notation”，是一种数据格式，js中的大量属性都是通过字典格式表示，因此json主要以字典格式存储。此外，<a href="https://en.wikipedia.org/wiki/GeoJSON">GeoJSON</a>是在<a href="https://en.wikipedia.org/wiki/JSON">json</a>文件的基础上构建的一种，处理方式类似。</p>
<p>序列化(serialization)与反序列化(deserialization)</p>
<ol>
<li>
<p>序列化指将数据结构、对象转换为可读取状态，如存为文件，以便下次或在其他环境中能够恢复到原来的状态；也称对象编组(marshlling)。</p>
</li>
<li>
<p>从一序列字节提取数据结果的反向操作则成为反序列化，也称解码组(unmarshlling) 。</p>
</li>
</ol>
<p>python中的序列化模块主要有：pickle、json 等等</p>
<h3 id="json对象"><a class="markdownIt-Anchor" href="#json对象"></a> JSON对象</h3>
<blockquote>
<p>在未保存前其在内存中的表示即数据类型，类似于DataFrame与csv的关系</p>
</blockquote>
<p>Python中的JSON序列化过程中，即在内存中的表示/数据类型：</p>
<ul>
<li>
<p>字典<code>dict</code>会编组为标准的<code>JSON</code>对象</p>
</li>
<li>
<p><code>list</code>及<code>tuple</code>转换为<code>array</code></p>
</li>
<li>
<p>字符及数值分别转换为<code>string</code>;<code>numbers</code></p>
</li>
</ul>
<h2 id="数据类型转换dumpsloads"><a class="markdownIt-Anchor" href="#数据类型转换dumpsloads"></a> 数据类型转换：dumps()+loads()</h2>
<blockquote>
<p>json.dumps()就是序列化的函数，不带s的是用来读写的</p>
</blockquote>
<p>我们可以直接将列表、字典等各种数据类型通过<code>json.dumps(object)</code>转换为json格式</p>
<p>当然，实际中更常用的是通过<code>json.loads(json_string)</code>读取json对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="comment"># 其他对象转为json对象</span></span><br><span class="line">mylist = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">mydic = &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>:<span class="string">&quot;h&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>:<span class="number">24</span>,</span><br><span class="line">    <span class="string">&quot;money&quot;</span>:<span class="number">1500</span>&#125;</span><br><span class="line">data_json = json.dumps(mydic)</span><br><span class="line"><span class="built_in">print</span>(data_json) <span class="comment"># &#123;&quot;name&quot;: &quot;h&quot;, &quot;age&quot;: 24, &quot;money&quot;: 1500&#125;</span></span><br><span class="line">data_json = json.dumps(mydic, indent=<span class="number">4</span>)</span><br><span class="line">data_json <span class="comment"># &#x27;&#123;\n    &quot;name&quot;: &quot;h&quot;,\n    &quot;age&quot;: 24,\n    &quot;money&quot;: 1500\n&#125;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(data_json) <span class="comment"># print()打印的话，会看待标准的字典样式，带4的缩进</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># json转为原始对象</span></span><br><span class="line">mydict = json.loads(data_json)</span><br></pre></td></tr></table></figure>
<h2 id="json文件写和读dumpload"><a class="markdownIt-Anchor" href="#json文件写和读dumpload"></a> JSON文件写和读dump()+load()</h2>
<blockquote>
<p>一般而言json文件是由<strong>字典+列表</strong>多层嵌套组成，最终文件是字符串</p>
</blockquote>
<p>写json文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可以不转换将数据直接写入</span></span><br><span class="line">mylist = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;test.json&quot;</span>,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    json.dump(mydic, f, indent=<span class="number">4</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;test.json&quot;</span>,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    json.dump(mylist, f)</span><br></pre></td></tr></table></figure>
<p>读json文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;test.json&quot;</span>,<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    mylist = json.load(f)</span><br></pre></td></tr></table></figure>
<p>追加到json文件，追加无法像文本一样直接写入，需要读取原始json字典或者list，修改后再重新写出</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.读取json文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;test.json&quot;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    mydic = json.load(f)</span><br><span class="line"><span class="comment">#2.修改，update好像是Python3.9及之后有的函数，也可以其他方式修改</span></span><br><span class="line">x = &#123;<span class="string">&quot;x&quot;</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]&#125;</span><br><span class="line">mydic.update(x)</span><br><span class="line"><span class="comment">#3.重新写入</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;test.json&quot;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    json.dump(mydic, f)</span><br></pre></td></tr></table></figure>
<h2 id="读写出错非标准json格式处理"><a class="markdownIt-Anchor" href="#读写出错非标准json格式处理"></a> 读写出错?——非标准json格式处理</h2>
<blockquote>
<p>出错调试案例</p>
</blockquote>
<p><strong>情况1</strong>：由于文件的多次序列与反序列化/读写，会导致格式不一致或<strong>非标准文件的产生</strong>。</p>
<ul>
<li>如：读文件时出现：<code>JSONDecodeError: Invalid control character at: line...</code>，说明文件格式不标准，添加参数<code>json.load(jf, strict=False)</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;./pois.json&#x27;</span>,<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    poi_list = json.load(f, strict=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<p><strong>情况2</strong>：文件是多个json对象组成的，理论上应该是存成[{},{}…]或类似的结构</p>
<ul>
<li>如通过记事本或notepad打开文件长这样，<strong>每行是一个json对象</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;created_at&quot;</span>:<span class="string">&quot;Sat Jul 01 13:00:00 +0000 2017&quot;</span>,<span class="string">&quot;id&quot;</span>:<span class="number">881135299081887744</span>,...&#125;</span><br><span class="line">&#123;<span class="string">&quot;id&quot;</span>:<span class="number">865709269722832896</span>,<span class="string">&quot;id_str&quot;</span>:<span class="string">&quot;865709269722832896&quot;</span>,<span class="string">&quot;user_id&quot;</span>...&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>处理逻辑：先读取文件再逐行/逐对象load加载</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 复合写法，将对象追加到list</span></span><br><span class="line">tweets = []</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">open</span>(<span class="string">&#x27;./dataset/tweets.json&#x27;</span>, <span class="string">&#x27;r&#x27;</span>):</span><br><span class="line">    tweets.append(json.loads(line))</span><br><span class="line"><span class="comment"># 拆开写</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;./dataset/tweets.json&#x27;</span>,<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:   </span><br><span class="line">    jsonstr_list = f.readlines()</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> jsonstr_list:</span><br><span class="line">    x = json.loads(line)</span><br><span class="line">    tweets.append(x)</span><br></pre></td></tr></table></figure>
<h3 id="中文显示"><a class="markdownIt-Anchor" href="#中文显示"></a> 中文显示</h3>
<p>输出文件中文编码显示<strong>ensure_ascii=False</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&quot;./china.json&quot;</span>,<span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    json.dump(ty_city,fp,indent=<span class="number">4</span>,ensure_ascii=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<h2 id="部分参考"><a class="markdownIt-Anchor" href="#部分参考"></a> 部分参考</h2>
<blockquote>
<p>详细的也可以自己查或看以下链接</p>
</blockquote>
<p>- <a href="https://docs.python.org/zh-cn/3.9/library/json.html#basic-usage">Json in python</a></p>
<p>- <a href="https://www.geeksforgeeks.org/working-with-json-data-in-python/">Working With JSON Data in Python</a></p>
<p>- <a href="https://www.geeksforgeeks.org/python-difference-between-json-dump-and-json-dumps/">dump vs dumps</a></p>
]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>json文件</tag>
      </tags>
  </entry>
  <entry>
    <title>文献篇(2) 论文下载</title>
    <url>/posts/99dce68a/</url>
    <content><![CDATA[<blockquote>
<p>个人平时下载文献的流程和几种方式…</p>
</blockquote>
<p>今天有人问我是怎么下载<strong>英文文献</strong>的？我大概捋了一下：</p>
<p>1.论文所在官网；2.<a href="https://scholar.google.com/">谷歌学术</a> + <a href="https://sci-hub.se/">Scihub</a>（优先doi号搜索）3.<a href="https://www.researchgate.net/">researchgate</a>，若作者未发可以点击<strong>请求全文</strong> 4…</p>
<span id="more"></span>
<h2 id="主页"><a class="markdownIt-Anchor" href="#主页"></a> 主页</h2>
<p>下载文献的目的通常是为了精度或者引用，所以我的习惯是首先应明确论文是否需要下载，这时候一般</p>
<ol>
<li>进到论文主页（通过名称或doi直接搜索直达）查看作者及摘要信息等，确定论文是否需要下载</li>
<li>确定下载后先看能不能通过主页下载，有的期刊本身是开源的或者作者选择了Open，这之后可以直接下，若不行则尝试机构登录</li>
<li>用科学院的邮箱进行机构登录可以解锁ELSEVIER及很多好期刊的资源，能通过机构下载的优先使用，这样的文章pdf质量也最好,如<a href="https://www.nature.com/articles/s41558-022-01344-2">示例1</a>，<a href="https://doi.org/10.1016/j.compenvurbsys.2022.101777">示例2</a></li>
</ol>
<img src="/posts/99dce68a/image-20220609213555174.png" class alt="image-20220609213555174">
<img src="/posts/99dce68a/image-20220609214043317.png" class alt="image-20220609214043317">
<h2 id="谷歌学术或scihub"><a class="markdownIt-Anchor" href="#谷歌学术或scihub"></a> 谷歌学术或SciHub</h2>
<blockquote>
<p>(<a href="https://scholar.google.com/">Google 学术搜索</a>)<a href="https://sci-hub.se/">Sci-Hub消除科学障碍</a></p>
<p>一般前面的操作不行我才会到scihub求助</p>
</blockquote>
<img src="/posts/99dce68a/image-20220609214239964.png" class alt="image-20220609214239964">
<img src="/posts/99dce68a/image-20220609214345185.png" class alt="image-20220609214345185">
<h2 id="researchgate"><a class="markdownIt-Anchor" href="#researchgate"></a> ResearchGate</h2>
<blockquote>
<p><a href="https://www.researchgate.net/">https://www.researchgate.net/</a></p>
</blockquote>
<p>很多学者都会在这里建立自己的个人建立，并及时添加个分享最新的研究成果，加上平台的学者网络和研究推荐，是个很实用的<strong>学者及论文追踪平台</strong></p>
<p>这里很多人会把论文的预印本或者发表后的pdf附在成果上，如果没有则可以<strong>请求全文</strong>，基本上有求必应（有点时间长可以尝试发邮件），有人对自己的研究感兴趣，这对于科研人员来说是件非常高兴的事情，如这周我就给两名陌生学者共享了组里的未开源的论文pdf</p>
<img src="/posts/99dce68a/image-20220609214948366.png" class alt="image-20220609214948366">
<h2 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h2>
<p>如果还不能找到自己的文献可以求助他人同学，或者给论文作者发邮件</p>
<p>以上~</p>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>论文下载</tag>
      </tags>
  </entry>
  <entry>
    <title>文献篇(3) 如何开展研究背景调研和总结？</title>
    <url>/posts/e8c71149/</url>
    <content><![CDATA[<blockquote>
<p>待补充</p>
</blockquote>
<p>本文预计包含以下内容：</p>
<p>①为什么要进行文献调研和现状分析？ ②要把握的重难点是？  ③怎么查文献读文献？<br>
④ 应用类？方法类？如何总结归纳？   ⑤论文背景部分怎么写？</p>
<span id="more"></span>
<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2>
<blockquote>
<p>最近一个多月的时间，由于团队在进行几个项目的申请工作，所以非常密集地针对几个较为宽泛的研究主题进行了<u>文献调研、研究现状归纳总结和撰写研究背景</u>，过程中有了很多收获，遂想花点时间静心整理一下自己入学一年多时间里在读文献，调查研究现状和写背景方面的一些习惯和心得。[这周加班干活，具体内容待闲暇时间补充……20220609]</p>
</blockquote>
<h2 id="why"><a class="markdownIt-Anchor" href="#why"></a> Why</h2>
<blockquote>
<p>为什么要读文献</p>
<p>为什么要开展背景调研</p>
</blockquote>
<h2 id="what"><a class="markdownIt-Anchor" href="#what"></a> What</h2>
<blockquote>
<p>文献的类别</p>
<p>阅读的类别</p>
</blockquote>
<h2 id="how-读"><a class="markdownIt-Anchor" href="#how-读"></a> How -&gt;读</h2>
<blockquote>
<p>怎么检索查阅及下载文献</p>
<p>怎么读和记</p>
</blockquote>
<h2 id="how-思"><a class="markdownIt-Anchor" href="#how-思"></a> How -&gt; 思</h2>
<blockquote>
<p>如何梳理与总结</p>
</blockquote>
<h2 id="how-写"><a class="markdownIt-Anchor" href="#how-写"></a> How -&gt; 写</h2>
<blockquote>
<p>怎么写科技论文研究背景</p>
<p>怎么写申报书研究现状</p>
</blockquote>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>文献</tag>
      </tags>
  </entry>
  <entry>
    <title>矢栅处理(5)：R语言nc转多张Geotif</title>
    <url>/posts/ef2a4876/</url>
    <content><![CDATA[<p>下载了天尺度1km格网的中国区域的温度数据，nc文件格式，需要先裁剪并输出为tif以便后续的提取工作，在Python里折腾老半天不得劲，最后用<strong>R语言完成</strong>。</p>
<span id="more"></span>
<p>这几天的数据处理工作让我感觉Python对于栅格数据的支持不够友好，而且性能捉急，往后类似的工作尽量上手R语言做，<strong>R语言对栅格处理友好且速度更快</strong>。</p>
<h2 id="包"><a class="markdownIt-Anchor" href="#包"></a> 包</h2>
<p>安装</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">install.packages<span class="punctuation">(</span><span class="string">&quot;ncdf4&quot;</span><span class="punctuation">)</span></span><br><span class="line">install.packages<span class="punctuation">(</span><span class="string">&quot;raster&quot;</span><span class="punctuation">)</span></span><br><span class="line">install.packages<span class="punctuation">(</span><span class="string">&quot;rgdal&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>文档查看：<a href="https://cran.r-project.org/web/packages/raster/index.html">raster 包</a>，<a href="https://cran.r-project.org/web/packages/raster/raster.pdf">API文档</a>，<a href="https://cran.r-project.org/web/packages/rgdal/index.html">rgdal</a></p>
<h2 id="nc写tif"><a class="markdownIt-Anchor" href="#nc写tif"></a> nc写tif</h2>
<ol>
<li>基于研究区裁剪数据</li>
</ol>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>ncdf4<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>raster<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>rgdal<span class="punctuation">)</span></span><br><span class="line">study_area <span class="operator">=</span> <span class="string">&quot;A:/my_research/Studyarea.shp&quot;</span></span><br><span class="line">extent <span class="operator">&lt;-</span> shapefile<span class="punctuation">(</span>study_area<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>读取文件并拆分，循环写入</li>
<li>说明（可以自行输出中间过程文件查看）：ncbr输出即为读入的nc文件，包含其数据的维度及名称等等，自行查看</li>
</ol>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">outdir <span class="operator">=</span> <span class="string">&quot;E:/Datasets/temp/tif/prep/&quot;</span></span><br><span class="line">ncfile <span class="operator">=</span> <span class="string">&quot;E:/Datasets/temp/China_1km_prep_2017.nc&quot;</span></span><br><span class="line">ncbr <span class="operator">=</span> brick<span class="punctuation">(</span>ncfile<span class="punctuation">,</span>varname <span class="operator">=</span> <span class="string">&quot;prep&quot;</span><span class="punctuation">,</span>lvar<span class="operator">=</span><span class="number">4</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">filenames <span class="operator">=</span> paste0<span class="punctuation">(</span>outdir<span class="punctuation">,</span>ncbr<span class="operator">@</span>data<span class="operator">@</span><span class="built_in">names</span><span class="punctuation">,</span><span class="string">&quot;.tif&quot;</span><span class="punctuation">)</span></span><br><span class="line">nlayers <span class="operator">=</span> <span class="built_in">length</span><span class="punctuation">(</span>filenames<span class="punctuation">)</span></span><br><span class="line"><span class="keyword">for</span><span class="punctuation">(</span>i <span class="keyword">in</span> <span class="number">1</span><span class="operator">:</span>nlayers<span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line">  r <span class="operator">=</span> ncbr<span class="punctuation">[[</span>i<span class="punctuation">]</span><span class="punctuation">]</span> <span class="comment">#取一个图层</span></span><br><span class="line">  rc <span class="operator">=</span> crop<span class="punctuation">(</span>r<span class="punctuation">,</span>shp<span class="punctuation">)</span> <span class="comment"># 范围筛选</span></span><br><span class="line">  writeRaster<span class="punctuation">(</span>rc<span class="punctuation">,</span> filenames<span class="punctuation">[</span>i<span class="punctuation">]</span><span class="punctuation">,</span> bylayer<span class="operator">=</span><span class="literal">TRUE</span><span class="punctuation">,</span> format <span class="operator">=</span> <span class="string">&quot;GTiff&quot;</span><span class="punctuation">,</span>overwrite <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span>options<span class="operator">=</span><span class="string">&quot;COMPRESS=LZW&quot;</span><span class="punctuation">,</span>NAflag<span class="operator">=</span><span class="operator">-</span><span class="number">1</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>不过貌似不能直接按照shapefile边界形状裁剪？</p>
]]></content>
      <categories>
        <category>时空数据处理分析</category>
      </categories>
      <tags>
        <tag>R语言</tag>
        <tag>GeoTIFF</tag>
        <tag>nc文件</tag>
      </tags>
  </entry>
  <entry>
    <title>R语言学习(1)：基础</title>
    <url>/posts/7b2f7b5e/</url>
    <content><![CDATA[<blockquote>
<p><strong>从Python到R</strong>~</p>
</blockquote>
<p>相比于Python，R语言在进行统计分析建模及可视化方面有明显优势，且很多算法提供了R版本但不一定有Python。而两种语言在数据处理分析等方面其实相像，因此可以通过<strong>类比</strong>熟悉一下R语言，以便快速上手R并完成一些工作。本文小结R语言基础，主要涉及</p>
<ol>
<li>基本语法，数据类型</li>
<li>常用函数，流程控制（写循环）</li>
<li>文件读写及数据框的常规操作</li>
</ol>
<span id="more"></span>
<p>目前我用Python最常用的有以下操作：</p>
<ol>
<li>用列表或字典存数据；写for循环；创建DataFrame。</li>
<li>批量获取文件名；读写csv文件，获取表格字段信息等；行列筛选；分组聚合。</li>
<li>对DataFrame进行运算，apply函数应用。</li>
</ol>
<p>R的基础语法和数据类型？在R中上述常规操作如何实现？</p>
<img src="/posts/7b2f7b5e/dataframe.png" class alt="dataframe">
<h2 id="r基础"><a class="markdownIt-Anchor" href="#r基础"></a> R基础</h2>
<h3 id="对象类型"><a class="markdownIt-Anchor" href="#对象类型"></a> 对象类型</h3>
<blockquote>
<p>R中的对象即是我们通常理解的变量</p>
<p><strong>R的索引默认从1开始而非0</strong></p>
</blockquote>
<p>数值类型：TRUE/FLASE; integer; numric; complex; character; raw(二进制)</p>
<p>特殊：Inf(正无穷); -Inf; NaN(非数字); NA(缺失，不存在); NULL(空变量，元素存在但是没赋值)</p>
<ol>
<li>向量/Vector，<code>c()</code>，相当于数组，其内元素的类型必须相同</li>
<li>列表/List，<code>list()</code>，类似于Python中的list但是包容性更强，可以同时包含多种不同类型的数据</li>
<li>矩阵/Matrix，<code>matrix()</code>,二维数组</li>
<li>数组/Array，<code>array()</code></li>
<li>因子/Factor，<code>factor()</code>，类别变量</li>
<li>数据框/Data Frame，<code>data.frame()</code>，表格数据，每列为一个向量，列名为name</li>
</ol>
<h3 id="运算"><a class="markdownIt-Anchor" href="#运算"></a> 运算</h3>
<ol>
<li>
<p>比较：用<code>==; !=</code>来比较整数/向量/字符串是否相等，用<code>all.equal(a,b)</code>比较两个数字</p>
</li>
<li>
<p>变量赋值：<code>&lt;-; =</code>，都可以 无区别，个人习惯=，全局变量赋值<code>&lt;&lt;-</code></p>
</li>
<li>
<p>逻辑向量：<code>&amp; ! |</code>，与非或，根据向量生成逻辑向量<code>any();all()</code></p>
</li>
</ol>
<h3 id="循环流程控制"><a class="markdownIt-Anchor" href="#循环流程控制"></a> 循环/流程控制</h3>
<ol>
<li><code>if else</code></li>
</ol>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span><span class="punctuation">(</span>x<span class="operator">&gt;</span><span class="number">3</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    y<span class="operator">=</span><span class="number">6</span></span><br><span class="line"><span class="punctuation">&#125;</span> <span class="keyword">else</span></span><br><span class="line"><span class="punctuation">&#123;</span>message<span class="punctuation">(</span><span class="string">&quot;ok&quot;</span><span class="punctuation">)</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li><code>repeat</code>循环，结合<code>next; break</code></li>
</ol>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">n<span class="operator">=</span><span class="number">0</span>;j<span class="operator">=</span><span class="number">0</span></span><br><span class="line">message<span class="punctuation">(</span><span class="string">&quot;do while&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="keyword">repeat</span><span class="punctuation">&#123;</span></span><br><span class="line">  n<span class="operator">=</span>n<span class="operator">+</span><span class="number">1</span></span><br><span class="line">  <span class="keyword">if</span><span class="punctuation">(</span>n<span class="operator">%%</span><span class="number">7</span><span class="operator">==</span><span class="number">0</span><span class="punctuation">)</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    message<span class="punctuation">(</span>n<span class="punctuation">)</span></span><br><span class="line">    <span class="keyword">next</span>  <span class="comment">#跳过后续代码直接进入下一次迭代</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line">  j<span class="operator">=</span>j<span class="operator">+</span><span class="number">1</span></span><br><span class="line">  <span class="keyword">if</span><span class="punctuation">(</span>n<span class="operator">==</span><span class="number">100</span><span class="punctuation">)</span> <span class="keyword">break</span> <span class="comment">#结束循环</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="comment"># j=86，跳过了14次</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li><code>while</code>循环，直接用</li>
<li><code>for</code>循环</li>
</ol>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span><span class="punctuation">(</span>i <span class="keyword">in</span> <span class="number">1</span><span class="operator">:</span><span class="number">5</span><span class="punctuation">)</span><span class="punctuation">&#123;</span><span class="punctuation">&#125;</span> </span><br><span class="line"><span class="keyword">for</span><span class="punctuation">(</span>n <span class="keyword">in</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="literal">TRUE</span><span class="punctuation">,</span> <span class="literal">FALSE</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="常用函数"><a class="markdownIt-Anchor" href="#常用函数"></a> 常用函数</h2>
<h3 id="查看信息"><a class="markdownIt-Anchor" href="#查看信息"></a> 查看信息</h3>
<p><code>library(bfast)</code>: 导入三方包，此处为bfast</p>
<p><code>Rscript test.R </code>：运行脚本</p>
<p><code>ls()</code>：查看所有变量，ls(pattern=“ab”)可以正则匹配</p>
<p><code>rm(list=ls())</code>：删除所有变量</p>
<p><code>class(); mode(); typeof()</code>:查看变量/数值类型：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">x <span class="operator">=</span> array<span class="punctuation">(</span><span class="number">1</span><span class="operator">:</span><span class="number">24</span><span class="punctuation">,</span> <span class="built_in">dim</span><span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">4</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="built_in">class</span><span class="punctuation">(</span>x<span class="punctuation">)</span> <span class="comment">#&quot;array&quot;</span></span><br><span class="line">mode<span class="punctuation">(</span>x<span class="punctuation">)</span> <span class="comment">#&quot;numeric&quot;</span></span><br><span class="line">typeof<span class="punctuation">(</span>x<span class="punctuation">)</span> <span class="comment">#&quot;integer&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>length()</code>：计算向量长度</p>
<p><code>dim()</code>：返回多维向量的维度</p>
<p><code>names()</code>：对象命名, R中可以给每个对象赋予名称，类似于字典的<strong>键</strong></p>
<p><code>unlist()</code>；将多维list展开成一维</p>
<p><code>options(digits=n)</code>：设置全局小数点显示位数</p>
<p><code>summary()</code>:汇总函数，输出向量最大最小值四分位数等信息，也可以作用与data.frame，每列的汇总信息</p>
<p><code>attribute/</code>查看对象的所有属性裂变</p>
<p><code>View()</code>以电子表格的形式查看data.frame</p>
<h3 id="文件路径相关"><a class="markdownIt-Anchor" href="#文件路径相关"></a> 文件路径相关</h3>
<blockquote>
<p>R中支持正斜杠<code>/</code>或双反斜杠<code>\\</code></p>
</blockquote>
<p><code>path = getwd()</code>：返回当前工作路径</p>
<p><code>file.path(&quot;c&quot;,&quot;program files&quot;,&quot;R&quot;)</code>:拼接，类似于Python中的os.path.join()</p>
<p><code>files = dir(path ,pattern = &quot;\\.csv$&quot;)</code>：返回路径下所有csv文件名</p>
<p><code>filenames = dir(path ,pattern = &quot;\\.csv$&quot;, full.names = TRUE)</code>:返回文件名绝对路径</p>
<p><code>basename(file)</code>：文件名</p>
<p><code>path.expand(&quot;~&quot;)</code>：返回当前绝对&quot;C:/Users/huangs/Documents&quot;</p>
<h3 id="创建字典name"><a class="markdownIt-Anchor" href="#创建字典name"></a> 创建”字典name”</h3>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">x <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="operator">:</span><span class="number">4</span><span class="punctuation">)</span></span><br><span class="line"><span class="built_in">names</span><span class="punctuation">(</span>x<span class="punctuation">)</span> <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&#x27;a1&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;a2&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;a3&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;a4&#x27;</span><span class="punctuation">)</span></span><br><span class="line">x<span class="punctuation">[</span><span class="string">&#x27;a1&#x27;</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<h3 id="创建序列range"><a class="markdownIt-Anchor" href="#创建序列range"></a> 创建序列”range”</h3>
<p><code>1:10</code>：创建一个1~10的序列</p>
<p><code>seq(); seq.int()</code>：相当于Python中的range()</p>
<p><code>seq_alone(x)</code>：创建一个和x一样长的，从1开始的序列</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">seq<span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> length.out <span class="operator">=</span> <span class="number">11</span><span class="punctuation">)</span> <span class="comment"># 0.1~1.0</span></span><br><span class="line"><span class="built_in">seq.int</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span><span class="number">10</span><span class="punctuation">)</span> <span class="comment">#0 1 ... 10</span></span><br><span class="line">seq<span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">9</span><span class="punctuation">,</span> by <span class="operator">=</span> <span class="number">2</span><span class="punctuation">)</span>     <span class="comment"># 1 3 5 7 9</span></span><br><span class="line">seq<span class="punctuation">(</span><span class="number">1.575</span><span class="punctuation">,</span> <span class="number">5.125</span><span class="punctuation">,</span> by <span class="operator">=</span> <span class="number">0.05</span><span class="punctuation">)</span></span><br><span class="line">seq<span class="punctuation">(</span><span class="number">17</span><span class="punctuation">)</span> <span class="comment">#等价于seq.int(17) seq(1:17) seq_len(17)</span></span><br></pre></td></tr></table></figure>
<p><code>rep(1:5),3</code>：基于一个序列的重复构造新序列，有多个参数可选，可以自定义重复规则</p>
<p><code>runif(30，1, 50)</code>：服从标准/随机分布的30个数，random uniform seq</p>
<h3 id="创建时间序列"><a class="markdownIt-Anchor" href="#创建时间序列"></a> 创建时间序列</h3>
<blockquote>
<p>有关R中的时间在另外的笔记中进行总结</p>
</blockquote>
<p>seq.Date: Generate Regular Sequences of Dates。<a href="https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/seq.Date">api</a></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">## first days of years</span></span><br><span class="line">seq<span class="punctuation">(</span>as.Date<span class="punctuation">(</span><span class="string">&quot;1910/1/1&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> as.Date<span class="punctuation">(</span><span class="string">&quot;1999/1/1&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="string">&quot;years&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">## by month</span></span><br><span class="line">seq<span class="punctuation">(</span>as.Date<span class="punctuation">(</span><span class="string">&quot;2000/1/1&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> by <span class="operator">=</span> <span class="string">&quot;month&quot;</span><span class="punctuation">,</span> length.out <span class="operator">=</span> <span class="number">12</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">## quarters</span></span><br><span class="line">seq<span class="punctuation">(</span>as.Date<span class="punctuation">(</span><span class="string">&quot;2000/1/1&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> as.Date<span class="punctuation">(</span><span class="string">&quot;2003/1/1&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> by <span class="operator">=</span> <span class="string">&quot;quarter&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## find all 7th of the month between two dates, the last being a 7th.</span></span><br><span class="line">st <span class="operator">&lt;-</span> as.Date<span class="punctuation">(</span><span class="string">&quot;1998-12-17&quot;</span><span class="punctuation">)</span></span><br><span class="line">en <span class="operator">&lt;-</span> as.Date<span class="punctuation">(</span><span class="string">&quot;2000-1-7&quot;</span><span class="punctuation">)</span></span><br><span class="line">ll <span class="operator">&lt;-</span> seq<span class="punctuation">(</span>en<span class="punctuation">,</span> st<span class="punctuation">,</span> by <span class="operator">=</span> <span class="string">&quot;-1 month&quot;</span><span class="punctuation">)</span></span><br><span class="line">rev<span class="punctuation">(</span>ll<span class="punctuation">[</span>ll <span class="operator">&gt;</span> st <span class="operator">&amp;</span> ll <span class="operator">&lt;</span> en<span class="punctuation">]</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>seq.POSIXt: Generate Regular Sequences of Times。<a href="https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/seq.POSIXt">api</a></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">## first days of years</span></span><br><span class="line">seq<span class="punctuation">(</span>ISOdate<span class="punctuation">(</span><span class="number">1910</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">)</span><span class="punctuation">,</span> ISOdate<span class="punctuation">(</span><span class="number">1999</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="string">&quot;years&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">## by month</span></span><br><span class="line">seq<span class="punctuation">(</span>ISOdate<span class="punctuation">(</span><span class="number">2000</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">)</span><span class="punctuation">,</span> by <span class="operator">=</span> <span class="string">&quot;month&quot;</span><span class="punctuation">,</span> length.out <span class="operator">=</span> <span class="number">12</span><span class="punctuation">)</span></span><br><span class="line">seq<span class="punctuation">(</span>ISOdate<span class="punctuation">(</span><span class="number">2000</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">31</span><span class="punctuation">)</span><span class="punctuation">,</span> by <span class="operator">=</span> <span class="string">&quot;month&quot;</span><span class="punctuation">,</span> length.out <span class="operator">=</span> <span class="number">4</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">## quarters</span></span><br><span class="line">seq<span class="punctuation">(</span>ISOdate<span class="punctuation">(</span><span class="number">1990</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">)</span><span class="punctuation">,</span> ISOdate<span class="punctuation">(</span><span class="number">2000</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">)</span><span class="punctuation">,</span> by <span class="operator">=</span> <span class="string">&quot;quarter&quot;</span><span class="punctuation">)</span> <span class="comment"># or &quot;3 months&quot;</span></span><br><span class="line"><span class="comment">## days vs DSTdays: use c() to lose the time zone.</span></span><br><span class="line">seq<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span>ISOdate<span class="punctuation">(</span><span class="number">2000</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">20</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span> by <span class="operator">=</span> <span class="string">&quot;day&quot;</span><span class="punctuation">,</span> length.out <span class="operator">=</span> <span class="number">10</span><span class="punctuation">)</span></span><br><span class="line">seq<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span>ISOdate<span class="punctuation">(</span><span class="number">2000</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">20</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span> by <span class="operator">=</span> <span class="string">&quot;DSTday&quot;</span><span class="punctuation">,</span> length.out <span class="operator">=</span> <span class="number">10</span><span class="punctuation">)</span></span><br><span class="line">seq<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span>ISOdate<span class="punctuation">(</span><span class="number">2000</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">20</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span> by <span class="operator">=</span> <span class="string">&quot;7 DSTdays&quot;</span><span class="punctuation">,</span> length.out <span class="operator">=</span> <span class="number">4</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<h3 id="apply运算"><a class="markdownIt-Anchor" href="#apply运算"></a> apply运算</h3>
<ul>
<li>
<p><code>lapply(list(),f(x))</code>：<code>&quot;list apply&quot;</code>，</p>
<ul>
<li>对<strong>list</strong>中的每一个元素依次计算<code>f()</code>，并返回一个新的<strong>list</strong></li>
</ul>
</li>
<li>
<p><code>vapply(list()/vector(), f(x), numeric(1))</code>：<code>&quot;vaetor apply&quot;</code>：返回vector，但需要确保结果可用vector包装并指定返回的数据类型及长度</p>
</li>
<li>
<p><code>eapply()</code>；遍历环境中的变量</p>
</li>
<li>
<p><code>mapply()</code>:多参数apply，</p>
</li>
<li>
<p><code>tapply</code>：类似<strong>group by</strong>，<code>with(data, tapply(x1, x2, f()))</code></p>
<ul>
<li><code>by, aggregate</code></li>
</ul>
</li>
<li>
<p><code>library(plyr)</code>：指定输入输出形式的apply函数</p>
<ul>
<li><code>ddply()</code>; 输入输出为<strong>data.frame</strong></li>
<li><code>llply()</code>；输入输出均为list</li>
<li><code>laply()</code>；输入list，输出array</li>
</ul>
</li>
</ul>
<h3 id="csv读写"><a class="markdownIt-Anchor" href="#csv读写"></a> CSV读写</h3>
<ul>
<li>
<p>数据加载：<code>load(file = &quot;...rda&quot;)</code></p>
</li>
<li>
<p>csv读写：</p>
</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">df <span class="operator">=</span> read.csv<span class="punctuation">(</span>path<span class="punctuation">,</span> header <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span>encoding <span class="operator">=</span> <span class="string">&quot;UTF-8&quot;</span><span class="punctuation">)</span></span><br><span class="line">write.csv<span class="punctuation">(</span>df<span class="punctuation">,</span>file <span class="operator">=</span> <span class="string">&#x27;....csv&#x27;</span><span class="punctuation">,</span>row.names <span class="operator">=</span> <span class="built_in">F</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<h3 id="异常捕获"><a class="markdownIt-Anchor" href="#异常捕获"></a> 异常捕获</h3>
<p>trycatch</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">tryCatch<span class="punctuation">(</span><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment"># 待执行/判断的代码</span></span><br><span class="line">    a<span class="operator">+</span>b</span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span> warning <span class="operator">=</span> <span class="keyword">function</span><span class="punctuation">(</span>w<span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="comment"># 出现warning状态时执行，可以输出警告，也可以执行其它命令</span></span><br><span class="line">    print<span class="punctuation">(</span><span class="string">&quot;warning&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span> error <span class="operator">=</span> <span class="keyword">function</span><span class="punctuation">(</span>e<span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="comment"># 出现Error状态时执行，可以输出错误，也可以执行其它命令</span></span><br><span class="line">    print<span class="punctuation">(</span>error<span class="punctuation">)</span></span><br><span class="line">    k <span class="operator">=</span> <span class="operator">-</span><span class="number">1</span></span><br><span class="line">    print<span class="punctuation">(</span>k<span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span>finally <span class="operator">=</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="built_in">return</span><span class="punctuation">(</span>k<span class="punctuation">)</span></span><br><span class="line">  <span class="comment"># 这里的代码最后一定会执行</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<h2 id="表格操作"><a class="markdownIt-Anchor" href="#表格操作"></a> 表格操作</h2>
<blockquote>
<p>R中的data.frame类似于Python的pandas dataframe ，用于表示表格型数据，应用十分灵活方便</p>
</blockquote>
<h3 id="行列选择"><a class="markdownIt-Anchor" href="#行列选择"></a> 行列选择</h3>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建</span></span><br><span class="line">data.frame<span class="punctuation">(</span></span><br><span class="line">x <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span>..<span class="punctuation">)</span></span><br><span class="line">y <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span>..<span class="punctuation">)</span></span><br><span class="line">z <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span>..<span class="punctuation">)</span></span><br><span class="line"><span class="built_in">names</span> <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&#x27;ID&#x27;</span><span class="punctuation">,</span>...<span class="punctuation">)</span></span><br><span class="line">row.names <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span>...<span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<img src="/posts/7b2f7b5e/dataframe.png" class alt="image-20220607230008504">
<p>其他操作</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取表格信息</span></span><br><span class="line">str<span class="punctuation">(</span>df<span class="punctuation">)</span></span><br><span class="line">summary<span class="punctuation">(</span>df<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#转置</span></span><br><span class="line">t<span class="punctuation">(</span>df<span class="punctuation">)</span> </span><br><span class="line">colSums<span class="punctuation">(</span>df<span class="punctuation">[</span><span class="punctuation">,</span><span class="punctuation">]</span><span class="punctuation">)</span><span class="operator">/</span>colMeans<span class="punctuation">(</span>df<span class="punctuation">[</span><span class="punctuation">,</span><span class="punctuation">]</span><span class="punctuation">)</span> <span class="comment">#计算列的和及均值</span></span><br><span class="line"><span class="comment"># 增加新列</span></span><br><span class="line">df<span class="operator">$</span>new_col <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span>..<span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 增加新行，拼接两个df</span></span><br><span class="line">newdf <span class="operator">=</span> rbind<span class="punctuation">(</span>df1<span class="punctuation">,</span> df2<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<h3 id="新建并追加dataframe"><a class="markdownIt-Anchor" href="#新建并追加dataframe"></a> 新建并追加data.frame</h3>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">outfile <span class="operator">=</span> <span class="string">&quot;../.*csv&quot;</span></span><br><span class="line">out.table <span class="operator">=</span> data.frame<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line"><span class="keyword">for</span> <span class="punctuation">(</span>colname <span class="keyword">in</span> <span class="built_in">names</span><span class="punctuation">(</span>df<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line">    gridid <span class="operator">=</span> colname</span><br><span class="line">    x <span class="operator">=</span> df<span class="punctuation">[</span><span class="punctuation">,</span>colname<span class="punctuation">]</span></span><br><span class="line">    res <span class="operator">=</span> myfun<span class="punctuation">(</span>x<span class="punctuation">)</span></span><br><span class="line">    k <span class="operator">=</span> res<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span></span><br><span class="line">    pvalue <span class="operator">=</span> res<span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span></span><br><span class="line">    ktime <span class="operator">=</span> times<span class="punctuation">[</span>k<span class="punctuation">]</span></span><br><span class="line">      <span class="comment"># Populate the row</span></span><br><span class="line">    new.row <span class="operator">=</span> data.frame<span class="punctuation">(</span>gridid <span class="operator">=</span> gridid<span class="punctuation">,</span> ktime <span class="operator">=</span> ktime<span class="punctuation">,</span> pvalue <span class="operator">=</span> pvalue<span class="punctuation">)</span></span><br><span class="line">    out.table <span class="operator">=</span> rbind<span class="punctuation">(</span>out.table<span class="punctuation">,</span> new.row<span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line">write.csv<span class="punctuation">(</span>outfile<span class="punctuation">,</span>file <span class="operator">=</span> outfile<span class="punctuation">,</span> row.names <span class="operator">=</span> <span class="built_in">F</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<h3 id="拆分"><a class="markdownIt-Anchor" href="#拆分"></a> 拆分</h3>
<p><code>groups = split(df, df$Quarter)</code>：返回的是<strong>dflist</strong>，通过索引访问，如<strong>groups[1]</strong></p>
<p>拆分后遍历</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">df &lt;- data.frame(</span><br><span class="line">  Weekday = factor(rep(c(&quot;Mon&quot;, &quot;Tues&quot;, &quot;Wed&quot;, &quot;Thurs&quot;, &quot;Fri&quot;), each = 4), </span><br><span class="line">                   levels = c(&quot;Mon&quot;, &quot;Tues&quot;, &quot;Wed&quot;, &quot;Thurs&quot;, &quot;Fri&quot;)),</span><br><span class="line">  Quarter = paste0(&quot;Q&quot;, rep(1:4, each = 5)), </span><br><span class="line">  Delay = c(9.9, 5.4, 8.8, 6.9, 4.9, 9.7, 7.9, 5, 8.8, 11.1, 10.2, 9.3, 12.2,</span><br><span class="line">            10.2, 9.2, 9.7, 12.2, 8.1, 7.9, 5.6))</span><br><span class="line">            </span><br><span class="line">gs = split(df, df$Quarter)</span><br><span class="line">for(gp in gs)</span><br><span class="line">&#123;</span><br><span class="line">  tempdf = data.frame(gp)</span><br><span class="line">  print(tempdf$Weekday)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="dplyr包"><a class="markdownIt-Anchor" href="#dplyr包"></a> dplyr包</h2>
<blockquote>
<p>一个功能强大的数据处理包<a href="https://dplyr.tidyverse.org/">dplyr</a></p>
</blockquote>
<p>安装：<code>install.packages(&quot;tidyverse&quot;)</code>;<code>install.packages(&quot;dplyr&quot;)</code></p>
<p><code>%&gt;%</code>管道操作符，该符号的意思是将前者作为后者的输入参数进行传入</p>
<h3 id="拆分group_split"><a class="markdownIt-Anchor" href="#拆分group_split"></a> 拆分group_split</h3>
<h3 id="groupby分类汇总"><a class="markdownIt-Anchor" href="#groupby分类汇总"></a> Groupby分类汇总</h3>
<p>参考<a href="https://mgimond.github.io/ES218/Week03ab_groupby.html#Count_the_number_of_records_in_each_group">1</a></p>
<p>操作实例</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">df <span class="operator">&lt;-</span> data.frame<span class="punctuation">(</span></span><br><span class="line">  Weekday <span class="operator">=</span> factor<span class="punctuation">(</span><span class="built_in">rep</span><span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;Mon&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Tues&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Wed&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Thurs&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Fri&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> each <span class="operator">=</span> <span class="number">4</span><span class="punctuation">)</span><span class="punctuation">,</span> </span><br><span class="line">                   levels <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;Mon&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Tues&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Wed&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Thurs&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Fri&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">  Quarter <span class="operator">=</span> paste0<span class="punctuation">(</span><span class="string">&quot;Q&quot;</span><span class="punctuation">,</span> <span class="built_in">rep</span><span class="punctuation">(</span><span class="number">1</span><span class="operator">:</span><span class="number">4</span><span class="punctuation">,</span> each <span class="operator">=</span> <span class="number">5</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span> </span><br><span class="line">  Delay <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">9.9</span><span class="punctuation">,</span> <span class="number">5.4</span><span class="punctuation">,</span> <span class="number">8.8</span><span class="punctuation">,</span> <span class="number">6.9</span><span class="punctuation">,</span> <span class="number">4.9</span><span class="punctuation">,</span> <span class="number">9.7</span><span class="punctuation">,</span> <span class="number">7.9</span><span class="punctuation">,</span> <span class="number">5</span><span class="punctuation">,</span> <span class="number">8.8</span><span class="punctuation">,</span> <span class="number">11.1</span><span class="punctuation">,</span> <span class="number">10.2</span><span class="punctuation">,</span> <span class="number">9.3</span><span class="punctuation">,</span> <span class="number">12.2</span><span class="punctuation">,</span></span><br><span class="line">            <span class="number">10.2</span><span class="punctuation">,</span> <span class="number">9.2</span><span class="punctuation">,</span> <span class="number">9.7</span><span class="punctuation">,</span> <span class="number">12.2</span><span class="punctuation">,</span> <span class="number">8.1</span><span class="punctuation">,</span> <span class="number">7.9</span><span class="punctuation">,</span> <span class="number">5.6</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">library<span class="punctuation">(</span>dplyr<span class="punctuation">)</span></span><br><span class="line">df <span class="operator">%&gt;%</span> </span><br><span class="line">  group_by<span class="punctuation">(</span>Weekday<span class="punctuation">)</span> <span class="operator">%&gt;%</span> </span><br><span class="line">  summarize<span class="punctuation">(</span>min_delay <span class="operator">=</span> <span class="built_in">min</span><span class="punctuation">(</span>Delay<span class="punctuation">)</span><span class="punctuation">,</span> max_delay <span class="operator">=</span> <span class="built_in">max</span><span class="punctuation">(</span>Delay<span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>R语言</category>
      </categories>
      <tags>
        <tag>R语言</tag>
      </tags>
  </entry>
  <entry>
    <title>在读书籍:《流畅的Python》</title>
    <url>/posts/15750410/</url>
    <content><![CDATA[<blockquote>
<p>持续阅读并更新</p>
</blockquote>
<p>本书对Python的数据模型/类型和一些基础有一些深入的讲解。翻译自国外的书籍《Fluent Python》，最早2017年出版，我大概是18年买的，那阵子Python刚开始火，不过买了发现过了好几年都看不懂，现在勉强能抽空看看hh…</p>
<span id="more"></span>
<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2>
<blockquote>
<p>Python3官方教程开头是这样写的：”Python是一门既容易上手又强大的编程语言。”这句话本身并无大碍，但正因为它这一特性，很多人都只用到了其强大功能的一小部分…</p>
</blockquote>
<p>作者本书强调Python的独有特性，专注于基本库。作者表明尽管Python的包索引已经极多，但是他几乎不会提到标准库以外的任何包。</p>
<p>赞！因为接触过一段时间的工作会发现三方包的性能方面参差不齐，实际中需要代码优化和加速的场景越来越频繁，而如果能够多调用标准库，充分发挥Python特性，我想应该是可以有助于代码运行效率提高的。</p>
<h2 id="第一部分-python数据模型"><a class="markdownIt-Anchor" href="#第一部分-python数据模型"></a> 第一部分-Python数据模型</h2>
<blockquote>
<p>浅浅介绍一下Python一些<strong>数据类型/类</strong>的底层构造模式</p>
</blockquote>
<p>要点</p>
<ol>
<li>Python中的内置类型实现了很多特殊方法（以双下划线开头如<code>__getitem__()</code>），也就是函数，来实现一些比较基本的操作，如：<strong>迭代/循环、属性访问、对象实例创建删除、字符串表示，文件管理(with…)等</strong></li>
<li>所以当需要使用内置类型实现上述相关功能时，用<strong>内置的方法：速度更快，优先考虑</strong>，如<code>len(x)</code>，若x是一个内置类型如list的实例，那么运行就快，相当于<strong>走后门</strong>。</li>
<li>下一部分的主要目的就是熟悉和了解Python内置的<strong>数据类型的底层特性及内置方法</strong>：序列（列表、元组）、字典、集合等，特殊用法，从而提高代码的性能</li>
</ol>
<h2 id="数据结构序列列表元组"><a class="markdownIt-Anchor" href="#数据结构序列列表元组"></a> 数据结构——序列(列表+元组…)</h2>
<blockquote>
<p>第二部分是数据结构，包含三部分</p>
<p>1 序列和数组; 2 字典和集合; 3 文本和字节序列</p>
</blockquote>
<h3 id="list和推导式"><a class="markdownIt-Anchor" href="#list和推导式"></a> list和推导式</h3>
<ol>
<li>
<p>序列就是一个能装很多类似数据的可以遍历的数据，比如list可以装很多个元素，string可以有逐字符遍历。</p>
</li>
<li>
<p>序列分类</p>
<ol>
<li>按能不能放不同类型的数据分为：容器序列（list tuple…）、扁平序列(str array.array…)，后者小而快，前者更灵活</li>
<li>按是否可变（简单理解为自由增删改）分可变和不可变，如<strong>list dict属于可变</strong>，<strong>str tuple不可变</strong></li>
</ol>
</li>
<li>
<p>list使用要点：</p>
<ol>
<li>多使用<strong>列表推导式</strong>，但一般只用于<strong>创建</strong>新列表，一行不能搞定的也不用</li>
<li>生成器-列表推导，将列表推导的[]换成()就得到了生成器，生成器就是动态吐出元素不会直接创建，<strong>元素在调用时再生成</strong>，一次性的，每个只能吐一次
<ul>
<li>节省内存，避免额外内存消耗，大数据考虑</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="元组tuple及的使用"><a class="markdownIt-Anchor" href="#元组tuple及的使用"></a> 元组tuple及<code>*</code>的使用</h3>
<ol>
<li>元组相当于<strong>一行记录</strong>，同属一个元组的这些数据是隐形绑定的，相当于表格的一行</li>
<li>元组拆包的妙用：显式或隐式的都有，很方便，举例：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 平行复制</span></span><br><span class="line">loc = (<span class="number">33.9</span>, <span class="number">118.5</span>)</span><br><span class="line">lat, lng = loc</span><br><span class="line"><span class="comment"># 函数传参</span></span><br><span class="line">afunc = f(a,b)</span><br><span class="line">z = f(*loc)</span><br><span class="line"><span class="comment"># *处理不确定个数的元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a,*b,c,d = <span class="built_in">range</span>(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="number">1</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<ol>
<li>具名元组，可以用来构建：
<ol>
<li>带字段的元组。表头？是否可以取代表格数据管理还有待探索hh</li>
<li>有名字的类</li>
</ol>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line">City = namedtuple(<span class="string">&#x27;City&#x27;</span>, <span class="string">&#x27;name country pop loc&#x27;</span>) <span class="comment">#创建类</span></span><br><span class="line">tolyo = City(<span class="string">&#x27;Tokyo&#x27;</span>,<span class="string">&#x27;JP&#x27;</span>,<span class="number">36.933</span>, (<span class="number">35.7</span>, <span class="number">139.7</span>)) <span class="comment"># 实例化</span></span><br></pre></td></tr></table></figure>
<h3 id="切片与赋值"><a class="markdownIt-Anchor" href="#切片与赋值"></a> 切片与赋值</h3>
<blockquote>
<p>即选取序列中的一段/一部分</p>
<p>索引从0开始，左闭右开 (a,b]，空表示断点</p>
</blockquote>
<ul>
<li>s[1:5]，选取序列s的第二个到第五个元素</li>
<li><code>s[a: b:c]</code>，a~b之间以间隔c取值, c值为负数代表倒序取值</li>
</ul>
<p>切片赋值时，若左侧为一个切片，右侧应该是可迭代的，即便只有一个值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">alistp[<span class="number">1</span>:<span class="number">5</span>]=[<span class="number">48</span>]</span><br></pre></td></tr></table></figure>
<h3 id="序列的拼接"><a class="markdownIt-Anchor" href="#序列的拼接"></a> 序列的拼接</h3>
<p>+和*都是创建一个新的序列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">c = a+b <span class="comment"># &gt;&gt;&gt;[1,2,3,3,4,5]</span></span><br><span class="line">d = a*<span class="number">3</span> <span class="comment"># &gt;&gt;&gt;[1, 2, 3, 1, 2, 3, 1, 2, 3]</span></span><br><span class="line">e = <span class="number">5</span>*<span class="string">&#x27;abc&#x27;</span><span class="comment"># &gt;&gt;&gt;&#x27;abcabcabcabcabc&#x27;</span></span><br></pre></td></tr></table></figure>
<p>+=和*=可用于对可变序列，如列表和字典，其原理是这些类的内部实现了<code>__iadd__或__imul__</code></p>
<ul>
<li>对于可变序列使用时，就地改变数据，数据的内存及ID位置不会变</li>
</ul>
<h3 id="序列排序"><a class="markdownIt-Anchor" href="#序列排序"></a> 序列排序</h3>
<p>list.sort()：就地排序,返回None</p>
<p>sorted()：对可迭代对象排序生成新对象，如列表、元组及生成器都可以</p>
<ul>
<li>
<p>可选参数：reverse(默认是False，升序输出); key 默认是元素本身的值排序，若设置key=str.lower或key=len可以使其忽略大小写或基于长度排序</p>
</li>
<li>
<p>此外，key关键字可以在很多内置函数中使用，如max() min()</p>
</li>
</ul>
<p>当我们需要进行查找和插入元素并<strong>保持序列的顺序不变</strong>时，可使用bisect模块，其使用二分法进行查找和插入，有需要时再检索即可</p>
<h3 id="处理数值序列-数组array"><a class="markdownIt-Anchor" href="#处理数值序列-数组array"></a> 处理数值序列-数组array</h3>
<blockquote>
<p>如果只处理<strong>纯数字</strong>，尤其是比如大量的浮点数，array比list要高效地多</p>
<p>因为数组背后是对数字的机器翻译——字节标段数</p>
</blockquote>
<p>使用数组<a href="https://docs.python.org/3/library/array.html">array</a></p>
<p>如以下示例生成一个含1000万的浮点数组并写入文件，再读取。会发现写入不到1s，读取约0.1s，文件大小&lt;80mb</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> array <span class="keyword">import</span> array</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> random</span><br><span class="line">floats = array(<span class="string">&#x27;d&#x27;</span>, (random() <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>**<span class="number">7</span>))) <span class="comment">#d代表底层C语言数据类型，浮点, 更多类型可查看文档</span></span><br><span class="line"><span class="comment"># 写入</span></span><br><span class="line">fp = <span class="built_in">open</span>(<span class="string">&#x27;test_floats.bin&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">floats.tofile(fp)</span><br><span class="line">fp.close()</span><br><span class="line"><span class="comment"># 读取</span></span><br><span class="line">floats2 = array(<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;test_floats.bin&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    floats2.fromfile(fp, <span class="number">10</span>**<span class="number">7</span>)</span><br><span class="line">floats2==floats</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>此外，<strong>pickle</strong>也是一个快速序列化数字类型的内置模块，同时pickle还可以序列化各种类型的数据</p>
</li>
<li>
<p>array的排序可以通过, a = array.array(a.typecode, sorted(a))</p>
</li>
</ul>
<p>标准库之外：值得学习的Numpy和Scipy库，强大的科学计算工具</p>
<p>Python内部实现了双向队列的类型collections.deque：线程安全、可以快速从两段添加或删除元素的数据类型</p>
<h2 id="数据结构字典与集合"><a class="markdownIt-Anchor" href="#数据结构字典与集合"></a> 数据结构——字典与集合</h2>
<h3 id="字典功能结构"><a class="markdownIt-Anchor" href="#字典功能结构"></a> 字典功能结构</h3>
<h3 id="字典的构造和推导式"><a class="markdownIt-Anchor" href="#字典的构造和推导式"></a> 字典的构造和推导式</h3>
<h3 id="字典常用方法"><a class="markdownIt-Anchor" href="#字典常用方法"></a> 字典常用方法</h3>
<h3 id="键找不到时的处理"><a class="markdownIt-Anchor" href="#键找不到时的处理"></a> 键找不到时的处理</h3>
<p>常规查找：</p>
<p>my_dict.get(key, defalut)</p>
<p>更新处理</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_dict.setdefault(key, []).append(newvalue)</span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line"><span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> my_dict:</span><br><span class="line">    my_dict[key] = []</span><br><span class="line">my_dict[key].append(newvalue) </span><br></pre></td></tr></table></figure>
<h3 id="自定义字典"><a class="markdownIt-Anchor" href="#自定义字典"></a> 自定义字典</h3>
<h2 id="little-tips"><a class="markdownIt-Anchor" href="#little-tips"></a> little tips</h2>
<ol>
<li>“_”占位符可以用来过滤一些不需要的输出结果</li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>书籍文档学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>技术类书籍</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析Python中的类、模块、包</title>
    <url>/posts/659ef075/</url>
    <content><![CDATA[<p>类和继承是面向对象编程<a href="https://en.wikipedia.org/wiki/Object-oriented_programming">(OOP)</a>中的重要概念，Python中的大量模块等也都是基于类实现的；模块和包是Python可拓展性和便捷性的支撑，也是我们接触最多的内容。了解Python中的类、模块和包一方面有助于强化写代码时候的<strong>逻辑</strong>（更清楚地知道自己写的代码-每一步是在干嘛）、提高效率，同时便于我们更好地<strong>读懂</strong>并复制粘贴别人的代码。本文主要内容：</p>
<ol>
<li>Python中的<strong>模块(module)<strong>和</strong>包(package)</strong></li>
<li>Python中如何定义<strong>类(class)</strong></li>
<li>什么时候需要类？</li>
</ol>
<span id="more"></span>
<h2 id="模块和包"><a class="markdownIt-Anchor" href="#模块和包"></a> 模块和包</h2>
<blockquote>
<p><a href="https://docs.python.org/3/tutorial/modules.html">官方文档的介绍——Modules in python</a></p>
</blockquote>
<p><strong>模块</strong>：一个<code>.py文件</code>就构成了一个模块，模块名即为去掉后缀之后的名。</p>
<p><strong>包</strong>：一个包含<code>__init__.py</code>文件+若干子包+若干模块的<strong>文件夹</strong>，文件夹的名字即为<strong>包名</strong>，第一个文件是必须（该文件的作用即是为了防止系统将含.py文件的文件夹均识别为包）,因此有些时候github上下载别人写好的小工具包可以直接放在文件夹下import使用而不需要install。</p>
<ul>
<li>模块包含内置模块、标准模块以及第三方模块；包也包括内置的包、第三方包</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在交互窗口中运行，内置的模块路径在c拓展内</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> time,os,datetime,pandas</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>time</span><br><span class="line">&lt;module <span class="string">&#x27;time&#x27;</span> (built-<span class="keyword">in</span>)&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os</span><br><span class="line">&lt;module <span class="string">&#x27;os&#x27;</span> <span class="keyword">from</span> <span class="string">&#x27;D:\\Miniconda3\\lib\\os.py&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>datetime</span><br><span class="line">&lt;module <span class="string">&#x27;datetime&#x27;</span> <span class="keyword">from</span> <span class="string">&#x27;D:\\Miniconda3\\lib\\datetime.py&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pandas</span><br><span class="line">&lt;module <span class="string">&#x27;pandas&#x27;</span> <span class="keyword">from</span> <span class="string">&#x27;D:\\Miniconda3\\lib\\site-packages\\pandas\\__init__.py&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>从<a href="https://www.python.org/downloads/source/">官网</a>下载初始Python的源码做一个简单的了解：</li>
</ul>
<img src="/posts/659ef075/image-20220518132724603.png" class alt="libs">
<p>下载完成后进入文件夹：<u>A:\Python-3.10.4\Lib</u>，可以看到其中只有两种文件</p>
<ol>
<li><strong>文件夹即包</strong>，熟悉的如：json、logging、multiprocessing、urllib</li>
<li><strong>py文件，即脚本/模块</strong>，熟悉的如：<a href="http://os.py">os.py</a>、<a href="http://re.py">re.py</a>、<a href="http://zipfile.py">zipfile.py</a></li>
<li>一个<strong>特殊的空文件夹，site-packages</strong>，打开其中有一个文本描述，写的是：本目录用于存放第三方的包（通过pypi/conda安装的包即存放在这）</li>
</ol>
<p>所以，即便我们不安装额外的包，也可以使用内置的模块及标准库中的模块与包：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time, os, re</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> pool</span><br></pre></td></tr></table></figure>
<p>Python的巨大优势就在于可拓展性和便捷，有大量的第三方包可供使用。另外，除了安装第三方包、我们也可以自己写模块和包用于调用。</p>
<p><u>tip：自己写的py文件放在目录下可以直接import，然后使用其中的<strong>变量及函数</strong>。通常该文件写完需要调试，这时候可以将运行的代码放在</u><code>if '__main__'== __main__:</code> <u>之下，这样在其他脚本import调用该”模块时”也不会执行运行的代码。</u></p>
<h2 id="定义类"><a class="markdownIt-Anchor" href="#定义类"></a> 定义类</h2>
<p>构造函数：</p>
<h2 id="何时需要类"><a class="markdownIt-Anchor" href="#何时需要类"></a> 何时需要类？</h2>
<blockquote>
<p>参考：<a href="https://stackoverflow.com/questions/33072570/when-should-i-be-using-classes-in-python">使用类的原因-讨论</a></p>
</blockquote>
<blockquote>
<p>通常，使用Python的内置及第三方模块可以完成我们的工作，并不需要自定义类，但随着工作量的增大和复杂化，或许会有这样的需求，以pandas为例</p>
</blockquote>
<p>结合实际讨论，</p>
<ol>
<li>属性/结果的保存和即时访问：当我们通过<code>pandas.read_csv()</code>读取一个文件之后，得到一个实例化的对象<code>dataframe</code>，接下来我们可以通过columns,names,head,shape等参数访问其<strong>属性</strong>，即对象实例化之后我们可以使用和追踪它的状态，就好像创建了一个list，而不只是调用了一个方法。</li>
<li>便于拓展和重用，可以继承，即方便别人用和自己调用，比如他人可以基于pandas开发geopandas等包，也即是依赖</li>
<li>结构清晰，好看，从各种包的api文档（如<a href="https://pandas.pydata.org/pandas-docs/stable/reference/frame.html">pandas</a>，<a href="https://matplotlib.org/stable/gallery/index.html">matplotlib</a>，<a href="https://numpy.org/doc/stable/reference/index.html">numpy</a>，<a href="https://geopandas.org/en/latest/docs/reference.html">geopandas</a>……）我们可以看看，其组织结构清楚，便于查阅……</li>
<li>……</li>
</ol>
<p><strong>何时使用？</strong></p>
<p>（虽然一直在享受着类的便捷，但个人还没遇到一定得用类的情况hh）</p>
<ul>
<li>当工作简单或者只是实现一个或者多个函数时，不需要。类的重要一点就是属性和方法组装在了一起，如果只是一个一次性的处理脚本不需要类</li>
<li>编写开源包和模块时</li>
<li>工作量比较大，代码组织感觉比较乱时，可以考虑（理理逻辑，通过多个函数/脚本也可以写出结构清晰的脚本）。</li>
</ul>
]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>类</tag>
        <tag>模块</tag>
      </tags>
  </entry>
  <entry>
    <title>矢栅处理(6)：点矢量提取栅格值extract</title>
    <url>/posts/2f2d96ec/</url>
    <content><![CDATA[<p>基于Python完成，(<strong>批量</strong>)用点矢量来提取栅格数据中的值。数据少也可使用Arcgis中的<a href="https://desktop.arcgis.com/en/arcmap/latest/tools/spatial-analyst-toolbox/extract-values-to-points.htm">Extract Values to Points</a>及<a href="https://desktop.arcgis.com/en/arcmap/latest/tools/spatial-analyst-toolbox/extract-multi-values-to-points.htm">multi</a>。</p>
<span id="more"></span>
<h2 id="思路及实现"><a class="markdownIt-Anchor" href="#思路及实现"></a> 思路及实现</h2>
<blockquote>
<p>本文<a href="https://mp.weixin.qq.com/s/aS9prn2fFoLFl2tgkfysDQ">转载</a>自公众号【GIS与Climate】，该号主是我一个所的师兄，他的公众号会频繁推送他研究中GIS相关的一些处理和分析，包括深度学习，推荐关注~</p>
</blockquote>
<h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3>
<p>单个栅格数据读入内存为一个<strong>二维</strong>numpy array，提取点矢量对应的栅格值实际上是读取某<strong>经纬度对应的栅格点的值（如果是投影系则是平面坐标）</strong>。</p>
<p>数组array只能<strong>通过行列号索引</strong>，所以实现方法：</p>
<ul>
<li><font color="#dd0000">经纬度/平面坐标 -&gt; 栅格矩阵行列号-&gt;对应栅格值</font></li>
<li>即将地理经纬度坐标变换到矩阵对应的行列号，本质上这是两个坐标空间的变换，也就是仿射变换。</li>
</ul>
<h3 id="案例"><a class="markdownIt-Anchor" href="#案例"></a> 案例</h3>
<blockquote>
<p>需预先确定数据的坐标系是否统一，需在统一参考系下才能正确运算</p>
</blockquote>
<p>rasterio包中的<a href="https://rasterio.readthedocs.io/en/latest/quickstart.html?highlight=index#spatial-indexing">spatial index</a>方法提供了该功能的实现，自定义函数并通过apply实现，单个图层</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">ExtractPointValue</span>(<span class="params">geometry,rs</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    geometry: geodataframe的geometry列</span></span><br><span class="line"><span class="string">    rs: 栅格数据</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># geometry.xy获取点几何的经纬度</span></span><br><span class="line">    x = geometry.xy[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    y = geometry.xy[<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">    row, col = rs.index(x,y)</span><br><span class="line">    value = rs.read(<span class="number">1</span>)[row,col]</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line"><span class="comment"># 数据读取及运算</span></span><br><span class="line">rs = rasterio.<span class="built_in">open</span>(<span class="string">&#x27;../input/rs.tif&#x27;</span>)</span><br><span class="line">gpd_points = gdp.read_file(<span class="string">&#x27;../input/shp/test_points.shp&#x27;</span>)</span><br><span class="line">gpd_points[<span class="string">&#x27;value1&#x27;</span>] = gpd_points[<span class="string">&#x27;geometry&#x27;</span>].apply(ExtractPointValue,rs=rs)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>时空数据处理分析</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Geopandas</tag>
        <tag>Rasterio</tag>
        <tag>Extract</tag>
      </tags>
  </entry>
  <entry>
    <title>矢栅处理(4)：NC文件读写</title>
    <url>/posts/448bb583/</url>
    <content><![CDATA[<p><a href="https://en.wikipedia.org/wiki/NetCDF">NC文件</a>由于便捷存储多维数据（如大范围长时间序列），因而广泛用于气候，气象数据存储及交换。python文档<a href="https://unidata.github.io/netcdf4-python/">netCDF4</a></p>
<span id="more"></span>
<p>安装：conda install -c conda-forge netcdf4</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> netCDF4 <span class="keyword">as</span> nc</span><br><span class="line"><span class="keyword">from</span> netCDF4 <span class="keyword">import</span> Dataset</span><br></pre></td></tr></table></figure>
<h2 id="netcdf"><a class="markdownIt-Anchor" href="#netcdf"></a> NetCDF</h2>
<blockquote>
<p>NetCDF (Network Common Data Form)，网络通用数据格式</p>
</blockquote>
<p>NC文件包括以下几个属性</p>
<ul>
<li>简单来说，netcdf是一个包含多自变量及其函数的文件。用公式来说就是f(x,y,z,…)=value，同时存储了xyz</li>
<li>函数的自变量x,y,z等在netcdf中叫做维(dimension) 或坐标轴(axix),<code>ds.dimensions</code>可以看到维度的信息</li>
<li>函数值与自变量均存储在(Variables)，<code>ds.variables</code>属性则存储了数据的详细信息及数组文件。</li>
</ul>
<p>具体案例见下方示例：</p>
<h2 id="python读nc文件"><a class="markdownIt-Anchor" href="#python读nc文件"></a> Python读nc文件</h2>
<p>netCDF文件有五种（NETCDF3_CLASSIC, NETCDF3_64BIT_OFFSET, NETCDF3_64BIT_DATA, NETCDF4_CLASSIC和NETCDF4）读取之后<code>ds.data_model</code>输出可以看到其实际存储格式。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ncfile = <span class="string">&#x27;E:\\Datasets\\temp\\China_1km_maxtmp_2017.nc&#x27;</span></span><br><span class="line">ds = Dataset(ncfile, <span class="string">&quot;r&quot;</span>, <span class="built_in">format</span>=<span class="string">&quot;NETCDF4&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(ds.data_model)</span><br><span class="line"><span class="comment"># ds.close()</span></span><br></pre></td></tr></table></figure>
<p>常见属性举例：时间这里是从1800年开始按天算的，实际中都要自行判断并转换，这里的温度的单位是K</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ds.dimensions</span><br><span class="line">&#123;<span class="string">&#x27;lon&#x27;</span>: &lt;<span class="keyword">class</span> <span class="string">&#x27;netCDF4._netCDF4.Dimension&#x27;</span>&gt;: name = <span class="string">&#x27;lon&#x27;</span>, size = <span class="number">7386</span>,</span><br><span class="line"> <span class="string">&#x27;lat&#x27;</span>: &lt;<span class="keyword">class</span> <span class="string">&#x27;netCDF4._netCDF4.Dimension&#x27;</span>&gt;: name = <span class="string">&#x27;lat&#x27;</span>, size = <span class="number">4267</span>,</span><br><span class="line"> <span class="string">&#x27;time&#x27;</span>: &lt;<span class="keyword">class</span> <span class="string">&#x27;netCDF4._netCDF4.Dimension&#x27;</span>&gt; (unlimited): name = <span class="string">&#x27;time&#x27;</span>, size = <span class="number">365</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ds_dict = ds.variables</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dt_dict.keys()</span><br><span class="line">dict_keys([<span class="string">&#x27;time&#x27;</span>, <span class="string">&#x27;lon&#x27;</span>, <span class="string">&#x27;lat&#x27;</span>, <span class="string">&#x27;maxtmp&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看数据信息</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dt_dict[<span class="string">&#x27;time&#x27;</span>]</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;netCDF4._netCDF4.Variable&#x27;</span>&gt;</span><br><span class="line">float32 time(time)</span><br><span class="line">    units: days since <span class="number">1800</span>-01-01 <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line">    standard_name: time</span><br><span class="line">    calendar: proleptic_gregorian</span><br><span class="line">    long_name: Time</span><br><span class="line">    axis: T</span><br><span class="line">unlimited dimensions: time</span><br><span class="line">current shape = (<span class="number">365</span>,)</span><br><span class="line">filling on, default _FillValue of <span class="number">9.969209968386869e+36</span> used</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dt_dict[<span class="string">&#x27;lon&#x27;</span>]</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;netCDF4._netCDF4.Variable&#x27;</span>&gt;</span><br><span class="line">float32 lon(lon)</span><br><span class="line">    standard_name: longitude</span><br><span class="line">    long_name: Longitude</span><br><span class="line">    units: degrees_east</span><br><span class="line">    axis: X</span><br><span class="line">unlimited dimensions: </span><br><span class="line">current shape = (<span class="number">7386</span>,)</span><br><span class="line">filling on, default _FillValue of <span class="number">9.969209968386869e+36</span> used</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dt_dict[<span class="string">&#x27;maxtmp&#x27;</span>]</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;netCDF4._netCDF4.Variable&#x27;</span>&gt;</span><br><span class="line">float32 maxtmp(time, lat, lon)</span><br><span class="line">    _FillValue: nan</span><br><span class="line">    scale_factor: <span class="number">0.01</span></span><br><span class="line">    add_offset: <span class="number">273.15</span></span><br><span class="line">    units: K</span><br><span class="line">    long_name: Daily Maximum Near-Surface Air Temperature</span><br><span class="line">    standard_name: air_temperature</span><br><span class="line">    missing_value: nan</span><br><span class="line">unlimited dimensions: time</span><br><span class="line">current shape = (<span class="number">365</span>, <span class="number">4267</span>, <span class="number">7386</span>)</span><br><span class="line">filling on</span><br></pre></td></tr></table></figure>
<p>数据矩阵访问，通常是掩码数组，这里是False，相当于无掩码，普通数组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dt_dict[<span class="string">&#x27;lon&#x27;</span>][:]</span><br><span class="line">masked_array(data=[ <span class="number">73.44696</span>,  <span class="number">73.45529</span>,  <span class="number">73.46363</span>, ..., <span class="number">134.97195</span>,</span><br><span class="line">                   <span class="number">134.9803</span> , <span class="number">134.98863</span>],</span><br><span class="line">             mask=<span class="literal">False</span>,</span><br><span class="line">       fill_value=<span class="number">1e+20</span>,</span><br><span class="line">            dtype=float32)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>array_lon = dt_dict[<span class="string">&#x27;lon&#x27;</span>][:].data</span><br><span class="line">array([ <span class="number">73.44696</span>,  <span class="number">73.45529</span>,  <span class="number">73.46363</span>, ..., <span class="number">134.97195</span>, <span class="number">134.9803</span> ,</span><br><span class="line">       <span class="number">134.98863</span>], dtype=float32)</span><br></pre></td></tr></table></figure>
<p>其他类似，后面的操作都是<strong>numy多维数组</strong>的操作了</p>
<ul>
<li>
<p>访问某天的全区域的数据<code>[1,:,:]</code>，也可以输入特定经纬度索引范围</p>
</li>
<li>
<p>访问某点的时间序列数据<code>[:,index_lon,index_lat]</code></p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dt_maxtmp = dt_dict[<span class="string">&#x27;maxtmp&#x27;</span>][<span class="number">1</span>,:,:]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dt_maxtmp</span><br><span class="line">masked_array(</span><br><span class="line">  data=[[--, --, --, ..., --, --, --],</span><br><span class="line">        [--, --, --, ..., --, --, --],</span><br><span class="line">        [--, --, --, ..., --, --, --],</span><br><span class="line">        ...,</span><br><span class="line">        [--, --, --, ..., --, --, --],</span><br><span class="line">        [--, --, --, ..., --, --, --],</span><br><span class="line">        [--, --, --, ..., --, --, --]],</span><br><span class="line">  mask=[[ <span class="literal">True</span>,  <span class="literal">True</span>,  <span class="literal">True</span>, ...,  <span class="literal">True</span>,  <span class="literal">True</span>,  <span class="literal">True</span>],</span><br><span class="line">        [ <span class="literal">True</span>,  <span class="literal">True</span>,  <span class="literal">True</span>, ...,  <span class="literal">True</span>,  <span class="literal">True</span>,  <span class="literal">True</span>],</span><br><span class="line">        [ <span class="literal">True</span>,  <span class="literal">True</span>,  <span class="literal">True</span>, ...,  <span class="literal">True</span>,  <span class="literal">True</span>,  <span class="literal">True</span>],</span><br><span class="line">        ...,</span><br><span class="line">        [ <span class="literal">True</span>,  <span class="literal">True</span>,  <span class="literal">True</span>, ...,  <span class="literal">True</span>,  <span class="literal">True</span>,  <span class="literal">True</span>],</span><br><span class="line">        [ <span class="literal">True</span>,  <span class="literal">True</span>,  <span class="literal">True</span>, ...,  <span class="literal">True</span>,  <span class="literal">True</span>,  <span class="literal">True</span>],</span><br><span class="line">        [ <span class="literal">True</span>,  <span class="literal">True</span>,  <span class="literal">True</span>, ...,  <span class="literal">True</span>,  <span class="literal">True</span>,  <span class="literal">True</span>]],</span><br><span class="line">  fill_value=nan,</span><br><span class="line">  dtype=float32)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dt_maxtmp.data</span><br><span class="line">array([[nan, nan, nan, ..., nan, nan, nan],</span><br><span class="line">       [nan, nan, nan, ..., nan, nan, nan],</span><br><span class="line">       [nan, nan, nan, ..., nan, nan, nan],</span><br><span class="line">       ...,</span><br><span class="line">       [nan, nan, nan, ..., nan, nan, nan],</span><br><span class="line">       [nan, nan, nan, ..., nan, nan, nan],</span><br><span class="line">       [nan, nan, nan, ..., nan, nan, nan]], dtype=float32)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>时空数据处理分析</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>R语言</tag>
        <tag>netCDF4</tag>
        <tag>NC文件</tag>
      </tags>
  </entry>
  <entry>
    <title>矢栅处理(杂)：OSM数据下载及shapefile读写</title>
    <url>/posts/42111e30/</url>
    <content><![CDATA[<p><a href="https://en.wikipedia.org/wiki/OpenStreetMap">OSM</a>地图数据是志愿地理信息数据<a href="https://en.wikipedia.org/wiki/Volunteered_geographic_information">(VGI)</a>的代表，更新快(<strong>天</strong>)覆盖区域广，在大区域研究中其数据尤其是路网应用广泛。这里简单介绍一下数据下载渠道及osm格式转换即<strong>shapefile的通用读写代码</strong>。</p>
<span id="more"></span>
<p>涉及多个国家的研究可能没有其他可替代的全球数据产品，所以这个数据应用很广。官网下载并不方便，可用通过<a href="http://download.geofabrik.de/index.html">Geofabrik</a>下载对应区域和国家的shape文件，其中中国的shapefile文件是完全开放的：</p>
<ul>
<li>下载<a href="http://download.geofabrik.de/asia/china.html#">路径</a>，点击[raw directory index]可以下载历年的数据</li>
<li>但是可能会发现有的国家并没有提供，仅提供了.som.pbf数据或者bz2的数据</li>
<li>shapefile的文件数据是按照数据类型（poi、路网、土地利用等等提供，是转换好的），但.osm的数据则是原始格式，pbf直接在qgis打开可以看到5个文件（点、线、面存储）</li>
</ul>
<img src="/posts/42111e30/img1.png" class alt="image1">
<img src="/posts/42111e30/img2.png" class alt="image2">
<h2 id="数据读写"><a class="markdownIt-Anchor" href="#数据读写"></a> 数据读写</h2>
<blockquote>
<p>osm文件实质就是多个矢量图层组成的文件，读取之后按照shapefile图层读写方式处理即可。数据量少可以直接使用相关插件完成转换及导出。量大则可以考虑开源的命令行工具或代码完成处理</p>
</blockquote>
<p>已知的可用工具：QGIS可以直接打开导出shape，ArcMap<a href="https://github.com/Esri/arcgis-osm-editor">插件</a>?</p>
<p>由于是矢量图层，直接使用GDAL中的矢量处理模块<a href="https://pcjericks.github.io/py-gdalogr-cookbook/index.html">ogr</a>完成处理</p>
<p>为了便于理解，读与写分开展示，实际上可以直接读取并完成写出。几何类型WKBGeometryType对应的<a href="https://gis.stackexchange.com/questions/239289/gdal-ogr-python-getgeomtype-method-returns-integer-what-is-the-matching-geo">代码</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> osgeo <span class="keyword">import</span> ogr, osr</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>inDS = ogr.Open(<span class="string">&#x27;./moldova-latest.osm.pbf&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>inDS.GetLayerCount()</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>layer = inDS.GetLayer(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>layer.GetGeomType()</span><br><span class="line"><span class="number">2</span> </span><br><span class="line"><span class="comment"># 输出可以看到5种类型分别为1 2 5 6 7</span></span><br><span class="line"><span class="comment"># ogr.wkbPoint = 1</span></span><br><span class="line"><span class="comment"># ogr.wkbLineString = 2</span></span><br><span class="line"><span class="comment"># ogr.wkbMultiLineString = 5</span></span><br><span class="line"><span class="comment"># ogr.wkbMultiPolygon = 6</span></span><br><span class="line"><span class="comment"># ogr.wkbGeometryCollection = 7</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lydefn = layer.GetLayerDefn() </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lydefn.GetFieldCount()</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="comment"># 9列</span></span><br></pre></td></tr></table></figure>
<p>读shape的字段，以线图层为例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#获取图层 定义及字段</span></span><br><span class="line">lydefn = layer.GetLayerDefn() </span><br><span class="line">fieldlist = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(lydefn.GetFieldCount()):</span><br><span class="line">    fddefn = lydefn.GetFieldDefn(i)</span><br><span class="line">    fddict = &#123;</span><br><span class="line">        <span class="string">&#x27;name&#x27;</span>:fddefn.GetName(),</span><br><span class="line">        <span class="string">&#x27;type&#x27;</span>:fddefn.GetType(),</span><br><span class="line">        <span class="string">&#x27;width&#x27;</span>:fddefn.GetWidth(),</span><br><span class="line">        <span class="string">&#x27;decimal&#x27;</span>:fddefn.GetPrecision()&#125;</span><br><span class="line">    fieldlist.append(fddict)</span><br><span class="line">fieldlist</span><br><span class="line"><span class="comment"># [&#x27;osm_id&#x27;, &#x27;name&#x27;, &#x27;highway&#x27;, &#x27;waterway&#x27;, &#x27;aerialway&#x27;, &#x27;barrier&#x27;, &#x27;man_made&#x27;, &#x27;z_order&#x27;, &#x27;other_tags&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>读shape的要素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 读取要素</span></span><br><span class="line">geomlist = []</span><br><span class="line">featurelist = []</span><br><span class="line">feature = layer.GetNextFeature() <span class="comment">#获得第一个要素</span></span><br><span class="line"><span class="keyword">while</span> feature <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">    geom = feature.GetGeometryRef()</span><br><span class="line">    geomlist.append(geom.ExportToWkt())</span><br><span class="line">    feature = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> fd <span class="keyword">in</span> fieldlist:</span><br><span class="line">        feature[fd[<span class="string">&#x27;name&#x27;</span>]] = feature.GetField(fd[<span class="string">&#x27;name&#x27;</span>])</span><br><span class="line">    featurelist.append(feature)</span><br><span class="line">    feature = layer.GetNextFeature()</span><br><span class="line">ds=<span class="literal">None</span> <span class="comment"># 释放数据源</span></span><br><span class="line"><span class="comment"># 预览数据</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(featurelist)</span><br><span class="line"><span class="number">39008</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>featurelist[<span class="number">0</span>]</span><br><span class="line">&#123;<span class="string">&#x27;osm_id&#x27;</span>: <span class="string">&#x27;4529536&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;name&#x27;</span>: <span class="literal">None</span>,</span><br><span class="line"> <span class="string">&#x27;highway&#x27;</span>: <span class="literal">None</span>,</span><br><span class="line"> <span class="string">&#x27;waterway&#x27;</span>: <span class="literal">None</span>,</span><br><span class="line"> <span class="string">&#x27;aerialway&#x27;</span>: <span class="literal">None</span>,</span><br><span class="line"> <span class="string">&#x27;barrier&#x27;</span>: <span class="literal">None</span>,</span><br><span class="line"> <span class="string">&#x27;man_made&#x27;</span>: <span class="literal">None</span>,</span><br><span class="line"> <span class="string">&#x27;z_order&#x27;</span>: <span class="number">0</span>,</span><br><span class="line"> <span class="string">&#x27;other_tags&#x27;</span>: <span class="literal">None</span>&#125;</span><br></pre></td></tr></table></figure>
<p>写shape,根据数据类型，就可以找到想要提取的文件并写出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建输出文件</span></span><br><span class="line">outShapefile = <span class="string">&quot;./data_line2.shp&quot;</span></span><br><span class="line">outDriver = ogr.GetDriverByName(<span class="string">&quot;ESRI Shapefile&quot;</span>)</span><br><span class="line">outDS = outDriver.CreateDataSource(outShapefile)</span><br><span class="line">srs = osr.SpatialReference()</span><br><span class="line">srs.ImportFromEPSG(<span class="number">4326</span>)</span><br><span class="line">out_layer = outDS.CreateLayer(outShapefile, srs, geom_type=ogr.wkbLineString, options = [<span class="string">&#x27;ENCODING=UTF-8&#x27;</span>])</span><br><span class="line"><span class="comment"># 写入字段</span></span><br><span class="line"><span class="keyword">for</span> fd <span class="keyword">in</span> fieldlist:</span><br><span class="line">    field = ogr.FieldDefn(fd[<span class="string">&#x27;name&#x27;</span>],fd[<span class="string">&#x27;type&#x27;</span>])</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;width&#x27;</span> <span class="keyword">in</span> fd:</span><br><span class="line">        field.SetWidth(fd[<span class="string">&#x27;width&#x27;</span>])</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;decimal&#x27;</span> <span class="keyword">in</span> fd:</span><br><span class="line">        field.SetPrecision(fd[<span class="string">&#x27;decimal&#x27;</span>])</span><br><span class="line">    out_layer.CreateField(field)</span><br><span class="line"><span class="comment"># 写入要素</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(featurelist)): </span><br><span class="line">    geom = ogr.CreateGeometryFromWkt(geomlist[i])</span><br><span class="line">    <span class="comment"># 创建空行</span></span><br><span class="line">    newfeature = ogr.Feature(out_layer.GetLayerDefn())</span><br><span class="line">    newfeature.SetGeometry(geom)</span><br><span class="line">    <span class="comment"># 写入字段及值</span></span><br><span class="line">    <span class="keyword">for</span> fd <span class="keyword">in</span> fieldlist: </span><br><span class="line">        fieldname = fd[<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">        infeature = featurelist[i]</span><br><span class="line">        newfeature.SetField(fieldname, infeature[fieldname]) </span><br><span class="line">    out_layer.CreateFeature(newfeature)</span><br><span class="line"><span class="comment"># 释放数据源并完成写出</span></span><br><span class="line">inDS=<span class="literal">None</span> </span><br><span class="line">outDS = <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<p>以上代码可以自行简化合并为一个部分，且可以根据需求进一步对shape进行分类导出操作。由于暂无需求暂不展开。</p>
]]></content>
      <categories>
        <category>时空数据处理分析</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>OpenStreetMap</tag>
        <tag>GDAL</tag>
        <tag>shapefile读写</tag>
      </tags>
  </entry>
  <entry>
    <title>矢栅处理(3)：Python读写GeoTIFF</title>
    <url>/posts/f61ccf5/</url>
    <content><![CDATA[<p><a href="https://hscyber.github.io/posts/a9be2430/">先看一下</a>tif文件的数值类型和压缩方式。地理栅格数据通常会以<u>GeoTIFF(.tif; .tiff)、HDF(.h5; .hdf5)、NETCDF(.nc)</u>等多种文件格式(后两者气象数据居多，长时间序列数据存储)，但实际中空间处理、统计及可视化最常用的还是geotiff数据，因此先小结并对比一下：<strong>(1) gdal模块和rasterio两个模块读写tif的对比；(2)geotif文件的压缩格式</strong></p>
<span id="more"></span>
<ul>
<li>关于h5文件和nc文件的读写后续总结</li>
</ul>
<h2 id="geotiff文件"><a class="markdownIt-Anchor" href="#geotiff文件"></a> GeoTIFF文件</h2>
<h3 id="文件简介"><a class="markdownIt-Anchor" href="#文件简介"></a> 文件简介</h3>
<blockquote>
<p><strong>GEO+TIF</strong>，如果 TIFF 文件本身没有地理配准信息，GDAL 将依次检查并使用扩展名为.aux.xml文件 . MapInfo .tab 文件以及tfw、.tifw/.tiffw 或 .wld 的 ESRI世界文件。</p>
</blockquote>
<p>tiff和png等本身即是光栅文件，geotiff文件是在tiff文件中嵌入地理参考信息/tags得到的，包含两部分</p>
<ul>
<li>像元值，纯数值矩阵numpy ndarray
<ul>
<li>矩阵的维度——行列数+波段数</li>
<li>矩阵的数值及<a href="https://www.runoob.com/numpy/numpy-dtype.html">numpy数据类型dtype</a>, 表示为，np.uint8; np.bool_; np.complex64
<ul>
<li>int8, int16, int32, int64;  uint16,  uint16, uint32, uint64;(无符号即大于等于0)</li>
<li>float16, float32, float64</li>
</ul>
</li>
</ul>
</li>
<li>地理参考/空间位置信息
<ul>
<li>空间范围Extent，矩形框四个角的范围</li>
<li>坐标系：地理坐标系及投影坐标系，如果深究坐标参考系的信息较为丰富</li>
<li>分辨率，或行列数、空值 Nodata value、图层个数等</li>
</ul>
</li>
<li>tiff等光栅文件均可视为点文件，以该点为中心的格网空间范围内的值皆=该点的值</li>
<li><strong><font color="#dd0000">数据读取和处理等中间过程可通过numpy数组完成，涉及空间运算时把位置信息加入生成进行处理即可</font></strong></li>
</ul>
<h2 id="文件读写"><a class="markdownIt-Anchor" href="#文件读写"></a> 文件读写</h2>
<blockquote>
<p>简要版，更多的参数设置查看文档：<a href="https://rasterio.readthedocs.io/en/latest/quickstart.html">rasterio</a>; <a href="https://gdal.org/python/osgeo.gdal-module.html">gdal1</a>, <a href="https://gdal.org/index.html">gdal2</a>. 仅以单波段图像为例进行读写分析，多波段可以自行拓展</p>
</blockquote>
<p><strong><font color="#dd0000">读写后的tif信息往往不完全一致，可以通过读取两幅影像比较数值矩阵是否相等,下述三种方法写出文件的结果数值一致</font></strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(data1 == data2).<span class="built_in">all</span>() <span class="comment">#True则表示相同</span></span><br></pre></td></tr></table></figure>
<h3 id="rasterio推荐"><a class="markdownIt-Anchor" href="#rasterio推荐"></a> rasterio(推荐)</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> rasterio</span><br><span class="line"><span class="comment"># 读</span></span><br><span class="line"><span class="keyword">with</span> rasterio.<span class="built_in">open</span>(file) <span class="keyword">as</span> src_dataset:</span><br><span class="line">    profiles = src_dataset.profile</span><br><span class="line">    band1 = src_dataset.read(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(profiles)</span><br><span class="line"><span class="built_in">print</span>(band1) <span class="comment">#ndarray</span></span><br><span class="line"><span class="comment"># 在此更新字典信息</span></span><br><span class="line">new_type = rasterio.int32</span><br><span class="line">profiles.update(dtype=new_type,compress=<span class="string">&#x27;DEFLATE&#x27;</span>)</span><br><span class="line"><span class="comment"># 写: band1为一个numpy array</span></span><br><span class="line"><span class="keyword">with</span> rasterio.<span class="built_in">open</span>(out, <span class="string">&#x27;w&#x27;</span>, **profiles) <span class="keyword">as</span> dst:</span><br><span class="line">        dst.write(band1.astype(new_type), <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h3 id="gdal"><a class="markdownIt-Anchor" href="#gdal"></a> gdal</h3>
<blockquote>
<p>更为底层，前者实际上是基于gdal完成的读写</p>
<p>gdal写出的文件会比rasterio更大，暂时还不知道原因</p>
</blockquote>
<p>读，获取各项信息，可以通过dir(ds)查看其全部属性方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ds = gdal.Open(tiffile)</span><br><span class="line">band = ds.GetRasterBand(<span class="number">1</span>)</span><br><span class="line">im_data = band.ReadAsArray()</span><br><span class="line"><span class="built_in">print</span>(im_data.dtype)</span><br><span class="line"><span class="comment"># 各项信息</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;文件的源信息&quot;</span>,ds.GetMetadata())</span><br><span class="line">im_width = ds.RasterXSize <span class="comment">#栅格矩阵的列数</span></span><br><span class="line">im_height = ds.RasterYSize <span class="comment">#栅格矩阵的行数</span></span><br><span class="line">im_bands = ds.RasterCount <span class="comment">#波段数</span></span><br><span class="line"></span><br><span class="line">im_geotrans = ds.GetGeoTransform() <span class="comment">#仿射矩阵，左上角像素的大地坐标和像素分辨率</span></span><br><span class="line">im_proj = ds.GetProjection() <span class="comment">#地图投影信息，字符串表示</span></span><br><span class="line">proj = osr.SpatialReference(wkt=im_proj)</span><br><span class="line">nodata = band.GetNoDataValue()</span><br></pre></td></tr></table></figure>
<p>写<code>GDALDataset *Create(const char *pszName,nXSize,nYSize,nBands,eType,...)</code></p>
<p>GDALDataType, 如gdal.GDT_Byte</p>
<table>
<thead>
<tr>
<th style="text-align:center">enum GDALDataType</th>
<th style="text-align:center">对应numpy类型</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">GDT_Byte</td>
<td style="text-align:center">np.uint8</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">GDT_UInt16, GDT_Int16</td>
<td style="text-align:center">np.uint16, np.int16</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">GDT_UInt32, GDT_Int32</td>
<td style="text-align:center">np.uint32, np.int32</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">GDT_UInt64, GDT_Int64</td>
<td style="text-align:center">np.uint64, np.int64</td>
<td style="text-align:center">GDAL &gt;= 3.5</td>
</tr>
<tr>
<td style="text-align:center">GDT_Float32， GDT_Float64</td>
<td style="text-align:center">np.float32, np.float64</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">GDT_CInt16，GDT_CInt32</td>
<td style="text-align:center">Complex Int16</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">GDT_CFloat32，GDT_CFloat64</td>
<td style="text-align:center">Complex Float32</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>写出方法1: Create</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">write_geotif</span>(<span class="params">outpath, im_data, im_geotrans,im_proj, nodata=-<span class="number">1</span></span>):</span><br><span class="line">    <span class="comment"># 仅适用于单个波段</span></span><br><span class="line">    <span class="comment"># 数据类型</span></span><br><span class="line">    GDT_Dict = &#123;</span><br><span class="line">        <span class="string">&#x27;uint8&#x27;</span>:gdal.GDT_Byte,</span><br><span class="line">        <span class="string">&#x27;int8&#x27;</span>:gdal.GDT_Byte,</span><br><span class="line">        <span class="string">&#x27;uint16&#x27;</span>:gdal.GDT_UInt16,</span><br><span class="line">        <span class="string">&#x27;int16&#x27;</span>:gdal.GDT_Int16,</span><br><span class="line">        <span class="string">&#x27;uint32&#x27;</span>:gdal.GDT_UInt32,</span><br><span class="line">        <span class="string">&#x27;int32&#x27;</span>:gdal.GDT_Int32,</span><br><span class="line">        <span class="string">&#x27;float32&#x27;</span>:gdal.GDT_Float32&#125;</span><br><span class="line">    gdaltype = GDT_Dict[im_data.dtype.name]</span><br><span class="line">    im_bands, (im_height, im_width) = <span class="number">1</span>, im_data.shape</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建文件</span></span><br><span class="line">    driver = gdal.GetDriverByName(<span class="string">&quot;GTiff&quot;</span>)</span><br><span class="line">    dataset = driver.Create(outpath, im_width, im_height, im_bands, gdaltype, options=[<span class="string">&quot;COMPRESS=LZW&quot;</span>])</span><br><span class="line">    dataset.SetGeoTransform(im_geotrans) <span class="comment">#写入仿射变换参数</span></span><br><span class="line">    dataset.SetProjection(im_proj) <span class="comment">#写入投影</span></span><br><span class="line">    <span class="comment"># 写入数据</span></span><br><span class="line">    dataset.GetRasterBand(<span class="number">1</span>).WriteArray(im_data)</span><br><span class="line">    dataset.GetRasterBand(<span class="number">1</span>).SetNoDataValue(nodata)</span><br><span class="line">    <span class="comment"># 写入内存</span></span><br><span class="line">    <span class="keyword">del</span> dataset</span><br><span class="line">outpath = <span class="string">r&quot;....tif&quot;</span></span><br><span class="line">write_geotif(outpath, im_data, im_geotrans,im_proj, nodata=nodata)</span><br></pre></td></tr></table></figure>
<p>写出方法2: CreateCopy</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write_geotif2</span>(<span class="params">outpath, im_data, src_ds</span>):</span><br><span class="line">    <span class="comment"># 创建文件</span></span><br><span class="line">    driver = gdal.GetDriverByName(<span class="string">&quot;GTiff&quot;</span>)</span><br><span class="line">    dst_ds = driver.CreateCopy(outpath, src_ds, strict=<span class="number">0</span>, options=[<span class="string">&quot;COMPRESS=LZW&quot;</span>])</span><br><span class="line">    <span class="comment"># 写入数据</span></span><br><span class="line">    dst_ds.GetRasterBand(<span class="number">1</span>).WriteArray(im_data)</span><br><span class="line">    <span class="comment"># 写入内存</span></span><br><span class="line">    <span class="keyword">del</span> dst_ds</span><br><span class="line">outpath = <span class="string">r&quot;...tif&quot;</span></span><br><span class="line">write_geotif2(outpath, im_data,ds)</span><br></pre></td></tr></table></figure>
<h3 id="matlab"><a class="markdownIt-Anchor" href="#matlab"></a> matlab</h3>
<p>由于文件本质上是纯数值文件，Matlab处理tiff文件也十分便捷<a href="https://ww2.mathworks.cn/help/map/ref/geotiffwrite.html">api</a>，但鉴于目前不太熟悉，后续填充</p>
<h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2>
<ol>
<li><a href="https://rasterio.readthedocs.io/en/latest/intro.html">https://rasterio.readthedocs.io/en/latest/intro.html</a></li>
<li><a href="https://gdal.org/tutorials/index.html">https://gdal.org/tutorials/index.html</a></li>
<li><a href="https://gdal.org/index.html">https://gdal.org/index.html</a></li>
<li><a href="https://gdal.org/drivers/raster/gtiff.html">https://gdal.org/drivers/raster/gtiff.html</a></li>
<li><a href="https://digital-geography.com/geotiff-compression-comparison/#:~:text=GDAL%20supports%20three%20lossless%20compression,methods%20with%20GDALs%20creation%20options.">其他参考</a></li>
</ol>
]]></content>
      <categories>
        <category>时空数据处理分析</category>
      </categories>
      <tags>
        <tag>GeoTIFF</tag>
        <tag>Rasterio</tag>
        <tag>GDAL</tag>
        <tag>栅格文件读写</tag>
      </tags>
  </entry>
  <entry>
    <title>矢栅处理(2)：GeoTIFF数值类型及压缩</title>
    <url>/posts/a9be2430/</url>
    <content><![CDATA[<center>小结读写tif文件之前，先总结一下tif文件数值类型以及压缩的必要性和方法。</center>
<span id="more"></span>
<h2 id="numpy数值类型"><a class="markdownIt-Anchor" href="#numpy数值类型"></a> numpy数值类型</h2>
<p><a href="https://www.runoob.com/numpy/numpy-dtype.html">numpy数据类型dtype</a>, 表示为，np.uint8; np.bool_; np.complex64</p>
<ul>
<li>int8, int16, int32, int64;  uint16,  uint16, uint32, uint64;(无符号即大于等于0)</li>
<li>float16, float32, float64</li>
</ul>
<h2 id="tif数值类型"><a class="markdownIt-Anchor" href="#tif数值类型"></a> tif数值类型</h2>
<blockquote>
<p>1MB=1024KB 1KB=1024B 1B=8bit,    1B*3000w/1024/1024=28.6</p>
</blockquote>
<p>数据类型主要包括整型和浮点，其中整型还包括无符号整型，各类型占用空间的大小见下表</p>
<ul>
<li>以一张中国0.01°×0.01°格网的geotif（约）为例：宽6160×高4974约3000w个格点,</li>
<li><strong><font color="#dd0000">如果文件不压缩会很大，大量的空值也会占据空间，因此压缩是必要的。</font></strong></li>
<li><strong>numpy矩阵本身的保存也很大</strong>，而通过h5等文件格式能够较好的用于数据存储并节约内存！</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">数据类型</th>
<th style="text-align:center">单个占用空间(bytes/B)</th>
<th style="text-align:center">数值范围</th>
<th style="text-align:center">数组大小</th>
<th style="text-align:center">TIFF大小(不压缩)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">uint8</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0~255(2^8-1)</td>
<td style="text-align:center">29MB</td>
<td style="text-align:center">29.8MB</td>
</tr>
<tr>
<td style="text-align:center">int8</td>
<td style="text-align:center">1</td>
<td style="text-align:center">-128~127</td>
<td style="text-align:center">29MB</td>
<td style="text-align:center">29.8MB</td>
</tr>
<tr>
<td style="text-align:center">int16</td>
<td style="text-align:center">2</td>
<td style="text-align:center">-32768-32767</td>
<td style="text-align:center">58MB</td>
<td style="text-align:center">59.7MB</td>
</tr>
<tr>
<td style="text-align:center">int32</td>
<td style="text-align:center">4</td>
<td style="text-align:center">…</td>
<td style="text-align:center">116MB</td>
<td style="text-align:center">2.4MB(Lzw压缩)</td>
</tr>
<tr>
<td style="text-align:center">int64</td>
<td style="text-align:center">8</td>
<td style="text-align:center">…</td>
<td style="text-align:center">233MB</td>
<td style="text-align:center">…</td>
</tr>
<tr>
<td style="text-align:center">float16</td>
<td style="text-align:center">2</td>
<td style="text-align:center">10 个尾数位</td>
<td style="text-align:center">58MB</td>
<td style="text-align:center">…</td>
</tr>
<tr>
<td style="text-align:center">float32</td>
<td style="text-align:center">4</td>
<td style="text-align:center">32 个尾数位</td>
<td style="text-align:center">116MB</td>
<td style="text-align:center">119MB</td>
</tr>
</tbody>
</table>
<h3 id="压缩方式"><a class="markdownIt-Anchor" href="#压缩方式"></a> 压缩方式</h3>
<blockquote>
<p>图像/光栅文件<strong>大量冗余</strong>使得压缩可以大量减少其空间，便于数据交换和临时存储，且压缩并不会对影响数据。</p>
</blockquote>
<p>测试结果仅供参考。图像压缩的方式有很多，这里仅比较几个GeoTIFF中常用的三种<strong>无损压缩</strong>算法以及较新的ZSTD(facabook, 2016)，以int32 geotiff文件为例，目前看性价比最高的是<font color="#dd0000">Deflate</font>，然后是LZW：</p>
<ul>
<li>压缩会减少数据占用<font color="#dd0000">空间</font>，但会增加读取和写入数据的<font color="#dd0000">时间</font></li>
<li>压缩的越多压缩所需要的时间越长,时间参考(%%timmit)</li>
<li>通过某些操作如增大GDAL的块缓存可以缩小写入时间，在此不做考虑</li>
</ul>
<table>
<thead>
<tr>
<th>压缩方式</th>
<th style="text-align:center">压缩/写出速度</th>
<th style="text-align:center">压缩比例</th>
<th style="text-align:center">压缩后</th>
<th style="text-align:center">读取速度</th>
</tr>
</thead>
<tbody>
<tr>
<td>PACKBITS</td>
<td style="text-align:center">最快；199ms</td>
<td style="text-align:center">小</td>
<td style="text-align:center">5.91MB</td>
<td style="text-align:center">127ms</td>
</tr>
<tr>
<td>LZW</td>
<td style="text-align:center">中；441ms</td>
<td style="text-align:center">中</td>
<td style="text-align:center">2.41MB</td>
<td style="text-align:center">205ms</td>
</tr>
<tr>
<td>DEFLATE</td>
<td style="text-align:center">慢；570ms</td>
<td style="text-align:center">大</td>
<td style="text-align:center">1.87MB</td>
<td style="text-align:center">140ms</td>
</tr>
<tr>
<td>ZSTD</td>
<td style="text-align:center">最慢；2340ms</td>
<td style="text-align:center">最大</td>
<td style="text-align:center">1.76MB</td>
<td style="text-align:center">191ms</td>
</tr>
</tbody>
</table>
<p>时间测试代码示例 (10 loops each)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%timeit</span><br><span class="line">file = <span class="string">&#x27;...tif&#x27;</span></span><br><span class="line">ds = gdal.Open(file)</span><br><span class="line">im_data = ds.ReadAsArray()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>时空数据处理分析</category>
      </categories>
      <tags>
        <tag>GeoTIFF</tag>
        <tag>栅格数据压缩</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔随记-2022/520</title>
    <url>/posts/29d41ed/</url>
    <content><![CDATA[<p>今天是2022年5月20日，加了一天的班赶材料，这会闲下来，贴一首诗…</p>
<p>When I started loving myself, Charlie Chaplin</p>
<span id="more"></span>
<h2 id="when-i-started-loving-myself"><a class="markdownIt-Anchor" href="#when-i-started-loving-myself"></a> When I started loving myself</h2>
<h2 id="当我开始爱自己"><a class="markdownIt-Anchor" href="#当我开始爱自己"></a> 当我开始爱自己</h2>
<blockquote>
<p>The poem below was written by Charlie Chaplin on his 70th birthday,  April 16, 1959. <a href="https://charterforcompassion.org/attributes-of-compassion/when-i-started-loving-myself">参考</a></p>
</blockquote>
<p>When I started loving myself<br>
I understood that I’m always and at any given opportunity<br>
in the right place at the right time.<br>
And I understood that all that happens is right –<br>
from then on I could be calm.<br>
Today I know: It’s called TRUST.</p>
<p>When I started to love myself I understood how much it can offend somebody<br>
When I tried to force my desires on this person,<br>
even though I knew the time is not right and the person was not ready for it,<br>
and even though this person was me.<br>
Today I know: It’s called LETTING GO</p>
<p>When I started loving myself<br>
I could recognize that emotional pain and grief<br>
are just warnings for me to not live against my own truth.<br>
Today I know: It’s called AUTHENTICALLY BEING.</p>
<p>When I started loving myself<br>
I stopped longing for another life<br>
and could see that everything around me was a request to grow.<br>
Today I know: It’s called MATURITY.</p>
<p>When I started loving myself<br>
I stopped depriving myself of my free time<br>
and stopped sketching further magnificent projects for the future.<br>
Today I only do what’s fun and joy for me,<br>
what I love and what makes my heart laugh,<br>
in my own way and in my tempo.<br>
Today I know: it’s called HONESTY.</p>
<p>When I started loving myself<br>
I escaped from all what wasn’t healthy for me,<br>
from dishes, people, things, situations<br>
and from everything pulling me down and away from myself.<br>
In the beginning I called it the “healthy egoism”,<br>
but today I know: it’s called SELF-LOVE.</p>
<p>When I started loving myself<br>
I stopped wanting to be always right<br>
thus I’ve been less wrong.<br>
Today I’ve recognized: it’s called HUMBLENESS.</p>
<p>When I started loving myself<br>
I refused to live further in the past<br>
and worry about my future.<br>
Now I live only at this moment where EVERYTHING takes place,<br>
like this I live every day and I call it CONSCIOUSNESS.</p>
<p>When I started loving myself<br>
I recognized, that my thinking<br>
can make me miserable and sick.<br>
When I requested for my heart forces,<br>
my mind got an important partner.<br>
Today I call this connection HEART WISDOM.</p>
<p>We do not need to fear further discussions,<br>
conflicts and problems with ourselves and others<br>
since even stars sometimes bang on each other<br>
and create new worlds.<br>
Today I know: THIS IS LIFE!</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/posts/4a17b156/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>
<h2 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start"></a> Quick Start</h2>
<h3 id="create-a-new-post"><a class="markdownIt-Anchor" href="#create-a-new-post"></a> Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="run-server"><a class="markdownIt-Anchor" href="#run-server"></a> Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br><span class="line">$ hexo s</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files"><a class="markdownIt-Anchor" href="#generate-static-files"></a> Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br><span class="line">$ hexo g</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#deploy-to-remote-sites"></a> Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<h3 id="command"><a class="markdownIt-Anchor" href="#command"></a> command</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo deploy</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Hexo框架</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>matplotlib基础(2)：绘图逻辑与输出尺寸/格式</title>
    <url>/posts/5524eff4/</url>
    <content><![CDATA[<p><a href="https://hscyber.github.io/posts/8dfff56a/">前一节</a>小结了一下Matplotlib一张图表的组成(Elements), 也即<strong>Anatomy of a figure</strong>，包括Figure, Axes, Axis, Spines…。另外还指出了一个点-图表本质上<u>是由以下三种要素的组合: patchs块、线和文本</u>，<strong>且理论上上述部件(也称artist)都能够被访问和调整，即自定义</strong>。接下来要要做的即是逐步熟悉各部件的调整，在此之前先简单理一理绘图的<strong>逻辑</strong>及最基本的创建<strong>画布和图形及字体尺寸</strong>，并放了A4尺寸出图的参考代码。附录是关于文件格式的简单汇总。</p>
<span id="more"></span>
<h2 id="绘图的逻辑"><a class="markdownIt-Anchor" href="#绘图的逻辑"></a> 绘图的逻辑</h2>
<blockquote>
<p>用代码绘图的思路和用软件如PS/AI/CoreDraw等是一样的</p>
</blockquote>
<blockquote>
<p>主要针对最后的出图而非草图</p>
</blockquote>
<p>通常制作一张图表通常包含几步：</p>
<ol>
<li>数据的整理和图的设计</li>
<li>确定风格、字体字号、分辨率dpi等等</li>
<li>新建画布，选择大小尺寸</li>
<li>插入图层，设计图形的布局，在不同的层上绘制图形</li>
<li>最终叠加的结果即为成图</li>
<li>保存并输出图片，格式-或矢量(.SVG/ .PDF/ .PS)或栅格(.PNG/ .JPS/ .TIFF)</li>
</ol>
<h2 id="图层顺序"><a class="markdownIt-Anchor" href="#图层顺序"></a> 图层顺序</h2>
<blockquote>
<p>通过属性zorder=…来设置图层绘制顺序，数字越小越在底层</p>
<p>tips: 将图形输出为**.svg**导入 Adobe IIIustrator可以看到各形状的排布顺序并调整</p>
</blockquote>
<p>通常我们不需要修改，但是当大量图形绘制产生叠盖或者较复杂时可以考虑调整该参数，如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">ax.plot(..., zorder=<span class="number">80</span>)</span><br></pre></td></tr></table></figure>
<img src="/posts/5524eff4/zorder.png" class alt="zorder">
<h2 id="图形尺寸"><a class="markdownIt-Anchor" href="#图形尺寸"></a> 图形尺寸</h2>
<blockquote>
<p>除了画布的尺寸，其他形状如线、点的大小宽度默认单位都是pt. 1/72英寸</p>
</blockquote>
<h3 id="要点小结"><a class="markdownIt-Anchor" href="#要点小结"></a> 要点/小结</h3>
<ol>
<li><strong><font color="#dd0000">figsize()决定了图像输出的实际大小，即修改dpi图像尺寸不会变</font></strong></li>
<li><strong><font color="#dd0000">分辨率决定了<u>栅格图像模糊/清晰度</u>，矢量缩放清晰度不影响</font></strong></li>
</ol>
<p>所以实际中，以A4纸(21cm宽，高29.7cm)为例，我们可以设置如下：</p>
<ul>
<li>21cm/2.54=8.27，29.7/2.54=11.7假设两边各1.27cm的边距，则7.26</li>
<li>pad_inches=0.5表明各设置0.5英寸-&gt; 四周1.27cm的边距</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建画布，画布默认背景为透明即空颜色facecolor=&#x27;w&#x27;表示设为白色</span></span><br><span class="line">cm = <span class="number">1</span>/<span class="number">2.54</span></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">21</span>*cm,<span class="number">29.7</span>*cm),facecolor=<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"><span class="comment"># fig, ax = plt.subplots(figsize=(8.27,11.7),facecolor=&#x27;w&#x27;)</span></span><br><span class="line">ax.plot(<span class="built_in">range</span>(<span class="number">20</span>))</span><br><span class="line">plt.savefig(<span class="string">r&quot;./A4.png&quot;</span>, dpi=<span class="number">300</span>,pad_inches=<span class="number">0.5</span>,bbox_inches=<span class="string">&#x27;tight&#x27;</span>)</span><br><span class="line">plt.savefig(<span class="string">r&quot;./A4.pdf&quot;</span>, dpi=<span class="number">300</span>,pad_inches=<span class="number">0.5</span>,bbox_inches=<span class="string">&#x27;tight&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>其他尺寸的图像类推自行设计</p>
<h4 id="补充"><a class="markdownIt-Anchor" href="#补充"></a> 补充</h4>
<p>在jupyter中绘图时，默认dpi为72，此时dpi会影响图像的显示大小，所以为了方便我们可以先预设一个较清晰的dpi，但我们在输出时也可以单独指定文件的dpi，二者并不冲突，运行时<a href="https://matplotlib.org/stable/tutorials/introductory/customizing.html#customizing-with-dynamic-rc-settings">rc调整</a></p>
<ul>
<li>更多可以<a href="https://matplotlib.org/stable/gallery/subplots_axes_and_figures/figure_size_units.html">参考</a></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># rc默认设置文件目录：matplotlib.matplotlib_fname()，比如我的路径在</span></span><br><span class="line"><span class="comment"># &gt;&gt;&#x27;D:\\Miniconda3\\envs\\vis\\lib\\site-packages\\matplotlib\\mpl-data\\matplotlibrc&#x27;</span></span><br><span class="line">mpl.rcParams[<span class="string">&#x27;figure.dpi&#x27;</span>] = <span class="number">200</span></span><br></pre></td></tr></table></figure>
<h3 id="字体的大小磅"><a class="markdownIt-Anchor" href="#字体的大小磅"></a> 字体的大小/磅</h3>
<blockquote>
<p>字体的大小也是直接实际的大小，默认是以磅数(point (pt))为单位</p>
</blockquote>
<p>1 (pt)磅等于1/72 英寸，默认字体大小为10磅，比如我们可以设置默认字体为10.5磅即五号</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">matplotlib.rcParams[<span class="string">&#x27;font.size&#x27;</span>]=<span class="number">10.5</span></span><br></pre></td></tr></table></figure>
<p>字体字号和磅数的对应关系，具体可以搜索</p>
<table>
<thead>
<tr>
<th style="text-align:center">字号</th>
<th style="text-align:center">磅数(pt)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">小五</td>
<td style="text-align:center">9</td>
</tr>
<tr>
<td style="text-align:center">五号</td>
<td style="text-align:center">10.5</td>
</tr>
<tr>
<td style="text-align:center">小四</td>
<td style="text-align:center">12</td>
</tr>
<tr>
<td style="text-align:center">小三</td>
<td style="text-align:center">15</td>
</tr>
<tr>
<td style="text-align:center">三号</td>
<td style="text-align:center">16</td>
</tr>
<tr>
<td style="text-align:center">小二</td>
<td style="text-align:center">18</td>
</tr>
<tr>
<td style="text-align:center">二号</td>
<td style="text-align:center">22</td>
</tr>
</tbody>
</table>
<h3 id="线宽和点的大小"><a class="markdownIt-Anchor" href="#线宽和点的大小"></a> 线宽和点的大小</h3>
<blockquote>
<p>lw=2.8时大概线宽是1mm； 散点图s=math.pi*8, 直径约为2mm</p>
</blockquote>
<p>线宽默认1.5，换算1pt=2.54/72 -&gt; <strong>1.5pt=0.53mm</strong>， 默认的markersize=2.12mm</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">matplotlib.rcParams[<span class="string">&#x27;lines.linewidth&#x27;</span>]=<span class="number">1.5</span></span><br><span class="line">matplotlib.rcParams[<span class="string">&#x27;lines.markersize&#x27;</span>]=<span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>散点图的点默认尺寸为rcParams[‘lines.markersize’] ** 2=1.27cm²，<strong>，注意代表的是散点圆的面积</strong></p>
<h3 id="尺寸计算原理"><a class="markdownIt-Anchor" href="#尺寸计算原理"></a> 尺寸计算原理</h3>
<blockquote>
<p>设置的时候只需要用实际预期长度除以2.54。</p>
</blockquote>
<p>图像输出的实际尺寸大小计算及距举例，<strong>1厘米(cm)=0.394英寸(inch)， 1英寸=2.54厘米</strong></p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>i</mi><mi>m</mi><mi>a</mi><mi>g</mi><mi>e</mi><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo stretchy="false">(</mo><mi>c</mi><mi>m</mi><mo stretchy="false">)</mo><mo>=</mo><mi>d</mi><mi>p</mi><mi>i</mi><mo>×</mo><mi>f</mi><mi>i</mi><mi>g</mi><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo>÷</mo><mfrac><mrow><mi>d</mi><mi>p</mi><mi>i</mi></mrow><mn>2.54</mn></mfrac><mspace linebreak="newline"></mspace><mo>=</mo><mi>f</mi><mi>i</mi><mi>g</mi><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo>×</mo><mn>2.54</mn><mspace linebreak="newline"></mspace></mrow><annotation encoding="application/x-tex">imagesize(cm)=dpi\times figsize\div \frac{dpi}{2.54}\\=figsize\times 2.54 \\
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">÷</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.0574399999999997em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714399999999998em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord">.</span><span class="mord">5</span><span class="mord">4</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mord mathnormal">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">.</span><span class="mord">5</span><span class="mord">4</span></span><span class="mspace newline"></span></span></span></span></p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>p</mi><mi>i</mi><mo>=</mo><mn>300</mn><mo separator="true">,</mo><mi>f</mi><mi>i</mi><mi>g</mi><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo>=</mo><mo stretchy="false">(</mo><mn>6</mn><mo separator="true">,</mo><mn>12</mn><mo stretchy="false">)</mo><mspace linebreak="newline"></mspace><mi>w</mi><mi>i</mi><mi>d</mi><mi>t</mi><mi>h</mi><mo>=</mo><mn>6</mn><mo>×</mo><mn>300</mn><mo>÷</mo><mfrac><mn>300</mn><mn>2.54</mn></mfrac><mo>=</mo><mn>15.24</mn><mi>c</mi><mi>m</mi><mspace linebreak="newline"></mspace><mi>h</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo>=</mo><mn>12</mn><mo>×</mo><mn>2.54</mn><mo>=</mo><mn>30.48</mn><mi>c</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">dpi = 300, figsize = (6,12) \\
width = 6\times 300 \div \frac{300}{2.54}=15.24cm \\
height = 12\times 2.54 = 30.48cm
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">3</span><span class="mord">0</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mclose">)</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">i</span><span class="mord mathnormal">d</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">÷</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord">.</span><span class="mord">5</span><span class="mord">4</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span><span class="mord">0</span><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mord">.</span><span class="mord">2</span><span class="mord">4</span><span class="mord mathnormal">c</span><span class="mord mathnormal">m</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">.</span><span class="mord">5</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">0</span><span class="mord">.</span><span class="mord">4</span><span class="mord">8</span><span class="mord mathnormal">c</span><span class="mord mathnormal">m</span></span></span></span></span></p>
<p><strong>分辨率</strong>/resolution的度量-dpi：指每英寸点数Dots per inch/每厘米点数</p>
<p><strong>像素密度</strong>测量指标：ppi; pixels/cm ppcm</p>
<ul>
<li>每英寸像素Pixels per inch/每厘米像素pixels per centimetre</li>
</ul>
<h2 id="补充概念"><a class="markdownIt-Anchor" href="#补充概念"></a> 补充概念</h2>
<h3 id="静态图像文件格式"><a class="markdownIt-Anchor" href="#静态图像文件格式"></a> 静态图像文件格式</h3>
<blockquote>
<p>栅格raster(也称位图)和矢量vector是两类</p>
</blockquote>
<table>
<thead>
<tr>
<th>图片/文件格式</th>
<th>类型</th>
<th>大小</th>
<th>主流用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>JPEG/JPG</td>
<td>有损光栅</td>
<td>小</td>
<td>Web/在线网站</td>
</tr>
<tr>
<td>PNG</td>
<td>无损光栅</td>
<td>中</td>
<td>屏幕</td>
</tr>
<tr>
<td>TIF/TIFF</td>
<td>无损光栅</td>
<td>大</td>
<td>印刷/打印</td>
</tr>
<tr>
<td>SVG</td>
<td>无损可缩放矢量</td>
<td>小</td>
<td>web/论文</td>
</tr>
<tr>
<td>PDF</td>
<td>便携式文档格式</td>
<td>小</td>
<td>多图/共享</td>
</tr>
</tbody>
</table>
<h4 id="主要区别"><a class="markdownIt-Anchor" href="#主要区别"></a> 主要区别</h4>
<ul>
<li>
<p>JPEG是一种有损图像文件格式，其质量会随着文件大小而降低</p>
</li>
<li>
<p>TIFF和RNG都是无损压缩的位图格式，但是TIF文件更大保留了更多的信息；而PNG 更加轻巧且支持透明度；但png不支持 CMYK 颜色</p>
</li>
<li>
<p>通常将 SVG 描述为一种图像格式，但它实际上是一种文档格式，类似于 HTML 文档，因此可以托管脚本或 CSS，因此常用于网站呈现</p>
</li>
<li>
<p>svg和pdf输出都是可缩放无损的，不会出现栅格的放大模糊现象</p>
</li>
<li>
<p>PDF可以直接用于写作，组合多个图像</p>
</li>
</ul>
<h4 id="别名"><a class="markdownIt-Anchor" href="#别名"></a> 别名</h4>
<p>JPEG/JPG：Joint Photographic Experts Group，联合图像专家组</p>
<p>PNG：Portable Network Graphics，便携式网络图形</p>
<p>TIFF：Tagged Image File Format，标记图像文件格式</p>
<p>SVG：Scalable Vector Graphics，可缩放矢量图形（基于XML标记语言）</p>
<p>PDF：Portable Document Format，便携式文档格式</p>
<h3 id="backends"><a class="markdownIt-Anchor" href="#backends"></a> Backends</h3>
<blockquote>
<p><a href="https://matplotlib.org/stable/users/explain/backends.html">后端Backends</a>/前端frontend，后端可理解为支撑绘图制作的工具，前端则是面向用户的绘图代码</p>
</blockquote>
<p>后端是绘制图形的底层工具和可操作接口的组合，针对不同的需求，如有时需要在命令行输出图形，或需要在jupyter中绘制图形或直接根据数值生成图形写入内存，不同的后端支持不同的文件格式</p>
<ul>
<li>后端有交互式和非交互式</li>
<li>默认Matplotlib 应该自动选择一个后端，允许交互式工作和从脚本绘图，输出到屏幕或文件，用户不需手动设置。若需要编写图形界面或者嵌入Web应用程序服务器可再查</li>
</ul>
]]></content>
      <categories>
        <category>Python可视化</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Matplotlib</tag>
        <tag>出图尺寸</tag>
        <tag>分辨率</tag>
      </tags>
  </entry>
  <entry>
    <title>matplotlib基础(3)：图片存储常用格式及参数设置</title>
    <url>/posts/459b5ff7/</url>
    <content><![CDATA[<p>初步小结一下图形保存本地的常用设置，通过参数设置可以输出非常高质量清晰的且长宽格式的图片或pdf文件，主要介绍png、svg及pdf格式，以A4纸的宽度21cm或一半10cm为例测试。对于具体图形、文字、线条等尺寸的大小控制及文件格式可见<a href="https://hscyber.github.io/posts/5524eff4">上篇</a>。</p>
<span id="more"></span>
<p>需要说明的是，这一步是<a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.savefig.html">fig.save()</a>，即保存画布的步骤，这时<u>已经无法再调画布上的ax的图形，通常只能调节</u>：</p>
<ol>
<li>画布的背景颜色<strong>facecolor</strong>、边框颜色<strong>edgecolor</strong></li>
<li>图形四周默认的空白间距<strong>pad_inches</strong>，精细调节则<strong>bbox_inches</strong>，，多个ax的紧凑程度<strong>bbox_inches</strong></li>
<li>保存文件的文件格式及路径、清晰度<strong>dpi</strong></li>
</ol>
<p><font color="#dd0000">常规出图png即可，论文成图简单可png，较复杂细节多的可出无损矢量图svg或pdf，</font>此外svg格式的结果可以在<strong>Adobe Illustrator</strong>中调节，下文简单介绍。(地图保存也可以输出问svg或pdf，ArcMap&amp;QGIS均可)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib.backends.backend_pdf <span class="keyword">import</span> PdfPages</span><br><span class="line">mpl.rcParams[<span class="string">&#x27;figure.dpi&#x27;</span>] = <span class="number">120</span></span><br><span class="line">mpl.rcParams[<span class="string">&#x27;font.size&#x27;</span>]=<span class="number">10.5</span></span><br><span class="line">cm = <span class="number">1</span>/<span class="number">2.54</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#0.5代表1.27cm的间距</span></span><br><span class="line">fig.savefig(<span class="string">&#x27;../test.png&#x27;</span>,dpi=<span class="number">300</span>,bbox_inches=<span class="string">&#x27;tight&#x27;</span>,pad_inches=<span class="number">0.5</span>)</span><br><span class="line">fig.savefig(<span class="string">&#x27;../test.svg&#x27;</span>,dpi=<span class="number">300</span>,bbox_inches=<span class="string">&#x27;tight&#x27;</span>,pad_inches=<span class="number">0.5</span>)</span><br><span class="line">fig.savefig(<span class="string">&#x27;../test.pdf&#x27;</span>,dpi=<span class="number">300</span>,bbox_inches=<span class="string">&#x27;tight&#x27;</span>,pad_inches=<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure>
<h2 id="出图对比"><a class="markdownIt-Anchor" href="#出图对比"></a> 出图对比</h2>
<p>出图举例：此处目的是展示出图，从官网拉两张图拼接示意<a href="https://matplotlib.org/stable/gallery/lines_bars_and_markers/fill_between_demo.html#sphx-glr-gallery-lines-bars-and-markers-fill-between-demo-py">f1</a>，<a href="https://matplotlib.org/stable/gallery/subplots_axes_and_figures/axis_labels_demo.html#sphx-glr-gallery-subplots-axes-and-figures-axis-labels-demo-py">f2</a>，导入模块，修改路径运行代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig, (ax1, ax2) = plt.subplots(nrows =<span class="number">1</span> ,ncols=<span class="number">2</span>, figsize=(<span class="number">21</span>*cm,<span class="number">10</span>*cm), facecolor=<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"><span class="comment"># 图一参考</span></span><br><span class="line">N = <span class="number">21</span></span><br><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">10</span>, <span class="number">11</span>)</span><br><span class="line">y = [<span class="number">3.9</span>, <span class="number">4.4</span>, <span class="number">10.8</span>, <span class="number">10.3</span>, <span class="number">11.2</span>, <span class="number">13.1</span>, <span class="number">14.1</span>,  <span class="number">9.9</span>, <span class="number">13.9</span>, <span class="number">15.1</span>, <span class="number">12.5</span>]</span><br><span class="line"><span class="comment"># fit a linear curve an estimate its y-values and their error.</span></span><br><span class="line">a, b = np.polyfit(x, y, deg=<span class="number">1</span>)</span><br><span class="line">y_est = a * x + b</span><br><span class="line">y_err = x.std() * np.sqrt(<span class="number">1</span>/<span class="built_in">len</span>(x) +(x - x.mean())**<span class="number">2</span> / np.<span class="built_in">sum</span>((x - x.mean())**<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">ax1.plot(x, y_est, <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">ax1.fill_between(x, y_est - y_err, y_est + y_err, alpha=<span class="number">0.2</span>)</span><br><span class="line">ax1.plot(x, y, <span class="string">&#x27;o&#x27;</span>, ms=<span class="number">4</span>, color=<span class="string">&#x27;tab:red&#x27;</span>)</span><br><span class="line"><span class="comment"># 图2</span></span><br><span class="line">sc = ax2.scatter([<span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">2</span>], c=[<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">ax2.set_ylabel(<span class="string">&#x27;YLabel&#x27;</span>, loc=<span class="string">&#x27;top&#x27;</span>)</span><br><span class="line">ax2.set_xlabel(<span class="string">&#x27;XLabel&#x27;</span>, loc=<span class="string">&#x27;left&#x27;</span>)</span><br><span class="line">cbar = fig.colorbar(sc)</span><br><span class="line">cbar.set_label(<span class="string">&quot;ZLabel&quot;</span>, loc=<span class="string">&#x27;top&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">fig.savefig(<span class="string">r&#x27;...\f1.png&#x27;</span>,dpi=<span class="number">300</span>,bbox_inches=<span class="string">&#x27;tight&#x27;</span>,pad_inches=<span class="number">0.5</span>)</span><br><span class="line">fig.savefig(<span class="string">r&#x27;...\f1.svg&#x27;</span>,dpi=<span class="number">300</span>,bbox_inches=<span class="string">&#x27;tight&#x27;</span>,pad_inches=<span class="number">0.5</span>)</span><br><span class="line">fig.savefig(<span class="string">r&#x27;...\f1.pdf&#x27;</span>,dpi=<span class="number">300</span>,bbox_inches=<span class="string">&#x27;tight&#x27;</span>,pad_inches=<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure>
<h3 id="png"><a class="markdownIt-Anchor" href="#png"></a> png</h3>
<p>结果图，置入word刚好合适，四周边距还可以根据要求调整</p>
<img src="/posts/undefined/f1.png" class alt="f1">
<h3 id="细节矢量图svg"><a class="markdownIt-Anchor" href="#细节矢量图svg"></a> 细节矢量图svg</h3>
<p>使用浏览器打开即可预览，或者可以打开AI，进行进一步地拼图或调整图层等操作</p>
<img src="/posts/undefined/f3.png" class alt="f3">
<h3 id="细节矢量图pdf"><a class="markdownIt-Anchor" href="#细节矢量图pdf"></a> 细节矢量图pdf</h3>
<p>如下图，按设定画布固定大小的pdf，其实期刊论文的发表附图都要求使用pdf等矢量格式，因为高清无损！正文不方便，但在论文支撑材料/附件中可以生成PDF最后拼接即可。</p>
<img src="/posts/undefined/f2.png" class alt="f2">
<h2 id="多页pdf"><a class="markdownIt-Anchor" href="#多页pdf"></a> 多页pdf</h2>
<p>单个figure保存至pdf，比如我这里绘制了一幅6行3列的组图，保存为一页pdf文件，当然也可以直接保存为png或其他格式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">save_pdf = <span class="string">&quot;./figure/test.pdf&quot;</span></span><br><span class="line">fig, axes = plt.subplots(nrows =<span class="number">6</span> ,ncols=<span class="number">3</span>, figsize=(<span class="number">21</span>*cm,<span class="number">29.7</span>*cm),facecolor=<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">axes = axes.flatten()</span><br><span class="line"><span class="keyword">for</span> ax <span class="keyword">in</span> axes:</span><br><span class="line">    ax.plot(...)</span><br><span class="line">    ax.text(...)</span><br><span class="line">fig.savefig(save_pdf,<span class="built_in">format</span>=<span class="string">&#x27;pdf&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>多个figure保存为多页pdf，<code>PdfPages</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib.backends.backend_pdf <span class="keyword">import</span> PdfPages</span><br><span class="line"></span><br><span class="line">save_pdf = <span class="string">&quot;./figure/test.pdf&quot;</span></span><br><span class="line">pdf = PdfPages(save_pdf) <span class="comment"># 打开文件</span></span><br><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> df.columns.to_list():</span><br><span class="line">    values = df[col].to_numpy()</span><br><span class="line">    fig, ax = plt.subplots(figsize=(<span class="number">21</span>*cm,<span class="number">29.7</span>*cm),facecolor=<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">    ax.hist(values,<span class="number">50</span>)</span><br><span class="line">    fig.savefig(pdf,<span class="built_in">format</span>=<span class="string">&#x27;pdf&#x27;</span>) <span class="comment"># 保存</span></span><br><span class="line">    plt.close()</span><br><span class="line">pdf.close() <span class="comment"># 保存</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python可视化</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title>matplotlib基础(1)：图的组成元素</title>
    <url>/posts/8dfff56a/</url>
    <content><![CDATA[<p><strong>绘图技能</strong>是我一直想要拓展和延伸的一个技能。这一方面需要通过大量的输入来学习别人对图表的设计和呈现，学习色彩、布局等等……另一方面还要能够用代码来实现，而需要基于代码的可视化是一个比较繁琐的内容，需要学习和积累。故在此开始记录自己Python可视化的学习过程，当然，也便于代码的复用。本文主要涉及内容：</p>
<ol>
<li><strong>Matplotlib中Figure的组成要素</strong></li>
<li><strong>主要元素的常用方法汇总</strong></li>
<li>其他的诸如风格、字体、网格、图例、色带陆续总结……</li>
</ol>
<span id="more"></span>
<p>一张好看的学术图表不仅能够更优雅简洁地传递信息，也能给人予美的享受。在撰写学术论文的过程，耗费大量时间的除了做实验，另一个一定是作图了，要通过几张图把信息很好地呈现出来，需要费不少功夫。</p>
<blockquote>
<p>本系列笔记主要参考：<a href="https://matplotlib.org/stable/tutorials/introductory/usage.html">Matplotlib usage</a>, <a href="https://matplotlib.org/stable/api/index.html">Matplotlibapi文档</a>，<a href="https://matplotlib.org/stable/gallery/index.html">Matplotlib Gallery</a>，部分参考<a href="https://github.com/rougier/scientific-visualization-book">Rougier老师的开源书</a></p>
</blockquote>
<p>另外，快速绘图<a href="https://matplotlib.org/cheatsheets/cheatsheets.pdf">备忘录下载</a>，该备忘录有两张大图（<a href="https://camo.githubusercontent.com/bc3b143766ed68eb6a851900c317c5d9222eb1471888942afb35137aa5141557/68747470733a2f2f6d6174706c6f746c69622e6f72672f63686561747368656574732f63686561747368656574732d312e706e67">基础绘图</a>;<a href="https://camo.githubusercontent.com/8566d191963c2ada58246241d19a1252c519edea1ecf4049f5bc939e302e36a8/68747470733a2f2f6d6174706c6f746c69622e6f72672f63686561747368656574732f63686561747368656574732d322e706e67">色彩及文字等</a>），可以快速查看常见的绘图操作/函数，函数右侧的<strong>api</strong>还可以点击直达官网api文档详细介绍。</p>
<img src="/posts/8dfff56a/text-shadow.png" class alt="matplotlib">
<p>上图即通过matplotlib代码制作，详见<a href="https://github.com/rougier/scientific-visualization-book">book</a></p>
<h2 id="图的组成"><a class="markdownIt-Anchor" href="#图的组成"></a> 图的组成</h2>
<blockquote>
<p>matplotlib最新版的文档做了较大的改版，提供了更全的<a href="https://matplotlib.org/stable/gallery/index.html">api参考</a></p>
</blockquote>
<p>下图是Matplotlib官方文档中提供的一张介绍图组成元素的图，很整洁，左图为<a href="https://matplotlib.org/3.1.1/gallery/showcase/anatomy.html">旧版anatomy</a>，右图为最新的文档<a href="https://matplotlib.org/stable/gallery/showcase/anatomy.html?highlight=anatomy">anatomy</a>里的图，我稍作改动放到了一起：</p>
<img src="/posts/8dfff56a/anatomy.png" class alt="anatomy">
<h3 id="组成总览"><a class="markdownIt-Anchor" href="#组成总览"></a> 组成总览</h3>
<ul>
<li>
<p><strong>Figure</strong>：所有绘图元素的顶级容器，大致可以理解为<strong>画布canvas</strong>。我们可以设置它的尺寸(figsize)、标题(suptile)、x标签(supxlabel)、背景颜色(facecolor )等属性，背景默认是透明 transparent=True。</p>
</li>
<li>
<p><strong>Axes</strong>：相当于Subplot，子图，是我们实际的绘图区域，为<strong>矩形</strong>。一张图可以有多个子图(Axes)，如上图</p>
<ul>
<li><strong>Spines</strong>： 图边，每个子图都有4条边，<u>每条边有主副刻度线(Tick)+主副刻度标签(Tick labels)+边标签(Label)</u>，默认只显示左+下的Spine。</li>
<li><strong>Axis</strong>：默认显示的左和下方的两条Spines分别为<u>yaxis，xaxis</u>，属性同Spines。</li>
<li><strong>Line points</strong>…：绘制的图形，也就是我们要在axes上画的东西</li>
<li><strong>Legend</strong>：图例，每个axes都可以根据其上绘制的图形生成图例，也可以不依赖图形单独创建。</li>
<li><strong>Grid</strong>：网格线，自行选择是否添加（按照主副刻度线生成）</li>
<li><strong>Text</strong>：文本，可以作为注释说明添加到图上
<ul>
<li><strong>Annotation</strong>：可以添加连接线/箭头的文本，注释</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Artist</strong> : <strong>Everything on the figure</strong>, including Figure, Axes, and Axis objects, is an artist. 理解为图元素。</p>
<ul>
<li>组成<a href="https://matplotlib.org/stable/_images/inheritance-746d7ad5b4a3ecbadc51ab040f5d995f5c6ecc71.png">图</a></li>
</ul>
</li>
</ul>
<p>了解了组成部件，之后我们的学习任务主要就是了解和属性各个部件繁多的<strong>属性和属性调整的方法</strong>，以及组合。</p>
<p>下一节即有针对性地看一下各个元素的属性方法等</p>
<h3 id="图的基本单元"><a class="markdownIt-Anchor" href="#图的基本单元"></a> 图的基本单元</h3>
<p>任意的一张图，本质上是由以下三种要素的组合（莫明想起了GIS里的点线面hh）：</p>
<ul>
<li>patchs：块，如background bars ……</li>
<li>lines：线，如tick,line……</li>
<li>texts：文本，如label title……</li>
</ul>
<p>多数情况下我们都是使用绘图自带的<strong>默认</strong>设置，但是实际上，一张图的**任一组成部分即上述部件都能够被访问和调整！**如我们可以像下面这样直接设置每个label加粗，<strong>这些方法都能够在文档中快速找到</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>,<span class="number">2</span>))</span><br><span class="line"><span class="keyword">for</span> label <span class="keyword">in</span> ax.get_xaxis().get_ticklabels():</span><br><span class="line">    label.set_fontweight(<span class="string">&quot;bold&quot;</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>
<p>🔥想强调的是，每个部件在我们创建了一个图形之后就有了<strong>类</strong>对应的<strong>实例</strong>（对类不熟悉的可以移步<a href="https://hscyber.github.io/posts/659ef075/">Python中的类</a>），通过查阅<a href="https://matplotlib.org/stable/api/index.html">文档</a>我们可以看到该对象的<strong>所有属性及方法</strong>，进一步地我们可以按需检索并实现我们对图形想要进行的<strong>任意设置或调整</strong>，下面开始介绍并举例：</p>
<h2 id="主要部件详解"><a class="markdownIt-Anchor" href="#主要部件详解"></a> 主要部件详解</h2>
<p>虽然有文档，但是我还是要熟悉一些常见的属性方法，以使我们能够<strong>快速出图</strong>，至于最终成图的细节则可以再细扣</p>
<p>另外，以下所有均来自<u>Matplotlib3.5官方文档</u>，一些参数细节暂不展开讲，在后续的总结中再慢慢铺开</p>
<h3 id="figure"><a class="markdownIt-Anchor" href="#figure"></a> Figure</h3>
<blockquote>
<p><code>class matplotlib.figure.Figure</code>, <a href="https://matplotlib.org/stable/api/figure_api.html#matplotlib.figure.Figure">类的属性及方法</a></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 创建一个 fig实例 </span></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">5</span>, <span class="number">4</span>))</span><br><span class="line">fig, ax = plt.subplots()</span><br></pre></td></tr></table></figure>
<p>常用属性及方法/函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建时即可传参</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">matplotlib</span>.figure.Figure(figsize=<span class="literal">None</span>, dpi=<span class="literal">None</span>, facecolor=<span class="literal">None</span>, edgecolor=<span class="literal">None</span>, linewidth=<span class="number">0.0</span>, frameon=<span class="literal">None</span>, subplotpars=<span class="literal">None</span>, tight_layout=<span class="literal">None</span>, constrained_layout=<span class="literal">None</span>, *, layout=<span class="literal">None</span>, **kwargs)</span><br><span class="line"><span class="comment"># 添加子图</span></span><br><span class="line">.add_subplot()</span><br><span class="line">.add_axes()</span><br><span class="line">.subplots()</span><br><span class="line">.add_gridspec() <span class="comment">#复杂布局时使用</span></span><br><span class="line"><span class="comment"># 日期ticklabels自动调整，自动旋转以免叠盖</span></span><br><span class="line">.autofmt_xdate(bottom=<span class="number">0.2</span>, rotation=<span class="number">30</span>, ha=<span class="string">&#x27;right&#x27;</span>, which=<span class="string">&#x27;major&#x27;</span>)</span><br><span class="line"><span class="comment"># 添加色带</span></span><br><span class="line">.colorbar(mappable, cax=<span class="literal">None</span>, ax=<span class="literal">None</span>, use_gridspec=<span class="literal">True</span>, **kw)</span><br><span class="line"><span class="comment"># 放置图例</span></span><br><span class="line">.legend()</span><br><span class="line"><span class="comment"># 设置标题、文本</span></span><br><span class="line">.suptitle()</span><br><span class="line">.supxlabel(); .supylabel()</span><br><span class="line">.text(x, y, s, fontdict=<span class="literal">None</span>, **kwargs)</span><br><span class="line"><span class="comment"># 保存，常用，常用设置会在另一篇文章展开</span></span><br><span class="line">.savefig(fname, *, dpi=<span class="string">&#x27;figure&#x27;</span>, <span class="built_in">format</span>=<span class="literal">None</span>, metadata=<span class="literal">None</span>,</span><br><span class="line">        bbox_inches=<span class="literal">None</span>, pad_inches=<span class="number">0.1</span>,</span><br><span class="line">        facecolor=<span class="string">&#x27;auto&#x27;</span>, edgecolor=<span class="string">&#x27;auto&#x27;</span>,</span><br><span class="line">        backend=<span class="literal">None</span>, **kwargs)</span><br><span class="line"><span class="comment"># 设置各种属性，可以一次性设置多个参数，详见文档</span></span><br><span class="line">.<span class="built_in">set</span>(*...)</span><br><span class="line">.set_label(s)</span><br><span class="line">.set_alpha(alpha)</span><br><span class="line">.set_constrained_layout(constrained)</span><br><span class="line">.set_constrained_layout_pads(*, w_pad=<span class="literal">None</span>, h_pad=<span class="literal">None</span>, wspace=<span class="literal">None</span>, hspace=<span class="literal">None</span>)</span><br><span class="line">.set_dpi(); .set_edgecolor; .set_facecolor()...</span><br><span class="line"><span class="comment"># 获取</span></span><br><span class="line">.gca()  <span class="comment">#当前axes</span></span><br><span class="line">.get_axes()</span><br><span class="line">.get_children()</span><br><span class="line">.get_edgecolor(); .get_facecolor()</span><br><span class="line">.get_figheight(); .get_figwidth()</span><br></pre></td></tr></table></figure>
<h3 id="axes-绘图区"><a class="markdownIt-Anchor" href="#axes-绘图区"></a> 🔥Axes-绘图区</h3>
<blockquote>
<p><code>class matplotlib.axes.Axes</code>，<a href="https://matplotlib.org/stable/api/axes_api.html#the-axes-class">类的属性及方法</a></p>
</blockquote>
<p>创建，有很多种方式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#常用</span></span><br><span class="line">fig, ax = plt.subplots(ncols=<span class="number">2</span>, nrows=<span class="number">3</span>, figsize=(<span class="number">12</span>,<span class="number">8</span>), sharex=<span class="literal">True</span>)</span><br><span class="line">axs[<span class="number">2</span>, <span class="number">0</span>].plot([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]) <span class="comment">#在第三行第一列绘图</span></span><br><span class="line">ax_list = ax.flatten() <span class="comment">#可以遍历获取各个axes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一张图,一个axes,</span></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">10</span>, <span class="number">8</span>))</span><br><span class="line">ax = fig.add_subplot(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, aspect=<span class="number">1</span>)<span class="comment"># aspect是xy横纵比</span></span><br><span class="line">ax = fig.add_subplot(<span class="number">111</span>, aspect=<span class="number">1</span>)</span><br><span class="line"><span class="comment">#创建两个axes,一行两列</span></span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax1,ax2 = fig.add_subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, aspect=<span class="number">1</span>),fig.add_subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, aspect=<span class="number">1</span>)</span><br><span class="line">plt.show()</span><br><span class="line"><span class="comment">#创建两个axes,两行一列</span></span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax1,ax2 = fig.add_subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, aspect=<span class="number">1</span>),fig.add_subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, aspect=<span class="number">1</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建共享x、y轴的axes，左右双图</span></span><br><span class="line">axes.twinx() </span><br><span class="line">axes.twiny()</span><br><span class="line">.sharex()<span class="comment"># 也可以手动设置/绑定axes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 大小不一多子图的复杂布局，使用gridspec，具体查阅文档</span></span><br><span class="line">fig = plt.figure(constrained_layout=<span class="literal">True</span>)</span><br><span class="line">gs = fig.add_gridspec(<span class="number">3</span>, <span class="number">3</span>) <span class="comment">#初始九个图</span></span><br><span class="line">f_ax1 = fig.add_subplot(gs[<span class="number">0</span>, :]) <span class="comment">#合并了第一行的三个图，现在变成7张图</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>绘图（快速绘图）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">.plot() <span class="comment">#折线图</span></span><br><span class="line">.scatter() <span class="comment">#散点图</span></span><br><span class="line">.bar() <span class="comment">#柱状图</span></span><br><span class="line">.pie() <span class="comment">#饼图</span></span><br><span class="line">.hist() <span class="comment">#直方图</span></span><br><span class="line">.boxplot() <span class="comment"># 箱线图</span></span><br><span class="line">.hexbin(); .hist2d() <span class="comment">#二维直方图，√大量数据的相关性展示可用</span></span><br><span class="line">.stackplot() <span class="comment">#堆积柱状图</span></span><br><span class="line">.violinplot() <span class="comment">#小提琴图</span></span><br><span class="line">.imshow() <span class="comment">#绘制图片，二维矩阵栅格</span></span><br><span class="line"><span class="comment"># ...接口很多，还可以绘制洋流图、等高线、频谱图等</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制x y辅助线</span></span><br><span class="line">.vlines() <span class="comment">#竖线</span></span><br><span class="line">.hlines() <span class="comment">#横线</span></span><br><span class="line"><span class="comment"># 水平填充、垂直填充、任意填充</span></span><br><span class="line">.fill_between()</span><br><span class="line">.fill_betweenx()</span><br><span class="line">.fill()</span><br></pre></td></tr></table></figure>
<p>添加注释</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">.annotate() <span class="comment">#添加注释</span></span><br><span class="line">.text() <span class="comment">#添加注释</span></span><br><span class="line">.secondary_xaxis() <span class="comment">#添加水平轴；可以实现上下双刻度线，具体见文档</span></span><br><span class="line">.secondary_yaxis() <span class="comment">#添加垂直边；可以实现左右双刻度线</span></span><br><span class="line">.arrow() <span class="comment">#添加箭头</span></span><br><span class="line">.inset_axes() <span class="comment">#添加注释，插入子图</span></span><br><span class="line">.table() <span class="comment">#添加注释</span></span><br></pre></td></tr></table></figure>
<p>要素属性设置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">.set_xlim(); .get_xlim()<span class="comment"># 设置显示的范围，有set一般都有get</span></span><br><span class="line">.set_ylim()</span><br><span class="line">.set_xbound(); .set_ybound()<span class="comment"># 设置上下界</span></span><br><span class="line">.set_xlabel();.set_ylabel() <span class="comment">#设置标签</span></span><br><span class="line"></span><br><span class="line">.set_title() <span class="comment">#设置标题</span></span><br><span class="line">.set_xticks(); y... <span class="comment">#设置刻度值</span></span><br><span class="line">.set_xticklabels() <span class="comment">#设置刻度标签</span></span><br><span class="line">.minorticks_off(); .minorticks_on() <span class="comment">#次刻度的显示设置</span></span><br><span class="line">.ticklabel_format() <span class="comment">#格式化labels，如可以设置科学计数法显示</span></span><br><span class="line">.tick_params() <span class="comment"># 各种参数包括网格线等的设置</span></span><br><span class="line">.locator_params() <span class="comment">#设置主刻度线，高级自定义</span></span><br><span class="line">.set_position() <span class="comment">#设置图像在图中的位置，比如可以设置绘图左下角起点</span></span><br><span class="line"></span><br><span class="line">.set_xscale() <span class="comment">#设置刻度变换</span></span><br><span class="line">.set_yscale()</span><br><span class="line">.set_xmargin() <span class="comment">#设置绘制图形距离边/spines的距离,变相裁剪</span></span><br><span class="line">.set_ymargin() </span><br><span class="line">.set_aspect() <span class="comment">#设置轴缩放的横纵比</span></span><br><span class="line"></span><br><span class="line">.legend() <span class="comment">#设置图例</span></span><br><span class="line">h, l = ax.get_legend_handles_labels() <span class="comment">#获取图例句柄及标签</span></span><br><span class="line">.invert_xaxis();.invert_yaxis() <span class="comment">#设置轴的增大方向</span></span><br></pre></td></tr></table></figure>
<p>外观开关设置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 隐藏</span></span><br><span class="line">.set_axis_off()</span><br><span class="line">.set_axis_on()</span><br><span class="line">.grid()</span><br><span class="line">.get_facecolor()</span><br><span class="line">.set_facecolor()</span><br><span class="line">.get_xaxis() <span class="comment">#获取XAxis实例</span></span><br><span class="line">.get_yaxis()</span><br><span class="line"><span class="comment"># 隐藏轴及标签</span></span><br><span class="line">ax.get_xaxis().set_visible(<span class="literal">False</span>)</span><br><span class="line">ax.get_yaxis().set_visible(<span class="literal">False</span>)</span><br><span class="line">ax.get_xaxis().set_ticks([])</span><br><span class="line">ax.get_yaxis().set_ticks([])</span><br><span class="line">ax.xaxis.set_ticklabels([])</span><br><span class="line">ax.yaxis.set_ticklabels([])</span><br></pre></td></tr></table></figure>
<p>元素添加及参考系变换等，我们可以自行创建任意的图像然后添加到axes中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">.add_artist()</span><br><span class="line">.add_child_axes()</span><br><span class="line">.add_collection()</span><br><span class="line">.add_image()</span><br><span class="line">.add_line()</span><br><span class="line">.add_patch()</span><br><span class="line">.add_table()</span><br><span class="line"><span class="comment"># 轴的标准化坐标0-1和实际坐标的变换可能用到，具体用法在另一篇展开</span></span><br><span class="line">.get_xaxis_transform</span><br><span class="line">.get_yaxis_transform</span><br></pre></td></tr></table></figure>
<h3 id="spines-边框"><a class="markdownIt-Anchor" href="#spines-边框"></a> Spines-边框</h3>
<blockquote>
<p><code>class matplotlib.spines.Spine</code>，<a href="https://matplotlib.org/stable/api/spines_api.html">类的属性及方法</a></p>
</blockquote>
<p>属性设置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#获取和设置显示/隐藏边框</span></span><br><span class="line">ax.spines[<span class="string">&#x27;top&#x27;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line">ax.spines.top.set_visible(<span class="literal">False</span>)</span><br><span class="line">ax.spines[[<span class="string">&#x27;top&#x27;</span>, <span class="string">&#x27;right&#x27;</span>]].set_visible(<span class="literal">False</span>)</span><br><span class="line">ax.spines[:].set_visible(<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># 其他</span></span><br><span class="line">.set_bounds(low=<span class="literal">None</span>, high=<span class="literal">None</span>)</span><br><span class="line">.set_color(c)  <span class="comment"># 设置颜色</span></span><br><span class="line">.set_position(position)<span class="comment">#常用，设置位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更改边界线的形状，实际上axes依旧是矩形</span></span><br><span class="line">.set_patch_circle() <span class="comment"># 设置为圆形</span></span><br><span class="line">set_patch_arc(center, radius, theta1, theta2)</span><br></pre></td></tr></table></figure>
<h3 id="text-文本"><a class="markdownIt-Anchor" href="#text-文本"></a> Text-文本</h3>
<blockquote>
<p><code>class matplotlib.text.Text</code>，<a href="https://matplotlib.org/stable/api/text_api.html">类的属性及方法</a></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class matplotlib.text.Text(x=0, y=0, text=&#x27;&#x27;, color=None, ...)</span><br><span class="line"># 先添加文本</span><br><span class="line">text = ax.text(s = &quot;注释&quot;,x,y,c = &#x27;r&#x27;...)# 可以通过这样的方式获取文本示例再设置属性</span><br><span class="line"># 批量设置</span><br><span class="line">.set(*, agg_filter=&lt;UNSET&gt;, alpha=&lt;UNSET&gt;, animated=&lt;UNSET&gt;,...)</span><br></pre></td></tr></table></figure>
<p>属性具体设置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">.set_text(s) <span class="comment">#设置字的内容 </span></span><br><span class="line">.set_position((x,y))<span class="comment">#设置字的位置</span></span><br><span class="line">.set_x(x)</span><br><span class="line">.set_bbox(rectprops) <span class="comment">#设置字体外边框</span></span><br><span class="line">.set_color(color); .set_c(color)</span><br><span class="line"><span class="comment"># 字体及大小</span></span><br><span class="line">.set_font(fp); .set_fontproperties()</span><br><span class="line">.set_family.(); .set_fontfamily()</span><br><span class="line">.set_fontsize(fontsize)</span><br><span class="line"><span class="comment"># 设置加粗倾斜等</span></span><br><span class="line">.set_fontstyle(fontstyle);<span class="comment">#设置斜体&#123;&#x27;normal&#x27;, &#x27;italic&#x27;, &#x27;oblique&#x27;&#125;</span></span><br><span class="line">.set_fontweight(weight) <span class="comment">#字体粗细，&#123;a numeric value in range 0-1000, &#x27;ultralight&#x27;, &#x27;light&#x27;, &#x27;normal&#x27;, &#x27;regular&#x27;, &#x27;book&#x27;, &#x27;medium&#x27;, &#x27;roman&#x27;, &#x27;semibold&#x27;, &#x27;demibold&#x27;, &#x27;demi&#x27;, &#x27;bold&#x27;, &#x27;heavy&#x27;, &#x27;extra bold&#x27;, &#x27;black&#x27;&#125;</span></span><br><span class="line"><span class="comment"># 对齐方式</span></span><br><span class="line">.set_ha(align); </span><br><span class="line">.set_horizontalalignment(align)<span class="comment"># align&#123;&#x27;center&#x27;, &#x27;right&#x27;, &#x27;left&#x27;&#125;</span></span><br><span class="line"><span class="comment"># 旋转角度</span></span><br><span class="line">.set_rotation(s) <span class="comment">#float or &#123;&#x27;vertical&#x27;, &#x27;horizontal&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 行间距，默认1.2</span></span><br><span class="line">.set_linespacing(spacing)</span><br><span class="line"><span class="comment"># 数学公式，生效的前提是未设置全局Tex,(usetex=True).</span></span><br><span class="line">.set_math_fontfamily(fontfamily)</span><br><span class="line">.set_usetex(usetex=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">.update(kwargs) <span class="comment">#dict，传入字典更新其属性</span></span><br><span class="line">.update_from(other)</span><br></pre></td></tr></table></figure>
<h2 id="后续"><a class="markdownIt-Anchor" href="#后续"></a> 后续</h2>
<blockquote>
<p>待办</p>
</blockquote>
<ol>
<li>绘图逻辑与思路</li>
<li>Matplotlib绘图初始设置模板（包含风格、字体等等的初始化）</li>
<li>Matplotlib图片输出设置，空间占用与dpi的权衡……</li>
<li>绘图布局详解及案例</li>
<li>色彩及色带详解及案例</li>
<li>时间序列刻度详解及案例</li>
<li>文本及注释详解</li>
<li>其他绘图库了解及探索</li>
<li>地图绘制……</li>
<li>……</li>
</ol>
]]></content>
      <categories>
        <category>Python可视化</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title>Pandas(1)：数据选取/条件筛选小结</title>
    <url>/posts/f9c7a8a1/</url>
    <content><![CDATA[<p>小结一下Pandas 筛选 表格数据子集的方法作为速查手册……实际中我们的处理分析及可视化往往只是数据表的一部分，因此经常需要进行：<strong>选取特定位置、特定日期、特定数值</strong>（如文本、空值）、或者<strong>满足若干组合条件的行、列</strong>等处理，这里简单汇总一下主要有以下几类：</p>
<ol>
<li>位置筛选（与表中数值无关，仅取决于行列号或行列名）</li>
<li>条件筛选（与数值相关，根据若干符合条件（特定值或范围）选取数据子集）</li>
<li>复杂条件筛选（自定义函数apply的运用），<strong>理论上基于代码我们可以实现任何想得到的处理</strong></li>
</ol>
<span id="more"></span>
<h2 id="数据预览"><a class="markdownIt-Anchor" href="#数据预览"></a> 数据预览</h2>
<blockquote>
<p>日常涉及数据类型主要有：数字、字符串、时间日期格式。</p>
</blockquote>
<p>测试数据导入及查看基本信息</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">filepath = <span class="string">&quot;F:/weibo2017/Dataset/s3_day/1/2017-01-01.csv&quot;</span></span><br><span class="line"><span class="comment"># 取前1000行测试即可</span></span><br><span class="line">df = pd.read_csv(filepath, header=<span class="number">0</span>, parse_dates=[<span class="string">&#x27;PubTime&#x27;</span>, <span class="string">&#x27;date&#x27;</span>], nrows=<span class="number">1000</span>)</span><br><span class="line"><span class="comment"># 查看数据字段类型及信息</span></span><br><span class="line">df.info()</span><br><span class="line">df.columns.to_list()<span class="comment"># 导出列</span></span><br><span class="line"><span class="comment"># 预览后剔除冗余列</span></span><br><span class="line">usecols = [<span class="string">&#x27;_id&#x27;</span>,<span class="string">&#x27;Tools&#x27;</span>]</span><br><span class="line">df = df.drop(columns=usecols)</span><br><span class="line"><span class="comment"># 查看表格形状，行列数</span></span><br><span class="line">df.shape <span class="comment"># nrows = df.shape[0]</span></span><br><span class="line"><span class="comment"># 查看前几行或后几行</span></span><br><span class="line">df.head(<span class="number">7</span>)</span><br><span class="line">df.tail(<span class="number">7</span>)</span><br></pre></td></tr></table></figure>
<h2 id="位置筛选"><a class="markdownIt-Anchor" href="#位置筛选"></a> 位置筛选</h2>
<blockquote>
<p>Python默认从<code>0</code>开始索引.</p>
</blockquote>
<h3 id="行列号切片"><a class="markdownIt-Anchor" href="#行列号切片"></a> 行列号切片</h3>
<ul>
<li>
<p>切片时选取<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[a,b]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mclose">]</span></span></span></span>默认为 数学中的左闭右开<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[a,b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span>，因此总的个数为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>−</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">b-a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span></span></span></span>个</p>
</li>
<li>
<p>一般情况单列返回类型<strong>Series</strong>，多列或多行则返回<strong>DataFrame</strong></p>
</li>
<li>
<p>大多数情况，可以访问也可以修改值</p>
</li>
</ul>
<p>主要函数：<strong>df.iloc[],</strong> df.iat[], <a href="http://df.at">df.at</a>[]</p>
<p>原则：传入一个值或一个list时返回若干行；传入参数时，返回行及列的筛选</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一个参数</span></span><br><span class="line">df.iloc[<span class="number">2</span>] <span class="comment"># 以Series类型返回第二行数据</span></span><br><span class="line">df.iloc[<span class="number">1</span>:<span class="number">4</span>] <span class="comment">#返回2 3 4行</span></span><br><span class="line">df.iloc[[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>]] <span class="comment">#返回 3 5 7行</span></span><br><span class="line"><span class="comment"># 两个参数</span></span><br><span class="line">df.iloc[<span class="number">6</span>,<span class="number">4</span>] <span class="comment">#第六行第四列</span></span><br><span class="line">df.iloc[<span class="number">1</span>:<span class="number">4</span>,:] <span class="comment">#返回2 3 4行</span></span><br><span class="line">df.iloc[<span class="number">1</span>:<span class="number">4</span>, <span class="number">2</span>:<span class="number">4</span>] <span class="comment">#返回2~5行，3到5列</span></span><br><span class="line"><span class="comment"># 其他</span></span><br><span class="line">df.iat[<span class="number">4</span>,<span class="number">4</span>] <span class="comment">#访问第五行第五列的数值</span></span><br><span class="line">df.iat[<span class="number">3</span>,<span class="number">3</span>]=<span class="number">2</span> <span class="comment">#就地更改第四行第四列的数值</span></span><br><span class="line"><span class="comment"># 行列名称选取</span></span><br><span class="line">df.loc[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]] <span class="comment"># 多行，这里的1 2 3是索引的名字</span></span><br><span class="line">usecol = [<span class="string">&#x27;_id&#x27;</span>]</span><br><span class="line">usecol = [<span class="string">&#x27;_id&#x27;</span>,<span class="string">&#x27;Content&#x27;</span>]</span><br><span class="line">new_df = df[usecol] <span class="comment">#一列或多列都是返回dataframe</span></span><br><span class="line"><span class="comment">#df.at就地更改第四行&#x27;B&#x27;列的数值，4为行索引名称</span></span><br><span class="line">df.at[<span class="number">4</span>, <span class="string">&#x27;B&#x27;</span>]</span><br><span class="line">df.at[<span class="number">4</span>, <span class="string">&#x27;B&#x27;</span>] = <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>df创建列，直接df[]新建，右侧为值或者series或series的元组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;列名&#x27;</span>] = ...</span><br><span class="line">df[[<span class="string">&#x27;列1&#x27;</span>,<span class="string">&#x27;列2&#x27;</span>] = ...</span><br></pre></td></tr></table></figure>
<h2 id="条件筛选行dfloc"><a class="markdownIt-Anchor" href="#条件筛选行dfloc"></a> 条件筛选行df.loc</h2>
<blockquote>
<p>多个条件使用: 与(&amp;), 或(|), 非(!), 及取反(~)/即补集，</p>
<p>主要函数<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.loc.html">df.loc</a>，条件过多或繁琐则参考第三节apply</p>
</blockquote>
<p>条件筛选的实质是先根据条件生成一个这样的数组：[True, False, False,…]，再根据这个数组匹配</p>
<h3 id="特定值"><a class="markdownIt-Anchor" href="#特定值"></a> 特定值</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Con = df[<span class="string">&#x27;Comment&#x27;</span>].isna()</span><br><span class="line">df.fillna(-<span class="number">1</span>)</span><br><span class="line">Cond= f[<span class="string">&#x27;Comment&#x27;</span>].isnull()</span><br><span class="line">Con = df[<span class="string">&#x27;Comment&#x27;</span>].isin([a,b,c,...])</span><br><span class="line">df2 = df.loc[Con]</span><br><span class="line"><span class="comment"># 当然为了简介通常写在一起</span></span><br><span class="line">df2 = df.loc[df[<span class="string">&#x27;Comment&#x27;</span>].isna()]</span><br><span class="line">df2 = df.loc[df[<span class="string">&#x27;Comment&#x27;</span>].isin([a,b,c,...])]</span><br><span class="line">df2 = df.loc[df[<span class="string">&#x27;Comment&#x27;</span>].<span class="built_in">str</span>.contains(<span class="string">&quot;a&quot;</span>)]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="范围值"><a class="markdownIt-Anchor" href="#范围值"></a> 范围值</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Con = df[<span class="string">&#x27;hour&#x27;</span>]==<span class="number">3</span></span><br><span class="line">Con = df[<span class="string">&#x27;hour&#x27;</span>]&gt;=<span class="number">23</span></span><br><span class="line">df2 = df.loc[Con]</span><br><span class="line">df2 = df.loc[(df[<span class="string">&#x27;date&#x27;</span>]==<span class="string">&#x27;2017-01-01&#x27;</span>) &amp; (df[<span class="string">&#x27;Transfer&#x27;</span>]&gt;<span class="number">6</span>)]</span><br><span class="line"><span class="comment"># 筛选hour&lt;=3的行</span></span><br><span class="line">df2 = df.loc[~(df[<span class="string">&#x27;hour&#x27;</span>]&gt;<span class="number">3</span>)]</span><br></pre></td></tr></table></figure>
<h2 id="复杂条件筛选"><a class="markdownIt-Anchor" href="#复杂条件筛选"></a> 复杂条件筛选</h2>
<blockquote>
<p>个人建议通过类似 df.apply(lambda x: myfun(x)) 的方式实现</p>
</blockquote>
<p>即自定义一个新的函数生成新列，再筛选，如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">myfun</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">if</span> x&gt;<span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> x&gt;<span class="number">0</span>:</span><br><span class="line">        retuen <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        retuen <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>有几种形式，一种是单列输入单输出,这里的lambda x就是每一行的该列(df[col])的值</p>
<ul>
<li>df[newcol] = df[col].apply(lambda x: myfun(x))</li>
</ul>
<p>有时候需要多列参与运算，结果是返回单个值</p>
<p>如函数为myfun(x, y)，即有多个输入，这种情况x是代表一行，建议写成row,因此需要指定值</p>
<ul>
<li>df[col]  = df.apply(lambda row: myfun(row[col1],row[col2]), axis=1)</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;datetime&#x27;</span>] =  df.apply(<span class="keyword">lambda</span> row: datetime(row.year, row.month, row.day, row.hour), axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>如果输入输出都得是多列的，则需要通过zip函数拆包并新建多个列来接收，</p>
<p>举例<code>df[],df[]... = zip(*df.apply())</code>：其他情况类推</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">myfun</span>(<span class="params">x,y</span>):</span><br><span class="line">    <span class="keyword">return</span> x,y</span><br><span class="line">df[<span class="string">&#x27;x&#x27;</span>], df[<span class="string">&#x27;y&#x27;</span>] = <span class="built_in">zip</span>(*df.apply(<span class="keyword">lambda</span> row: myfun(row[<span class="string">&#x27;Co_oridinate1&#x27;</span>],row[<span class="string">&#x27;Co_oridinate2&#x27;</span>]), axis=<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p>关于更多函数的运用后续小结</p>
]]></content>
      <categories>
        <category>Pandas数据处理分析</category>
      </categories>
      <tags>
        <tag>Pandas</tag>
        <tag>表格数据筛选</tag>
      </tags>
  </entry>
  <entry>
    <title>Pandas(杂)：字符串列拆分及合并</title>
    <url>/posts/374675e0/</url>
    <content><![CDATA[<p>pandas处理表格时，<strong>字符串</strong>列的<u>拆分及合并</u>操作，类似于excel中的分列</p>
<p>1.根据分隔符将一列<strong>拆</strong>成多列;      2.将多列进行<strong>合并</strong></p>
<span id="more"></span>
<img src="/posts/374675e0/image-20220531130906473.png" class alt="image-20220531130906473">
<h2 id="分列"><a class="markdownIt-Anchor" href="#分列"></a> 分列</h2>
<blockquote>
<p>参考api介绍: <a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.str.split.html">Series.str.split()</a></p>
<p>该方法支持正则表达式</p>
</blockquote>
<p>处理高德Poi数据时发现有一列<strong>typename</strong>是这样的：</p>
<ul>
<li>汽车服务;汽车服务相关;汽车服务相关</li>
<li>生活服务;人才市场;人才市场</li>
<li>餐饮服务;中餐厅;中餐厅</li>
</ul>
<p>分别代表大中小类别，因此通过如下代码切分</p>
<ul>
<li><code>expand=True</code>表示将拆分的字符串展开为单独的列</li>
<li><code>n</code>指定拆分的分隔符个数，默认0/-1全部拆分</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 测试数据，原始df过大</span></span><br><span class="line">df_sample = df.sample(<span class="number">500</span>)</span><br><span class="line"><span class="comment"># 直接切分，预览结果发现得到五列，后两列大量为None,有的小类过细</span></span><br><span class="line">df_sample[<span class="string">&#x27;typename&#x27;</span>].<span class="built_in">str</span>.split(<span class="string">&#x27;;&#x27;</span>, expand=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 因此最终的切分代码</span></span><br><span class="line">df_sample[[<span class="string">&#x27;type1&#x27;</span>, <span class="string">&#x27;type2&#x27;</span>, <span class="string">&#x27;type3&#x27;</span>]] = df_sample[<span class="string">&#x27;typename&#x27;</span>].<span class="built_in">str</span>.split(<span class="string">&#x27;;&#x27;</span>, n=<span class="number">2</span>, expand=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<h2 id="合并"><a class="markdownIt-Anchor" href="#合并"></a> 合并</h2>
<blockquote>
<p>参考api介绍: <a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.str.cat.html">Series.str.cat()</a></p>
<p>补充的其他方法，另见<a href="https://sparkbyexamples.com/pandas/pandas-combine-two-columns-of-text-in-dataframe/">参考2</a></p>
</blockquote>
<p>确保各类为文本/字符串类型，否则先转换</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># df[&#x27;type1&#x27;] = df[&#x27;type1&#x27;].astype(str)</span></span><br><span class="line"><span class="comment"># 最直接的是字符串相加</span></span><br><span class="line">df_sample[<span class="string">&quot;typename2&quot;</span>] = df_sample[<span class="string">&#x27;type1&#x27;</span>].astype(<span class="built_in">str</span>) +<span class="string">&quot;-&quot;</span>+ df_sample[<span class="string">&quot;type2&quot;</span>]+<span class="string">&quot;-&quot;</span>+ df_sample[<span class="string">&quot;type3&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并方式2</span></span><br><span class="line">df_sample[<span class="string">&#x27;typename2&#x27;</span>] = df_sample[<span class="string">&#x27;type1&#x27;</span>].<span class="built_in">str</span>.cat(df_sample[[<span class="string">&#x27;type2&#x27;</span>, <span class="string">&#x27;type3&#x27;</span>]], sep=<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用字符串join函数</span></span><br><span class="line">df[<span class="string">&quot;typename2&quot;</span>] = df[[<span class="string">&#x27;type1&#x27;</span>, <span class="string">&#x27;type2&#x27;</span>, <span class="string">&#x27;type3&#x27;</span>]].apply(<span class="string">&quot;-&quot;</span>.join, axis=<span class="number">1</span>)</span><br><span class="line">df[<span class="string">&quot;typename2&quot;</span>] = df[[<span class="string">&#x27;type1&#x27;</span>, <span class="string">&#x27;type2&#x27;</span>, <span class="string">&#x27;type3&#x27;</span>]].agg(<span class="string">&quot;-&quot;</span>.join, axis=<span class="number">1</span>)</span><br><span class="line">df[<span class="string">&quot;typename2&quot;</span>] = df[[<span class="string">&#x27;type1&#x27;</span>, <span class="string">&#x27;type2&#x27;</span>, <span class="string">&#x27;type3&#x27;</span>]].apply(<span class="keyword">lambda</span> x: <span class="string">&quot;-&quot;</span>.join(x), axis =<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Pandas数据处理分析</category>
      </categories>
      <tags>
        <tag>Pandas</tag>
        <tag>表格分列及合并</tag>
      </tags>
  </entry>
  <entry>
    <title>论文学习(1)：Generalized Linear Mixed Models</title>
    <url>/posts/ca790165/</url>
    <content><![CDATA[<p>近期在学习广义线性混合效应模型，学习一篇好文章，谷歌学术引用8000,<u>Generalized Linear Mixed Models: A Practical Guide for Ecology and Evolution (Bolker, Benjamin M., et al. 2009)</u><a href="https://www.researchgate.net/publication/221995574_Generalized_Linear_Mixed_Models_A_Practical_Guide_for_Ecology_and_Evolution">下载</a></p>
<span id="more"></span>
<h2 id="摘要"><a class="markdownIt-Anchor" href="#摘要"></a> 摘要</h2>
<blockquote>
<p>固定效应和随机效应，可粗略将随机效应理解为分组效应。一组数据内存在组间差距，典型的比如一堆学生调查数据其中来自多个班级，这里班级即考虑为一个随机效应，因为不同班级本身存在一个<strong>偏差</strong>因此不能直接进行建模。</p>
</blockquote>
<p>大意：GLMMs在生态领域应用十分广泛，但是对于模型的使用、拟合及参数估计等还是存在一些问题，本文的工作是回顾了模型的使用，讨论了GLMM中的参数估计和模型推断，并<u>总结了一份数据分析步骤的“最佳的实践”</u>。</p>
<p>How should ecologists and evolutionary biologists <strong>analyze nonnormal data that involve random effects</strong>?<br>
Nonnormal data such as counts or proportions(因变量为包含随机效应的非正常数据比如频次，百分比等) often defy classical statistical procedures. Generalized linear mixed models (GLMMs) provide a more flexible approach for analyzing nonnormal data when random effects are present. The explosion of research on GLMMs in the last decade has generated <strong>considerable uncertainty</strong> for practitioners in ecology and evolution. Despite the availability of accurate techniques for estimating GLMM parameters in simple cases, complex GLMMs are challenging to fit and statistical inference such as hypothesis testing remains difficult. We review the use (and misuse) of GLMMs in ecology and evolution, <strong>discuss estimation and inference and summarize ‘best-practice’ data analysis procedures</strong> for scientists facing this challenge.</p>
<h2 id="内容"><a class="markdownIt-Anchor" href="#内容"></a> 内容</h2>
<blockquote>
<p>自行阅读，本文的核心内容都通过图表的形式呈现了，很友好，尤其是一开始的统计相关的一些知识总结。</p>
</blockquote>
<h3 id="概念表"><a class="markdownIt-Anchor" href="#概念表"></a> 概念表</h3>
<p>一些统计学的概念可能需要进一步学习和在实践中逐渐体会：Bayesian statistics, Bias, Block random effects, Continuous random effects, Crossed random effects, Exponential family,……</p>
<p><font color="#dd0000">统计模型的选择和处理依赖于因变量的类型</font>，关于GLM回归模型延伸一下，针对不同变量类型采取的不同变换，借用老师上课时候的一张PPT：</p>
<img src="/posts/undefined/f0.png" class>
<h3 id="模型参数估计"><a class="markdownIt-Anchor" href="#模型参数估计"></a> 模型参数估计</h3>
<blockquote>
<p>步骤及方法详情，具体可阅读论文，以下图文均来自论文</p>
</blockquote>
<img src="/posts/undefined/f1.png" class>
<img src="/posts/undefined/f2.png" class alt="image-20220820145710262">
<h3 id="模型推断方法"><a class="markdownIt-Anchor" href="#模型推断方法"></a> 模型推断方法</h3>
<p>在估计了GLMMs的参数值后，下一步是统计推断：即通过检查估计值及其置信区间、测试假设、选择最佳模型和评估模型间的拟合度差异，从数据中得出<strong>统计和生物学结论</strong>。本文讨论三种一般的推理类型：假设检验、模型比较和贝叶斯方法。</p>
<img src="/posts/undefined/f3.png" class alt="image-20220820145641791">
<h3 id="完整建模指南"><a class="markdownIt-Anchor" href="#完整建模指南"></a> 完整建模指南</h3>
<blockquote>
<p>具体情况具体分析，初步实践可以看一下这个<a href="https://ase.tufts.edu/bugs/guide/assets/mixed_model_guide.html">教程</a>，我觉得写的建模思路比较完整</p>
</blockquote>
<img src="/posts/undefined/f4.png" class alt="f4">
<h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2>
<blockquote>
<p>Bolker另一篇高引用文章(引用52498)，<a href="http://dx.doi.org/10.18637/jss.v067.i01">2015-Fitting Linear Mixed-Effects Models Using lme4</a>是R语言lme4包的介绍和模型拟合，略长，还没来及看</p>
</blockquote>
<p>Bolker, Benjamin M., et al. “Generalized linear mixed models: a practical guide for ecology and evolution.” <em>Trends in ecology &amp; evolution</em> 24.3 (2009): 127-135.</p>
<p>Bates, D., Mächler, M., Bolker, B., &amp; Walker, S. (2015). Fitting Linear Mixed-Effects Models Using lme4. <em>Journal of Statistical Software</em>, <em>67</em>(1), 1–48. <a href="https://doi.org/10.18637/jss.v067.i01">https://doi.org/10.18637/jss.v067.i01</a></p>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>论文阅读</tag>
        <tag>GLMM</tag>
        <tag>GLM</tag>
      </tags>
  </entry>
  <entry>
    <title>Python文件路径及目录批处理</title>
    <url>/posts/290b74f/</url>
    <content><![CDATA[<p>经常需要批量操作文件夹及文件路径，遂汇总一下Python操作文件夹目(foulder)及文件(file path)的函数以便速查。常用的几个内置模块：<a href="https://docs.python.org/zh-cn/3/library/os.html">os</a>、<a href="https://docs.python.org/zh-cn/3/library/glob.html">glob</a>及<a href="https://docs.python.org/zh-cn/3/library/shutil.html">shutil</a>，包括：<u>文件路径</u>的<strong>批量-读取、重命名、删除、移动</strong>以及<u>目录</u>的创建、重命名、删除、移动。结合条件判断可以实现各类操作。</p>
<span id="more"></span>
<p>导入模块，其他的内置模块还有<a href="https://docs.python.org/zh-cn/3/library/pathlib.html">pathlib</a>，<a href="https://docs.python.org/zh-tw/3/library/fnmatch.html">fnmatch</a>，可以相结合实现更多条件的操作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os, fnmatch</span><br><span class="line"><span class="keyword">from</span> glob <span class="keyword">import</span> glob</span><br><span class="line"><span class="keyword">import</span> shutil</span><br></pre></td></tr></table></figure>
<h2 id="文件目录操作dir"><a class="markdownIt-Anchor" href="#文件目录操作dir"></a> 文件目录操作(dir)</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.isdir(mydir)  <span class="comment"># True/False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.exists(mydir)  <span class="comment"># True/False</span></span><br></pre></td></tr></table></figure>
<p>创建，用于自动新建文件而非手动</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">create_dir</span>(<span class="params">cwd</span>):</span><br><span class="line">    isExists = os.path.exists(cwd)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isExists:</span><br><span class="line">        os.makedirs(cwd)</span><br><span class="line">    <span class="keyword">return</span> cwd</span><br><span class="line">outpath = create_dir(path+<span class="string">&quot;\\res&quot;</span>)</span><br><span class="line">outfile = outpath+<span class="built_in">str</span>()</span><br></pre></td></tr></table></figure>
<p>删除<code>os.rmdir(path)</code>，移动见下文，与文件相同<code>shutil.move()</code></p>
<h2 id="文件路径操作file"><a class="markdownIt-Anchor" href="#文件路径操作file"></a> 文件路径操作(file)</h2>
<p>判断是否为文件或者是否存在，结合if判断是否执行对应操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.isfile(myfile)  <span class="comment"># True/False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.exists(myfile)</span><br></pre></td></tr></table></figure>
<p>测试文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">C:\Users\huangs\Desktop\test</span><br><span class="line">│  20170101.txt</span><br><span class="line">│  20170102.txt</span><br><span class="line">│  20170103.csv</span><br><span class="line">│  tree.txt </span><br><span class="line">├─dir1</span><br><span class="line">│      20170103.txt</span><br><span class="line">│      20170104.txt   </span><br><span class="line">├─dir2</span><br><span class="line">│  ├─北京</span><br><span class="line">│  │      北京.csv</span><br><span class="line">│  │      </span><br><span class="line">│  └─江西</span><br><span class="line">│          上饶.csv</span><br><span class="line">│          九江.csv</span><br><span class="line">│          南昌.csv</span><br><span class="line">...</span><br><span class="line">│          </span><br><span class="line">└─dir3</span><br></pre></td></tr></table></figure>
<h3 id="读取文件"><a class="markdownIt-Anchor" href="#读取文件"></a> 读取文件</h3>
<ul>
<li><code>os.listdir()</code>读取路径下所有的文件和目录，不带根目录；</li>
<li><code>glob.glob()</code>则输出绝对路径，并且可以指定后缀</li>
<li><code>os.path.split(path)</code>，<code>os.path.basename()</code>及<code>os.path.splitext()</code>获取文件名及后缀等</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">path = <span class="string">r&quot;C:\Users\huangs\Desktop\test&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.listdir(path)</span><br><span class="line">[<span class="string">&#x27;20170101.txt&#x27;</span>,<span class="string">&#x27;20170102.txt&#x27;</span>,<span class="string">&#x27;20170103.csv&#x27;</span>, <span class="string">&#x27;dir1&#x27;</span>,<span class="string">&#x27;dir2&#x27;</span>, <span class="string">&#x27;dir3&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>files = [os.path.join(path,file) <span class="keyword">for</span> file <span class="keyword">in</span> os.listdir(path)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>files</span><br><span class="line">[<span class="string">&#x27;C:\\Users\\huangs\\Desktop\\test\\20170101.txt&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;C:\\Users\\huangs\\Desktop\\test\\20170102.txt&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;C:\\Users\\huangs\\Desktop\\test\\20170103.csv&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;C:\\Users\\huangs\\Desktop\\test\\dir1&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;C:\\Users\\huangs\\Desktop\\test\\dir2&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;C:\\Users\\huangs\\Desktop\\test\\dir3&#x27;</span>]</span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>glob(path+<span class="string">&quot;/*&quot;</span>)</span><br><span class="line">[<span class="string">&#x27;C:\\Users\\huangs\\Desktop\\test\\20170101.txt&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;C:\\Users\\huangs\\Desktop\\test\\20170102.txt&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;C:\\Users\\huangs\\Desktop\\test\\20170103.csv&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;C:\\Users\\huangs\\Desktop\\test\\dir1&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;C:\\Users\\huangs\\Desktop\\test\\dir2&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;C:\\Users\\huangs\\Desktop\\test\\dir3&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[file <span class="keyword">for</span> file <span class="keyword">in</span> glob(path+<span class="string">&quot;/*&quot;</span>) <span class="keyword">if</span> os.path.isfile(file)]</span><br><span class="line">[<span class="string">&#x27;C:\\Users\\huangs\\Desktop\\test\\20170101.txt&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;C:\\Users\\huangs\\Desktop\\test\\20170102.txt&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;C:\\Users\\huangs\\Desktop\\test\\20170103.csv&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>glob(path+<span class="string">&quot;/*.txt&quot;</span>)</span><br><span class="line">[<span class="string">&#x27;C:\\Users\\huangs\\Desktop\\test\\20170101.txt&#x27;</span>,<span class="string">&#x27;C:\\Users\\huangs\\Desktop\\test\\20170102.txt&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>输出指定嵌套层的文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>glob(path+<span class="string">&quot;/*/*/*.csv&quot;</span>)</span><br><span class="line">[<span class="string">&#x27;C:\\Users\\huangs\\Desktop\\test\\dir2\\北京\\北京.csv&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;C:\\Users\\huangs\\Desktop\\test\\dir2\\江西\\上饶.csv&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;C:\\Users\\huangs\\Desktop\\test\\dir2\\江西\\九江.csv&#x27;</span>, ...]</span><br></pre></td></tr></table></figure>
<p>获取文件信息等</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>file = <span class="string">r&#x27;C:\\Users\\huangs\\Desktop\\test\\dir2\\江西\\上饶.csv&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.split(file)</span><br><span class="line">(<span class="string">&#x27;C:\\\\Users\\\\huangs\\\\Desktop\\\\test\\\\dir2\\\\江西&#x27;</span>, <span class="string">&#x27;上饶.csv&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.splitext(file)[-<span class="number">1</span>]</span><br><span class="line"><span class="string">&#x27;.csv&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.basename(file)</span><br><span class="line"><span class="string">&#x27;上饶.csv&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="删改移动"><a class="markdownIt-Anchor" href="#删改移动"></a> 删改移动</h3>
<p>rename + remove</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.rename(src, dst,...)</span><br><span class="line">os.rename(filename, new_filename)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;.csv&#x27;</span> <span class="keyword">in</span> file:</span><br><span class="line">        os.remove(file)</span><br></pre></td></tr></table></figure>
<p>移动<code>shutil.move(src, dst)</code>，如将指定目录的文件移动到新目录</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">move_files</span>(<span class="params">indir, outdir</span>):</span><br><span class="line">    filenames = os.listdir(indir)</span><br><span class="line">    files = [indir+<span class="string">&quot;\\&quot;</span>+file <span class="keyword">for</span> file <span class="keyword">in</span> filenames]</span><br><span class="line">    newfiles = [outdir+<span class="string">&quot;\\&quot;</span>+file <span class="keyword">for</span> file <span class="keyword">in</span> filenames]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(files)):</span><br><span class="line">        shutil.move(files[i], newfiles[i])</span><br><span class="line">move_files(<span class="string">r&quot;C:\Users\huangs\Desktop\test\dir2&quot;</span>, <span class="string">r&quot;C:\Users\huangs\Desktop\test\dir1&quot;</span>)        </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>文件管理</tag>
        <tag>文件夹管理</tag>
      </tags>
  </entry>
  <entry>
    <title>python性能(1)：multiprocessing多进程</title>
    <url>/posts/4b434785/</url>
    <content><![CDATA[<p>这个系列放涉及Python性能相关的处理，总的来说-<font color="#dd0000">除了优化代码逻辑和数据结构，其他的就是增加计算或存储资源、时间换空间、空间换时间</font>。首先，较常用的，处理大量数据时通过多进程利用CPU的多核可以并行处理从而达到加速运算的目的，此处小结python内置模块<a href="https://docs.python.org/zh-cn/3.9/library/multiprocessing.html#">multiprecessing</a>的简单使用。</p>
<span id="more"></span>
<p>进程的知识点不少，方法也好多类，这里先放一个</p>
<h2 id="poolmap"><a class="markdownIt-Anchor" href="#poolmap"></a> Pool.map</h2>
<blockquote>
<p>目前我用的最多的简单粗暴的并行</p>
</blockquote>
<p>有大堆数据，需要进行相同的处理（函数）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> cpu_count</span><br><span class="line"><span class="built_in">print</span>(cpu_count())</span><br></pre></td></tr></table></figure>
<p>上面的函数查看电脑CPU的核数/即最大并行进程数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">file</span>):</span><br><span class="line">    <span class="comment"># 这里定义处理的函数</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># 8代表八个进程即使用8个核</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pool = Pool(<span class="number">8</span>)</span><br><span class="line">    <span class="comment"># files是一个参数列表list,[file1, file2, ...]</span></span><br><span class="line">    pool.<span class="built_in">map</span>(f, files)</span><br></pre></td></tr></table></figure>
<p>如果有多个参数，则可以将参数用元组封装传参后再拆包</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">paras</span>):</span><br><span class="line">    file, day = paras</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pool = Pool(<span class="number">8</span>)</span><br><span class="line">    paras = [(file, day) <span class="keyword">for</span> file <span class="keyword">in</span> files <span class="keyword">for</span> year <span class="keyword">in</span> days]</span><br><span class="line">    pool.<span class="built_in">map</span>(f,paras)</span><br></pre></td></tr></table></figure>
<h2 id="常用自定义函数"><a class="markdownIt-Anchor" href="#常用自定义函数"></a> 常用自定义函数</h2>
<p>常用辅助函数，很多时候需要根据处理的文件自动创建文件夹，比如：</p>
<ul>
<li>这里我经常用到的一个dataframe按列拆分并运算，然后输出的函数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">create_dir</span>(<span class="params">cwd</span>):</span><br><span class="line">    isExists = os.path.exists(cwd)</span><br><span class="line">    <span class="keyword">if</span> isExists:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        os.makedirs(cwd)</span><br><span class="line">    <span class="keyword">return</span> cwd</span><br><span class="line"><span class="comment"># 这也是很常用的一个df拆分函数</span></span><br><span class="line"><span class="keyword">for</span> year,table <span class="keyword">in</span> df.groupby(<span class="string">&#x27;year&#x27;</span>):</span><br><span class="line">    outdir = create_dir(<span class="built_in">dir</span>+<span class="string">&quot;\\&quot;</span>+<span class="built_in">str</span>(year))</span><br><span class="line">    ...</span><br><span class="line">    outfile = outdir+...+<span class="string">&quot;.csv&quot;</span></span><br><span class="line">    table.to_csv(..., encoding = <span class="string">&#x27;utf-8&#x27;</span>, index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python性能</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>multiprocessing</tag>
      </tags>
  </entry>
  <entry>
    <title>python性能(2)：大文件处理思路</title>
    <url>/posts/a8ff5b9/</url>
    <content><![CDATA[<p>本文小结一下处理大型文件的常规思路。Python借助Pandas处理表格文件很方便，但是涉及一下大的文件，比如需要处理单个**70G（笔记本内存一般16G）**的csv或者txt文件，显然不能够整个将其读取运存进行分析和运算，目前我的一般思路是<u>读取时分块，运算时并行，写出时压缩</u>。</p>
<span id="more"></span>
<h2 id="分块读取"><a class="markdownIt-Anchor" href="#分块读取"></a> 分块读取</h2>
<blockquote></blockquote>
<h2 id="并行运算"><a class="markdownIt-Anchor" href="#并行运算"></a> 并行运算</h2>
<blockquote>
<p>高效处理的一些模块和函数+Python中的多进程</p>
</blockquote>
<h2 id="写出压缩"><a class="markdownIt-Anchor" href="#写出压缩"></a> 写出压缩</h2>
<blockquote>
<p>尤其是对于中间计算过程的文件或者是仅用作备份的文件</p>
</blockquote>
]]></content>
      <categories>
        <category>Python性能</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中的时间格式(1)：详细版</title>
    <url>/posts/a0dd2ef9/</url>
    <content><![CDATA[<p>时间格式是一类较特殊也十分普遍的格式，大量数据都含有时间信息，在实际的学习中会经常接触。最近有创建、处理或转换时间序列数据的需求，因此做一个梳理并汇总以便在后续遇到相关处理时可以拿来即用，还有另一个简化的<a href="https://hscyber.github.io/posts/13994161">速查版</a>。本文主要涉及内容：</p>
<ol>
<li>python内置模块<strong>time</strong>及 <strong>datetime</strong>的时间格式及处理</li>
<li><strong>Pandas</strong>时间格式的表达及常规处理</li>
</ol>
<span id="more"></span>
<h2 id="主要参考"><a class="markdownIt-Anchor" href="#主要参考"></a> 主要参考</h2>
<blockquote>
<p>不论是Python的内置模块还是第三方提供的模块，官网的文档都是很好的学习资源，尤其是想要了解地更深的时候或者debug的时候，</p>
</blockquote>
<ul>
<li><a href="https://strftime.org/">https://strftime.org/</a></li>
</ul>
<p>Python官方文档</p>
<ul>
<li><a href="https://docs.python.org/3.9/library/index.html">python标准库</a></li>
<li><a href="https://docs.python.org/3.9/library/time.html">time模块文档</a></li>
<li><a href="https://docs.python.org/3.9/library/time.html">datetime模块文档</a></li>
</ul>
<p>NumPy</p>
<ul>
<li><a href="https://numpy.org/doc/stable/reference/arrays.datetime.html">NumPy中的日期和时间</a></li>
<li><a href="https://numpy.org/doc/stable/reference/routines.datetime.html">时间转换函数</a></li>
</ul>
<p>Pandas，pandas主要处理表格型数据，因此实际中数据以时间序列存在</p>
<ul>
<li><a href="https://pandas.pydata.org/docs/user_guide/timeseries.html">时间序列相关处理函数</a></li>
<li><a href="https://pandas.pydata.org/docs/user_guide/timedeltas.html#">时间增量/差</a></li>
</ul>
<p>涉及Python模块和类、实例、属性及方法相关相关的概念可查阅此文<a href="https://hscyber.github.io/posts/659ef075/">Python中的类</a></p>
<p>！在实际中最常用的其实一般是datetime的部分功能（如下），此文将各模块功能列出，便于检索</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="内置模块time"><a class="markdownIt-Anchor" href="#内置模块time"></a> 内置模块time</h2>
<h3 id="表达格式"><a class="markdownIt-Anchor" href="#表达格式"></a> 表达格式</h3>
<ol>
<li>
<p><strong>数字</strong> &lt;‘float’&gt;，Unix时间戳：从epoch(1970年1月1日00:00:00 UTC)经过的秒数/偏移量，如631123200000表示&quot;1990-01-01 00:00:00&quot;</p>
</li>
<li>
<p><strong>时间元组</strong> &lt; ‘time.struct_time’&gt;（实际实现，给计算机看的）包含了一个时间的完整信息</p>
<ul>
<li>time.struct_time(tm_year=2022, tm_mon=5, tm_mday=11, tm_hour=2, tm_min=53, tm_sec=2, tm_wday=2, tm_yday=131, tm_isdst=0)</li>
</ul>
</li>
<li>
<p><strong>字符串</strong> &lt;‘str’&gt;（可读性强，给人看的）：如&quot;1990-01-01 00:00:00&quot;，“2018-01-01”，&quot;1998/01/01&quot;等</p>
</li>
</ol>
<h3 id="时间获取"><a class="markdownIt-Anchor" href="#时间获取"></a> 时间获取</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># print(&quot;获取计算机当前时间时间：&#123;0&#125;,数据类型：&#123;1&#125;&quot;.format(t, type(t)))</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">t = time.time()</span><br><span class="line"><span class="comment"># 1652701116.7288237,数据类型: &lt;class &#x27;float&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line">t = time.ctime()</span><br><span class="line"><span class="comment"># Mon May 16 19:38:36 2022,数据类型：&lt;class &#x27;str&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line">t = time.gmtime()</span><br><span class="line"><span class="comment"># time.struct_time(tm_year=2022, tm_mon=5, tm_mday=16, tm_hour=11, tm_min=38, tm_sec=36, tm_wday=0, tm_yday=136, tm_isdst=0),数据类型：&lt;class &#x27;time.struct_time&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line">t = time.localtime() <span class="comment">#逆操作time.mktime()：可以将数字转换成元组</span></span><br><span class="line"><span class="comment">#同上 time.struct_time(tm..</span></span><br></pre></td></tr></table></figure>
<h3 id="单个时间转换strftimestrptime"><a class="markdownIt-Anchor" href="#单个时间转换strftimestrptime"></a> 单个时间转换(<code>strftime()+strptime()</code>)</h3>
<p>将时间元组转换为格式化字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t_struct = time.gmtime() <span class="comment">#创建时间元组</span></span><br><span class="line">t_string = time.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, t_struct)</span><br></pre></td></tr></table></figure>
<p>将字符串转换为时间元组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t_string = <span class="string">&#x27;2022-05-16 13:16:15&#x27;</span></span><br><span class="line">t_struct = time.strptime(t_string,<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>所有格式化参数可以在此页面查找<a href="https://strftime.org/">strftime()</a><br>
常用的如下（注意区分大小写）：</p>
<ul>
<li><code>%Y %m %d</code>: 2022-05-01, <code>%Y %-m %-d</code>: 2022-5-1,</li>
<li><code>%H %M %S</code>: 05:01:08, <code>%-H %-M %-S</code>: 5:1:8,</li>
<li><code>%x</code>:‘05/11/22’,</li>
<li><code>%X</code>:'‘02:49:06’,</li>
<li><code>%c</code>: ‘Wed May 11 02:49:36 2022’</li>
<li><code>%a</code>: Sun, <code>%A</code>: Sunday, <code>%W</code>:0-6,weekday</li>
<li><code>%b</code>: Jan, <code>%B</code>: January,</li>
<li>…</li>
<li><code>%z</code>: UTC offset in the form +HHMM or -HHMM.  “%z %Z”:‘+0800 中国标准时间’</li>
<li><code>%j</code>: 001, 002, …, 366,</li>
<li><code>%U</code> <code>%W</code>：周数，一年的第多少周，前者表示周日为第一天</li>
</ul>
<h3 id="其他函数"><a class="markdownIt-Anchor" href="#其他函数"></a> 其他函数</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 脚本运行时间计算</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">start_time = time.time()</span><br><span class="line">main()<span class="comment">#需要计时的代码</span></span><br><span class="line">end_time = time.time()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;脚本运行总时长:&#123;:.2f&#125; min&#x27;</span>.<span class="built_in">format</span>((end_time-start_time)/<span class="number">60</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;脚本运行总时长:&#123;:.2f&#125; h&#x27;</span>.<span class="built_in">format</span>((end_time-start_time)/<span class="number">3600</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 代码停顿3秒</span></span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="内置模块datetime"><a class="markdownIt-Anchor" href="#内置模块datetime"></a> 🔥内置模块datetime</h2>
<blockquote>
<p>time较为底层，一般用的不多，其他实际中主要用datetime<br>
datetime是基于time包开发的包，datetime可以拆解为date和time两个部分。可以将这两个分开管理(datetime.date类，datetime.time类)，也可以将两者合在一起(datetime.datetime类)，datetime包还定义了时间间隔对象(timedelta)。</p>
</blockquote>
<h3 id="子类对象"><a class="markdownIt-Anchor" href="#子类对象"></a> 子类/对象</h3>
<p>类，这些类可以直接通过&quot;属性&quot;进行实例化对象，如datetime.date(2022, 5, 20)</p>
<ul>
<li><code>datetime.time</code>：独立于任何特定日期的理想化时间，包含属性: <u>hour, minute, second</u>, microsecond 和 tzinfo。
<ul>
<li>属性的意思表明可以通过 .month .hour获取对象实例的属性值</li>
</ul>
</li>
<li><code>datetime.date</code>: 理想化的简单型日期, 属性: <u>year, month, and day</u>。</li>
<li><code>datetime.datetime</code>: 日期和时间的结合。属性：<u>year, month, day, hour, minute, second</u>, microsecond, and tzinfo.</li>
<li><code>datetime.timedelta</code>：表示两个 date 对象或 time 对象，或者 datetime 对象之间的<u>时间间隔</u>，精确到微秒。
<ul>
<li>常用于时间之间的加减等操做</li>
</ul>
</li>
<li><code>datetime.tzinfo</code>：时区信息对象</li>
<li><code>datetime.timezone</code>：表示相对于UTC的偏移量</li>
</ul>
<p>这些类创建实例的<strong>共有属性</strong></p>
<ol>
<li>不可变</li>
<li>可哈希，即可以作为字典的键key</li>
<li>支持通过pickle模块进行高效封存，惯用pickle可以为实际工作带来诸多便利，见<a href>pickle使用-待更新</a></li>
<li>支持加减法，且涉及时间间隔及时间差等可以通过<strong>timedelta</strong>进行运算</li>
</ol>
<h3 id="date常用操作"><a class="markdownIt-Anchor" href="#date常用操作"></a> date常用操作</h3>
<blockquote>
<p>time的操作与之类似</p>
</blockquote>
<h4 id="获取创建时间"><a class="markdownIt-Anchor" href="#获取创建时间"></a> 获取/创建时间</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> date, timedelta</span><br><span class="line">today = date.today() <span class="comment">#输出 datetime.date(2022, 5, 16)</span></span><br><span class="line">year, month = today.year, today.month</span><br><span class="line"></span><br><span class="line">my_birthday = date(<span class="number">1998</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">time_to_birthday = <span class="built_in">abs</span>(my_birthday - today) <span class="comment"># datetime.timedelta(days=8901)</span></span><br></pre></td></tr></table></figure>
<p>UTC时间转北京时间：<code>time_bj = time_utc+ timedelta(hours=8)</code></p>
<h4 id="日期与字符串格式的转换"><a class="markdownIt-Anchor" href="#日期与字符串格式的转换"></a> 日期与字符串格式的转换</h4>
<p>将时间date转换为格式化字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> date</span><br><span class="line">t1 = date(<span class="number">2022</span>, <span class="number">1</span>, <span class="number">1</span>) </span><br><span class="line"><span class="comment">#  ISO 8601 格式 YYYY-MM-DD</span></span><br><span class="line">t_string = date.isoformat(t1) <span class="comment">#&#x27;2022-01-01&#x27;</span></span><br></pre></td></tr></table></figure>
<p>将字符串转换为日期date</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t1 = <span class="string">&#x27;2022-01-01&#x27;</span></span><br><span class="line">t_date = date.fromisoformat(t1) <span class="comment">#输出datetime.date(2022, 1, 1)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>其他方法，时间替换<code>date.replace</code>(year=self.year, month=self.month, day=self.day)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = date(<span class="number">2022</span>, <span class="number">12</span>, <span class="number">31</span>)</span><br><span class="line"><span class="comment"># 时间替换</span></span><br><span class="line">d2 = d.replace(day=<span class="number">26</span>)</span><br><span class="line"><span class="comment">#返回一个 time.struct_time</span></span><br><span class="line">d3 = date.timetuple(d) </span><br><span class="line"><span class="comment"># 获取当前时间的字符串格式</span></span><br><span class="line">t = date.today()</span><br><span class="line">t.ctime()<span class="comment"># 等价于`time.ctime(time.mktime(d.timetuple()))`</span></span><br><span class="line"><span class="comment">#输出&#x27;Mon May 16 00:00:00 2022&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="datetime常用操作"><a class="markdownIt-Anchor" href="#datetime常用操作"></a> 🔥datetime常用操作</h3>
<p>获取/创建时间</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, date, time, timezone</span><br><span class="line">datetime.now()   </span><br><span class="line">datetime.now(timezone.utc)</span><br><span class="line"><span class="comment"># 年月日等属性获取,date()</span></span><br><span class="line">t = datetime.now()</span><br><span class="line">year,month, udate = t.year, t.month, t.date()</span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line"><span class="comment"># datetime.datetime(2022, 5, 16, 21, 10, 32, 304773)</span></span><br><span class="line"><span class="comment"># datetime.datetime(2022, 5, 16, 13, 10, 32, 306332, tzinfo=datetime.timezone.utc)</span></span><br></pre></td></tr></table></figure>
<p>时间合并</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, date, time</span><br><span class="line">d = date(<span class="number">2022</span>, <span class="number">5</span>, <span class="number">12</span>)</span><br><span class="line">t = time(<span class="number">1</span>, <span class="number">18</span>)</span><br><span class="line">dt = datetime.combine(d, t)</span><br></pre></td></tr></table></figure>
<p>时间与字符串的转换，参数与<code>time</code>模块类似</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 字符串转时间</span></span><br><span class="line">dt = datetime.strptime(<span class="string">&quot;21/11/06 16:30&quot;</span>, <span class="string">&quot;%d/%m/%y %H:%M&quot;</span>)</span><br><span class="line"><span class="comment"># 时间转字符串</span></span><br><span class="line">t_str = dt.strftime(<span class="string">&quot;%Y-%m-%d %H:%M&quot;</span>)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="pandas中的时间格式"><a class="markdownIt-Anchor" href="#pandas中的时间格式"></a> Pandas中的时间格式</h2>
<blockquote>
<p>pandas为表格，因此处理的一般为时间序列而非单个时间</p>
</blockquote>
<p>pandas中的时间格式主要为以下两类</p>
<ul>
<li>datetime (datetime64[ns])， 类比datetime</li>
<li>String/Object</li>
</ul>
<h3 id="创建序列"><a class="markdownIt-Anchor" href="#创建序列"></a> 创建序列</h3>
<blockquote>
<p>pd.date_range()</p>
</blockquote>
<ul>
<li>pandas.date_range(start=None, end=None, periods=None, freq=None, tz=None, normalize=False, name=None, …)<a href="https://pandas.pydata.org/docs/reference/api/pandas.date_range.html">文档</a></li>
<li>参数说明
<ul>
<li><code>start end</code>:起始日期</li>
<li><code>periods</code>:日期数量</li>
<li><code>freq</code>: 间隔，默认<code>D</code>,可以设<code>M</code>,<code>8H</code><a href="https://pandas.pydata.org/docs/user_guide/timeseries.html#timeseries-offset-aliases">详见</a></li>
<li><code>inclusive</code>：=‘both’,‘left’,‘right’，'neither’指定左右是否闭合，如生成某月份数据但不知道该月多少天，可以指定为left，右边写下月第一天</li>
</ul>
</li>
</ul>
<p>常用代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建序列， 可以直接接收</span></span><br><span class="line"><span class="comment"># 默认都是ISO 8601 格式 YYYY-MM-DD, &#x27;2018-01-01 03:00:00&#x27;</span></span><br><span class="line">df[<span class="string">&#x27;time&#x27;</span>] = pd.date_range(start=<span class="string">&#x27;1/1/2018&#x27;</span>, end=<span class="string">&#x27;1/08/2018&#x27;</span>, freq=<span class="string">&#x27;D&#x27;</span>) <span class="comment">#8天</span></span><br><span class="line">pd.date_range(start=<span class="string">&#x27;1/1/2018&#x27;</span>, end=<span class="string">&#x27;1/08/2018&#x27;</span>) <span class="comment">#8天</span></span><br><span class="line">pd.date_range(start=<span class="string">&#x27;1/1/2018&#x27;</span>, periods=<span class="number">8</span>) <span class="comment">#8天</span></span><br><span class="line">pd.date_range(start=<span class="string">&#x27;1/1/2018&#x27;</span>, periods=<span class="number">8</span>, freq=<span class="string">&#x27;2M&#x27;</span>)  <span class="comment">#8天，两天之间间隔为两个月</span></span><br><span class="line">pd.date_range(start=<span class="string">&#x27;2018-01-01&#x27;</span>, end=<span class="string">&#x27;2018-02-01&#x27;</span>, freq=<span class="string">&#x27;3H&#x27;</span>)</span><br><span class="line">pd.date_range(start=<span class="string">&#x27;2017-01-01&#x27;</span>, end=<span class="string">&#x27;2017-02-01&#x27;</span>, closed=<span class="string">&#x27;left&#x27;</span>) <span class="comment">#创建指定月份的日期范围pandas&lt;1.4版本</span></span><br><span class="line">pd.date_range(start=<span class="string">&#x27;2017-01-01&#x27;</span>, end=<span class="string">&#x27;2017-02-01&#x27;</span>, inclusive=<span class="string">&#x27;left&#x27;</span>) <span class="comment">#创建指定月份的日期范围pandas&gt;1.4版本</span></span><br></pre></td></tr></table></figure>
<h3 id="时间序列格式转换"><a class="markdownIt-Anchor" href="#时间序列格式转换"></a> 🔥时间序列格式转换</h3>
<p><strong>datetime→string</strong>:<code>astype()+strftime()</code>，输入的列为datetime64[ns]类型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># astype()</span></span><br><span class="line">df[<span class="string">&#x27;time_str&#x27;</span>]=df[<span class="string">&#x27;time&#x27;</span>].astype(<span class="built_in">str</span>)</span><br><span class="line"><span class="comment"># strftime()</span></span><br><span class="line">df[<span class="string">&#x27;time_str&#x27;</span>] = df[<span class="string">&#x27;time&#x27;</span>].dt.strftime(<span class="string">&#x27;%m/%d/%Y&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>string→datetime</strong>: <code>to_datetime</code>，输入的列为String或Object类型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;time&#x27;</span>]=pd.to_datetime(df[<span class="string">&#x27;time_str&#x27;</span>].astype(<span class="built_in">str</span>), <span class="built_in">format</span>=<span class="string">&#x27;%Y/%m/%d&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="时间合并与拆分"><a class="markdownIt-Anchor" href="#时间合并与拆分"></a> 时间合并与拆分</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 合并</span></span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">&#x27;year&#x27;</span>: [<span class="number">2015</span>, <span class="number">2016</span>],<span class="string">&#x27;month&#x27;</span>: [<span class="number">2</span>, <span class="number">3</span>],<span class="string">&#x27;day&#x27;</span>: [<span class="number">4</span>, <span class="number">5</span>],<span class="string">&#x27;hour&#x27;</span>:[<span class="number">10</span>,<span class="number">20</span>]&#125;)</span><br><span class="line">df[<span class="string">&#x27;date&#x27;</span>] = pd.to_datetime(df[[<span class="string">&#x27;year&#x27;</span>,<span class="string">&#x27;month&#x27;</span>,<span class="string">&#x27;day&#x27;</span>]])</span><br><span class="line">df[<span class="string">&#x27;datetime&#x27;</span>] = pd.to_datetime(df.date) + pd.to_timedelta(df.hour, unit=<span class="string">&#x27;h&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#拆分/转换示例</span></span><br><span class="line">df[<span class="string">&#x27;day2&#x27;</span>] = df[<span class="string">&#x27;time&#x27;</span>].dt.strftime(<span class="string">&#x27;%D&#x27;</span>)</span><br><span class="line">df[<span class="string">&#x27;hour2&#x27;</span>] = df[<span class="string">&#x27;time&#x27;</span>].dt.strftime(<span class="string">&#x27;%H&#x27;</span>)</span><br><span class="line">df[<span class="string">&#x27;date2&#x27;</span>] = df[<span class="string">&#x27;time&#x27;</span>].dt.strftime(<span class="string">&#x27;%x&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="基于时间筛选数据"><a class="markdownIt-Anchor" href="#基于时间筛选数据"></a> 基于时间筛选数据</h3>
<blockquote>
<p><code>&amp;</code>与;<code>|</code>或</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># df[&#x27;time&#x27;]为时间格式：</span></span><br><span class="line">df2 = df.loc[(df.time &gt; pd.datetime(<span class="number">2017</span>,<span class="number">8</span>,<span class="number">23</span>,<span class="number">0</span>)) &amp; (df.time &lt; pd.datetime(<span class="number">2017</span>,<span class="number">8</span>,<span class="number">27</span>,<span class="number">0</span>))]</span><br><span class="line">df2 = df.loc[(df.time &lt; pd.datetime(<span class="number">2017</span>,<span class="number">8</span>,<span class="number">23</span>,<span class="number">0</span>)) | (df.time &gt; pd.datetime(<span class="number">2017</span>,<span class="number">8</span>,<span class="number">27</span>,<span class="number">0</span>))]</span><br><span class="line"><span class="comment"># df[&#x27;time&#x27;]为字符串：</span></span><br><span class="line">df2 = df.loc[(df.time &gt; <span class="string">&#x27;2017-08-20 00:00:00&#x27;</span>) &amp; (df.time &lt; <span class="string">&#x27;2017-08-26 00:00:00&#x27;</span>)]</span><br></pre></td></tr></table></figure>
<h3 id="其他操作"><a class="markdownIt-Anchor" href="#其他操作"></a> 其他操作</h3>
<blockquote>
<p>待补充<br>
……</p>
</blockquote>
<p>有了以上的基础，在实际中可以灵活按需涉及方案排列组合等实现想要的结果……</p>
]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>时间格式</tag>
        <tag>datetime</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中的时间格式(2)：速查版</title>
    <url>/posts/13994161/</url>
    <content><![CDATA[<p>前面花时间整理了一下Python中时间格式的几个基础模块的用法，主要是针对<a href="https://hscyber.github.io/posts/a0dd2ef9/">时间格式的表达及转换</a>。不过发现有些冗余不好找，因此整一个速查的版本方便自己快速<strong>复制粘贴</strong>。</p>
<span id="more"></span>
<p>一般只用<code>datetime</code>这个库即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, date, hour</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> timedelta</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br></pre></td></tr></table></figure>
<h2 id="常规时间格式处理"><a class="markdownIt-Anchor" href="#常规时间格式处理"></a> 常规时间格式处理</h2>
<p>转换，将根据字符串的模式匹配并生成时间格式</p>
<p>时间格式之后就可以按照自己的要求进行转换</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 字符串转时间</span></span><br><span class="line">dt = datetime.strptime(<span class="string">&quot;21/11/06 16:30:00&quot;</span>, <span class="string">&quot;%d/%m/%y %H:%M:%S&quot;</span>)</span><br><span class="line">dt = datetime.strptime(<span class="string">&quot;21/11/06 16&quot;</span>, <span class="string">&quot;%d/%m/%y %H&quot;</span>)</span><br><span class="line">year,month, udate = dt.year, dt.month, dt.date()</span><br><span class="line"><span class="comment"># 时间转字符串</span></span><br><span class="line">t_str = dt.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)</span><br><span class="line">t_str = dt.strftime(<span class="string">&quot;%Y-%m-%d %H&quot;</span>)</span><br><span class="line">t_str = dt.strftime(<span class="string">&quot;%Y/%m/%d&quot;</span>)</span><br><span class="line"><span class="comment"># 时间加减，如加时区</span></span><br><span class="line">time_bj = time_utc+ timedelta(hours=<span class="number">8</span>)</span><br></pre></td></tr></table></figure>
<h2 id="pandas时间序列处理"><a class="markdownIt-Anchor" href="#pandas时间序列处理"></a> pandas时间序列处理</h2>
<blockquote>
<p>建议是写出文件的时候转成字符串，在读取处理的时候则使用datetime格式便于计算和绘图等等</p>
</blockquote>
<p>时间格式转换</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入时即转换</span></span><br><span class="line">df = pd.read_csv(filepath, parse_dates=[<span class="string">&#x27;time&#x27;</span>,<span class="string">&#x27;date&#x27;</span>], encoding = <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="comment"># 如果是字符串则</span></span><br><span class="line">df[<span class="string">&#x27;time&#x27;</span>]=pd.to_datetime(df[<span class="string">&#x27;time_str&#x27;</span>].astype(<span class="built_in">str</span>), <span class="built_in">format</span>=<span class="string">&#x27;%Y/%m/%d&#x27;</span>)</span><br><span class="line"><span class="comment"># 如果是时间格式转字符串</span></span><br><span class="line"><span class="comment"># df[&#x27;time_str&#x27;]=df[&#x27;time&#x27;].astype(str)； strftime()</span></span><br><span class="line">df[<span class="string">&#x27;time_str&#x27;</span>] = df[<span class="string">&#x27;time&#x27;</span>].dt.strftime(<span class="string">&#x27;%m-%d-%Y&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>时间序列的拆分合并</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 合并</span></span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">&#x27;year&#x27;</span>: [<span class="number">2015</span>, <span class="number">2016</span>],<span class="string">&#x27;month&#x27;</span>: [<span class="number">2</span>, <span class="number">3</span>],<span class="string">&#x27;day&#x27;</span>: [<span class="number">4</span>, <span class="number">5</span>],<span class="string">&#x27;hour&#x27;</span>:[<span class="number">10</span>,<span class="number">20</span>]&#125;)</span><br><span class="line">df[<span class="string">&#x27;date&#x27;</span>] = pd.to_datetime(df[[<span class="string">&#x27;year&#x27;</span>,<span class="string">&#x27;month&#x27;</span>,<span class="string">&#x27;day&#x27;</span>]])</span><br><span class="line">df[<span class="string">&#x27;datetime&#x27;</span>] = pd.to_datetime(df.date) + pd.to_timedelta(df.hour, unit=<span class="string">&#x27;h&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#拆分/转换示例</span></span><br><span class="line">df[<span class="string">&#x27;day2&#x27;</span>] = df[<span class="string">&#x27;time&#x27;</span>].dt.strftime(<span class="string">&#x27;%D&#x27;</span>)</span><br><span class="line">df[<span class="string">&#x27;hour2&#x27;</span>] = df[<span class="string">&#x27;time&#x27;</span>].dt.strftime(<span class="string">&#x27;%H&#x27;</span>)</span><br><span class="line">df[<span class="string">&#x27;date2&#x27;</span>] = df[<span class="string">&#x27;time&#x27;</span>].dt.strftime(<span class="string">&#x27;%x&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>时间序列范围筛选</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># df[&#x27;time&#x27;]为时间格式：</span></span><br><span class="line">df2 = df.loc[(df.time &gt; pd.datetime(<span class="number">2017</span>,<span class="number">8</span>,<span class="number">23</span>,<span class="number">5</span>)) &amp; (df.time &lt;= pd.datetime(<span class="number">2017</span>,<span class="number">8</span>,<span class="number">27</span>,<span class="number">23</span>))]</span><br><span class="line">df2 = df.loc[(df.time &lt; pd.datetime(<span class="number">2017</span>,<span class="number">8</span>,<span class="number">23</span>,<span class="number">6</span>)) | (df.time &gt; pd.datetime(<span class="number">2017</span>,<span class="number">8</span>,<span class="number">27</span>,<span class="number">0</span>))]</span><br><span class="line"><span class="comment"># df[&#x27;time&#x27;]为字符串：</span></span><br><span class="line">df2 = df.loc[(df.time &gt; <span class="string">&#x27;2017-08-20 00:00:00&#x27;</span>) &amp; (df.time &lt; <span class="string">&#x27;2017-08-26 00:00:00&#x27;</span>)]</span><br></pre></td></tr></table></figure>
<p><a href="https://pandas.pydata.org/docs/reference/api/pandas.date_range.html">创建序列</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建序列， 可以直接接收</span></span><br><span class="line"><span class="comment"># 默认都是ISO 8601 格式 YYYY-MM-DD, &#x27;2018-01-01 03:00:00&#x27;</span></span><br><span class="line">df[<span class="string">&#x27;time&#x27;</span>] = pd.date_range(start=<span class="string">&#x27;1/1/2018&#x27;</span>, end=<span class="string">&#x27;1/08/2018&#x27;</span>, freq=<span class="string">&#x27;D&#x27;</span>) <span class="comment">#8天</span></span><br><span class="line">pd.date_range(start=<span class="string">&#x27;1/1/2018&#x27;</span>, end=<span class="string">&#x27;1/08/2018&#x27;</span>) <span class="comment">#8天</span></span><br><span class="line">pd.date_range(start=<span class="string">&#x27;1/1/2018&#x27;</span>, periods=<span class="number">8</span>) <span class="comment">#8天</span></span><br><span class="line">pd.date_range(start=<span class="string">&#x27;1/1/2018&#x27;</span>, periods=<span class="number">8</span>, freq=<span class="string">&#x27;2M&#x27;</span>)  <span class="comment">#8天，两天之间间隔为两个月</span></span><br><span class="line">pd.date_range(start=<span class="string">&#x27;2018-01-01&#x27;</span>, end=<span class="string">&#x27;2018-02-01&#x27;</span>, freq=<span class="string">&#x27;3H&#x27;</span>)</span><br><span class="line">pd.date_range(start=<span class="string">&#x27;2017-01-01&#x27;</span>, end=<span class="string">&#x27;2018-01-01&#x27;</span>, closed=<span class="string">&#x27;left&#x27;</span>) <span class="comment">#创建指定月份的日期范围pandas&lt;1.4版本</span></span><br><span class="line">pd.date_range(start=<span class="string">&#x27;2017-01-01&#x27;</span>, end=<span class="string">&#x27;2017-02-01&#x27;</span>, inclusive=<span class="string">&#x27;left&#x27;</span>) <span class="comment">#创建指定月份的日期范围pandas&gt;1.4版本</span></span><br></pre></td></tr></table></figure>
<h2 id="计算脚本时长"><a class="markdownIt-Anchor" href="#计算脚本时长"></a> 计算脚本时长</h2>
<p>对于python <code>.py</code>脚本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">start_time = time.time()</span><br><span class="line">main()</span><br><span class="line">seconds = time.time() - start_time</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Time Taken:&#x27;</span>, time.strftime(<span class="string">&quot;%H:%M:%S&quot;</span>,time.gmtime(seconds)))</span><br></pre></td></tr></table></figure>
<p>对于jupyter notebook/lab, 运行单元格加一行，如果是vscode则不需要</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%time</span><br><span class="line">my process...</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>时间格式</tag>
        <tag>datetime</tag>
      </tags>
  </entry>
  <entry>
    <title>文献篇(1) 论文检索</title>
    <url>/posts/33f7b1b7/</url>
    <content><![CDATA[<p>背景调研和文献整理是研究开展的必要过程，通常在明确问题之后首先就要进行一个较完整的文献梳理。本文主要介绍<a href="https://scholar.google.com/">谷歌学术</a>以及<a href="https://www.connectedpapers.com/">Connected papers</a>的使用，侧重于英文文献，其他常用平台还有<a href="https://www.webofscience.com/wos/woscc/basic-search">Web Of Science</a>、<a href="https://www.cnki.net/">中国知网</a>。</p>
<span id="more"></span>
<img src="/posts/33f7b1b7/image-20220604165048854.png" class alt="image-20220604165048854">
<h2 id="google-scholar"><a class="markdownIt-Anchor" href="#google-scholar"></a> Google Scholar</h2>
<blockquote>
<p><a href="https://scholar.google.com/">谷歌学术网址</a>，<strong>Stand on the shoulders of giants</strong></p>
<p>此平台也是一个很好的<strong>跟踪学者研究成果</strong>的平台</p>
</blockquote>
<h3 id="类型及时间筛选"><a class="markdownIt-Anchor" href="#类型及时间筛选"></a> 类型及时间筛选</h3>
<p>左侧设置搜索选项：</p>
<ul>
<li>
<p><strong>类型</strong>可以选择<strong>综述</strong>(review)或所有类型的文章（在论文投稿时会注明文章类型，其中包括review，因此平台可以识别）</p>
</li>
<li>
<p><strong>时间</strong>通常不受限，尤其是梳理研究历史和重要的文章的时候，也常设置近五年、三年或者近一年以追踪最近的成果进展</p>
</li>
</ul>
<h3 id="内容筛选"><a class="markdownIt-Anchor" href="#内容筛选"></a> 内容筛选</h3>
<p>逻辑符(大写)：<strong>AND  OR</strong>，常见论文搜索/组合方式（<strong>冒号后无空格</strong>）：</p>
<ul>
<li>关键词检索：typhoon resilience 或 typhoon+resilience 等价于typhoon AND resilience</li>
<li>短语关键词检索：“social resilience”</li>
<li>搜索标题：intitle
<ul>
<li>intitle:(resilience typhoon)</li>
<li>intitle:((typhoon OR hurricane) AND (resilience))</li>
</ul>
</li>
<li>搜索作者：author:(“San Zhang” OR “Si Li”)</li>
<li>搜索期刊文献：“social resilience” <u>source</u>:“International Journal of Geographical Information Science”</li>
</ul>
<p>**我最常用的是标题检索，如：intitle:((typhoon OR hurricane) AND (resilience) AND “social media”)。**想要更加广泛一点或者词组不一定包含在标题中时，则建议直接关键词组合，这样会默认检索论文全文信息。</p>
<h2 id="connected-papers"><a class="markdownIt-Anchor" href="#connected-papers"></a> Connected papers</h2>
<blockquote>
<p><a href="https://www.connectedpapers.com/">Find and explore academic papers</a>一个论文检索及管理、可视化梳理的平台</p>
<p>我通常用来找一个具体研究方向上<strong>被引量高</strong>的一些较为重要的文章</p>
</blockquote>
<img src="/posts/33f7b1b7/image-20220604170812558.png" class alt="image-20220604170812558">
<h3 id="作者的初衷"><a class="markdownIt-Anchor" href="#作者的初衷"></a> 作者的初衷</h3>
<p>多年来，我们一直感到学术文献回顾和探索的痛苦，并且一直在思考如何解决它。很多时候，我们找到了一篇有趣的论文，并且我们希望：<u>1. 查找针对同一主题的不同方法和方法；2. 追踪该领域的最新研究状况；3. 确定开创性作品和背景知识；4.探索并沉浸在主题中，并了解论文中的趋势和动态。</u>因此开发了这个平台</p>
<h3 id="怎么阅读"><a class="markdownIt-Anchor" href="#怎么阅读"></a> 怎么阅读</h3>
<p>布局显示</p>
<ul>
<li>相似的论文聚集在一起，并通过更强的线条（边缘）相连，<strong>线的颜色越深，联系越强</strong>，研究延续性越强。</li>
<li>指标刻画，<strong>论文被引越多，圆圈越大</strong>;论文越新，颜色越深。</li>
</ul>
<p><strong>List view</strong>：按时间顺序排列</p>
<p><strong>Prior and derivative works</strong></p>
<ul>
<li>开创性论文Prior</li>
<li>衍生的新方法论文/综述derivative</li>
</ul>
<p><strong>右侧可以查看论文摘要并且创建新的CP图</strong></p>
<p><strong>下载</strong>：直接下载.bib结尾的引文格式</p>
<h2 id="google"><a class="markdownIt-Anchor" href="#google"></a> Google</h2>
<blockquote>
<p><a href="https://www.google.com/">谷歌官网，需要梯子</a>，最后介绍一下搜索引擎的高级检索，百度也有类似的功能。</p>
<p><a href="http://www.googleguide.com/advanced_operators_reference.html">参考1-官方搜索运算符文档</a>，可以进行<u>标题，网址、文本、类型</u>等的检索。</p>
</blockquote>
<p>常用搜索（逻辑符(大写)：<strong>AND  OR</strong>，也可以用空格或+替换AND）</p>
<ul>
<li><strong>标题</strong>包含：intitle。如输入<u>intitle:google</u>（<strong>冒号后无空格</strong>），网页标题中带有google的网页都会被搜索出来。
<ul>
<li>还有<strong>allintitle</strong>，可以进行多个关键词的检索，包括还有allintext, allinurl，用法类似。</li>
<li>也就是说进行单个/并列关键词检索时二者检索结果均无区别，看习惯。<strong>e.g., [ intitle:google intitle:search ] is the same as [ allintitle: google search ]</strong>。</li>
</ul>
</li>
<li><strong>网址</strong>包含：inurl。搜索包含有特定字符的URL。</li>
<li><strong>网页正文</strong>包含：intext。搜索网页正文内容中的指定字符。</li>
<li><strong>文件</strong>检索：filetype。搜索指定类型的文件。例如输入<u>filetype:pdf</u>，将返回所有以pdf结尾的文件URL，这通常用于组合-即多条件检索,如 <u>inurl:google AND filetype:pdf</u>。
<ul>
<li>
<img src="/posts/33f7b1b7/image-20220527104807053.png" class alt="searchfile">
</li>
</ul>
</li>
<li><strong>相关网站</strong>检索site。找到与指定网站有联系的URL。例如输入<u>site:igsnrr.cas.cn</u>。所有和这个网站有联系的URL都会被显示。</li>
<li><strong>相似网站</strong>检索：related。查询将列出与您指定的网页相似的网页，如<u>related:igsnrr.cas.cn</u>：结果中会呈现科学网、中科院心理研究所、天文台等，可自行尝试。</li>
</ul>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>谷歌学术</tag>
      </tags>
  </entry>
  <entry>
    <title>矢栅处理(1)：分区统计sjoin|zonal</title>
    <url>/posts/54103437/</url>
    <content><![CDATA[<p><strong>按照多边形</strong>（如格网/行政区划）边界<strong>汇总统计</strong>其内的<strong>点/栅格</strong>是空间分析中的常用操作（栅格实际上可以看做点数据）。</p>
<p>对于软件，如果点是矢量，则可以直接通过ArcMap/QGIS的spatial join计算，点为栅格，则称zonal statistic……实际中数据多即需要批处理，可以采用QGIS、ArcPy或者基于Python（如<a href="https://geopandas.org/en/stable/docs/reference/api/geopandas.sjoin.html">geopandas</a> <a href="https://pythonhosted.org/rasterstats/manual.html#zonal-statistics">rasterstats</a>等模块）……</p>
<span id="more"></span>
<p>具体的实现流程视数据情况而定，数据量大的时候可以考虑看能不能先<strong>分块</strong>再算或者多分几步，这里仅给出一些我的处理案例，数据量更大的可能就需要考虑进一步优化实现思路了。此外：ArcGIS的底层是32位貌似且Python还是2.7的，因此运行会更慢，当然现在慢慢迁移到ArcGIS Pro，但是Pro比较吃电脑配置<strong>很多操作我更加推荐开源的QGIS</strong>，一方面QGIS参数的控制和结果更加细致，且运行速度（Python3.6）和结果预览都更快！</p>
<h2 id="栅格矢量zonal"><a class="markdownIt-Anchor" href="#栅格矢量zonal"></a> ∑栅格×矢量zonal</h2>
<p>以统计格网(polygons)内栅格值为例：</p>
<h3 id="python"><a class="markdownIt-Anchor" href="#python"></a> Python</h3>
<ol>
<li>ArcPy，实现Zonal Statistic<a href="https://desktop.arcgis.com/en/arcmap/latest/tools/spatial-analyst-toolbox/zonal-statistics.htm">功能</a>，应该在空间分析工具下，可自行查看文档</li>
<li>一个<font color="#dd0000">专门用于做分区统计的模块</font><a href="https://pythonhosted.org/rasterstats/manual.html#zonal-statistics">rasterstats文档</a>，较<strong>推荐</strong>，这里给一个简单的个人案例，统计区划内的高程信息。经过简单测试发现时间为50秒，而在QGIS中运行耗时150秒，ArcGIS理论上更慢，说明该工具还可以（毕竟底层C++）。
<ul>
<li>传入统计的矢量数据或geometry类型+栅格图层文件路径即可，输出的是一个字典，可以直接转成df</li>
<li>也可以自定义计算函数作为统计参数stats</li>
<li>对于分类的栅格数据可以添加<code>categorical = True</code>参数</li>
</ul>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rasterstats <span class="keyword">import</span> zonal_stats</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> geopandas <span class="keyword">as</span> gpd</span><br><span class="line"><span class="comment"># 读取shape矢量文件为gpd，空间区域，也可以通过csv文件创建gpd</span></span><br><span class="line">gdf = gpd.read_file(<span class="string">&quot;./青海西藏县.shp&quot;</span>, encoding = <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">tiffile = <span class="string">&quot;A:/Data/dem.tif&quot;</span> <span class="comment">#栅格文件</span></span><br><span class="line">stats = zonal_stats(gdf,demfile,stats=[<span class="string">&#x27;min&#x27;</span>, <span class="string">&#x27;max&#x27;</span>, <span class="string">&#x27;median&#x27;</span>, <span class="string">&#x27;majority&#x27;</span>, <span class="string">&#x27;sum&#x27;</span>])</span><br><span class="line">stats2 = zonal_stats(<span class="string">&quot;./青海西藏县.shp&quot;</span>,demfile,stats=<span class="string">&#x27;count&#x27;</span>)</span><br><span class="line"><span class="comment"># 统计的stats是一个字典，也可以输出geojson,参数geojson_out=True</span></span><br><span class="line"><span class="comment"># 这里我选择拼接两张表并导出统计的结果</span></span><br><span class="line">res = pd.concat([gdf, pd.DataFrame(stats)], axis=<span class="number">1</span>) <span class="comment">#geodataframe </span></span><br><span class="line"><span class="comment"># 再视情况写出即可res.to_file(...)</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>其他暂不探索</li>
</ol>
<h3 id="软件"><a class="markdownIt-Anchor" href="#软件"></a> 软件</h3>
<blockquote>
<p>之前汇总过一次全国960w格网的栅格计算，分省计算的，基于的是QGIS的批处理（通过导入参数json文件实现）/也尝试了其Python脚本发现不好用，可能是我还没上手习惯</p>
</blockquote>
<ul>
<li>
<p>ArcGIS略</p>
</li>
<li>
<p>QGIS：在工具箱搜索zonal或者分区统计即可</p>
</li>
</ul>
<img src="/posts/54103437/image-20220706222730274.png" class alt="image-20220706222730274">
<p>QGIS批处理，QGIS的脚本不如ArcPy好用，所以批处理之前是用参数导入的方式实现的，但是其参数设置还需要经过一道转换，略显麻烦，但也还行，代码见：</p>
<img src="/posts/54103437/image-20220706223030773.png" class alt="image-20220706223030773">
<p>参数设置代码参考，其要求比较严格需要标准的路径、json对象和json文件等，当时debug了好一会~，json的介绍可以我写过的<a href="https://hscyber.github.io/posts/3c868742/">这里</a>，需要设置输入文件、输出文件、栅格波段、计算方式（数量、均值等）、前缀等等</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> glob <span class="keyword">import</span> glob</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="comment"># infiles是输入的拆分好的960w格网文件</span></span><br><span class="line">inpath = <span class="string">&quot;A:/Data/ChinaGrid/grids_v1/shp&quot;</span></span><br><span class="line">infiles = glob(inpath+<span class="string">&quot;/*.shp&quot;</span>)</span><br><span class="line"><span class="comment"># 这里是为了把双反斜杠\\换成正斜杠/ </span></span><br><span class="line">infiles = [inpath+<span class="string">&quot;/&quot;</span>+os.path.basename(file) <span class="keyword">for</span> file <span class="keyword">in</span> infiles]</span><br><span class="line"><span class="comment"># 全部输出文件，视情况改，我这里因为只换了文件夹</span></span><br><span class="line">outfiles = [infile.replace(<span class="string">&#x27;v1&#x27;</span>,<span class="string">&#x27;v2&#x27;</span>) <span class="keyword">for</span> infile <span class="keyword">in</span> infiles]</span><br><span class="line">paras = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(outfiles)):</span><br><span class="line">    infile =  json.dumps(infiles[i])</span><br><span class="line">    <span class="comment"># outfile = json.dumps(outfiles[i])</span></span><br><span class="line">    <span class="comment"># 输入栅格，此处我计算的是同一个栅格，如果多个另外传参数</span></span><br><span class="line">    inraster =  json.dumps(<span class="string">&quot;A:/Data/ChinaGrid/base/china-gaia.tif&quot;</span>)</span><br><span class="line">    prefix = json.dumps(<span class="string">&#x27;imp_&#x27;</span>) <span class="comment"># 前缀</span></span><br><span class="line">    <span class="comment"># 这里搜一下qgis脚本 zonal的参数说明文档，或者先小文件跑看一下输出记录写的参数，1代表数量</span></span><br><span class="line">    statis = json.dumps([<span class="number">1</span>]) </span><br><span class="line">    para = &#123;</span><br><span class="line">        <span class="string">&quot;PARAMETERS&quot;</span>:&#123;</span><br><span class="line">            <span class="string">&quot;INPUT&quot;</span>:infile,</span><br><span class="line">            <span class="string">&quot;INPUT_RASTER&quot;</span>:inraster,</span><br><span class="line">            <span class="string">&quot;RASTER_BAND&quot;</span>:<span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">            <span class="string">&quot;COLUMN_PREFIX&quot;</span>: prefix,</span><br><span class="line">            <span class="string">&quot;STATISTICS&quot;</span>: statis&#125;,</span><br><span class="line">        <span class="string">&quot;OUTPUTS&quot;</span>: &#123;<span class="string">&quot;OUTPUT&quot;</span>: outfiles[i]&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    paras.append(para)</span><br><span class="line"><span class="built_in">print</span>(paras[<span class="number">0</span>])<span class="comment"># 预览一下</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;A:\Data\ChinaGrid\zonal_batch.json&quot;</span>,<span class="string">&#x27;w&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    json.dump(paras,f)</span><br></pre></td></tr></table></figure>
<h2 id="点矢量sjoin"><a class="markdownIt-Anchor" href="#点矢量sjoin"></a> ∑点×矢量sjoin</h2>
<p>以统计格网(polygons)内点的数量为例，比如我这里统计8w个0.05°格网内微博签到点的数量：</p>
<h3 id="软件-2"><a class="markdownIt-Anchor" href="#软件-2"></a> 软件</h3>
<ul>
<li>ArcMap：右击多边形直接join汇总点，或者通过ArcToolbox~\Analysis Tools.tbx\Overlay\Spatial Join</li>
</ul>
<img src="/posts/54103437/image-20220706220226879.png" class alt="image-20220706220226879">
<img src="/posts/54103437/image-20220706220152451.png" class alt="image-20220706220152451">
<img src="/posts/54103437/image-20220706221509848.png" class alt="image-20220706221509848">
<ul>
<li>QGIS：按位置连接，在QGIS工具箱搜索join或者连接都行，其工具检索双语支持，也可以批处理</li>
</ul>
<img src="/posts/54103437/image-20220706221352490.png" class alt="image-20220706221352490">
<h3 id="python-2"><a class="markdownIt-Anchor" href="#python-2"></a> Python</h3>
<ol>
<li>一种是基于ArcPy实现Spatial Join工具的脚本即可，查看tool help的代码即可，支持批处理，略</li>
<li>使用geopandas <a href="https://geopandas.org/en/stable/docs/reference/api/geopandas.sjoin.html">sjoin</a>，但是没法直接一步到位，以下是我的处理，先sjoin在merge，剔除无关字段</li>
</ol>
<p>我这里需要按月统计所有格网内的微博点数量，列名等参数可以自行更改，count()也可以换成求和或求值等，或者同时计算更多的类型使用pivot table，此处最后的结果是：**在原有的shapefile表上增加了12列，**每一列对应当月格网内微博点的数量</p>
<p>主要是以下几步：空间连接→计数→连接到polygon表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">table_sjoin = gpd.sjoin(points_table, polygons[[<span class="string">&#x27;gid&#x27;</span>, <span class="string">&#x27;geometry&#x27;</span>]])</span><br><span class="line">table_df = pd.DataFrame(table_sjoin.groupby(<span class="string">&#x27;gid&#x27;</span>)[<span class="string">&#x27;_id&#x27;</span>].count())</span><br><span class="line">polygons = pd.merge(left = polygons,right=table_df, on=<span class="string">&#x27;gid&#x27;</span>, how=<span class="string">&#x27;left&#x27;</span>).fillna(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>完整示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">outdir = <span class="string">r&quot;A:\my_research\dataset\wb1720\2017m&quot;</span></span><br><span class="line"><span class="comment"># grids是我的格网文件，wb2017是全年的微博</span></span><br><span class="line">polygons = grids.copy(deep=<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">for</span> month, table <span class="keyword">in</span> wb2017.groupby(<span class="string">&#x27;month&#x27;</span>):</span><br><span class="line">    outfile = outdir+<span class="string">&quot;\\m&quot;</span>+<span class="built_in">str</span>(month)+<span class="string">&quot;.shp&quot;</span></span><br><span class="line">    <span class="comment"># 按月输出微博文件，也可以忽略</span></span><br><span class="line">    table.to_file(outfile, encoding=<span class="string">&#x27;utf-8&#x27;</span>,index=<span class="literal">False</span>)</span><br><span class="line">    <span class="comment"># 统计数量，按照格网id gid。_id为微博的唯一di用于计数</span></span><br><span class="line">    <span class="comment"># 如果是某列求和则更改groupby函数及count()为其他函数即可</span></span><br><span class="line">    table_sjoin = gpd.sjoin(table, polygons[[<span class="string">&#x27;gid&#x27;</span>, <span class="string">&#x27;geometry&#x27;</span>]])</span><br><span class="line">    table_df = pd.DataFrame(table_sjoin.groupby(<span class="string">&#x27;gid&#x27;</span>)[<span class="string">&#x27;_id&#x27;</span>].count())</span><br><span class="line">    <span class="comment"># 调整列名</span></span><br><span class="line">    table_df = table_df.reset_index()</span><br><span class="line">    new_name = <span class="string">&quot;count_m&quot;</span>+<span class="built_in">str</span>(month)</span><br><span class="line">    table_df = table_df.rename(columns=&#123;<span class="string">&#x27;_id&#x27;</span>:new_name&#125;)</span><br><span class="line">    <span class="comment"># 连接表格</span></span><br><span class="line">    polygons = pd.merge(left = polygons,right=table_df, on=<span class="string">&#x27;gid&#x27;</span>, how=<span class="string">&#x27;left&#x27;</span>).fillna(<span class="number">0</span>)</span><br><span class="line">    polygons[new_name] = polygons[new_name].astype(<span class="string">&#x27;int32&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(month)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>时空数据处理分析</category>
      </categories>
      <tags>
        <tag>geopandas</tag>
        <tag>QGIS</tag>
        <tag>矢栅统计</tag>
      </tags>
  </entry>
  <entry>
    <title>数据抓取(1)：Python网络爬虫学习与参考</title>
    <url>/posts/5374e378/</url>
    <content><![CDATA[<p>爬虫类别笔记主要小结自己数据抓取的一些学习参考和经验，后续也考虑放一些自己数据抓取的案例。第一篇先记录一下自己的学习路径和一点体会。</p>
<span id="more"></span>
<h2 id="爬虫原理"><a class="markdownIt-Anchor" href="#爬虫原理"></a> 爬虫原理</h2>
<blockquote>
<p>主要针对平台提供的或网站上呈现的数据。</p>
</blockquote>
<p>爬虫是一个<strong>可以获取网页上的信息</strong>自动化脚本/程序。举例来说：我们打开任何的外部网站，在地址栏都会有一个连接(url)，这个网站打开之后就会自动加载页面，包括呈现的数据，比如打开淘宝会呈现商品，我们下拉会继续刷新网页提供新的商品信息……这个过程，回车打开网页即是对特定的url<strong>发送请求</strong>，url所有者（<strong>服务器端</strong>）收到请求后处理解析，然后<strong>发送响应内容</strong>，也就是我们看到的内容，不断下拉也会触发请求从而服务器动态给我们提供信息。这个过程就是一个数据请求的过程。写爬虫也就是通过代码（此处指Python）来实现<strong>批量多次</strong></p>
<ol>
<li>按要求发送请求</li>
<li>接收响应结果（网页信息或数据）</li>
<li>解析并将需要的信息保存到本地</li>
</ol>
<p>我们的学习主要在于学会<strong>解析网页和涉及到的常用Python库的使用</strong>。对于一般的网页可以很顺利地完成数据抓取工作，最多多花点时间。但是对于另一些平台，处于一些原因，会对数据的请求进行限制（反爬措施），如增加验证码，给内容加密，限制用户和IP访问的频率等等，所以实际数据抓取的难点在于<strong>反反爬</strong>hh，如</p>
<ol>
<li>平台数据宝贵或者涉及安全利益等等，不能免费共享</li>
<li>请求过于频繁会对平台的服务器造成较大的压力（频繁的I/O），造成额外的资源开销</li>
</ol>
<h2 id="学习参考"><a class="markdownIt-Anchor" href="#学习参考"></a> 学习参考</h2>
<blockquote>
<p>掌握了基本的网页知识和抓取工具用法之后就可以试着抓取一些数据，实践上手是学习最快的方式，尤其是被迫不得不自己动手的时候hh</p>
</blockquote>
<p>我个人学习爬虫是断断续续的，一开始主要是看的这位大佬的书籍《Python3网络爬虫开发实战》<a href="https://item.jd.com/13527222.html">jd</a>和网站<a href="https://cuiqingcai.com/">博客</a>，先是把书看了个大概，了解网页的一些基础和工具基础，再模仿着书上的案例。然后是在工作实践中组里时长有这方面的需求，自己就不得不上手写并调试（这个过程中还需要不断地翻看别人写的博客和文档），从一些最简单的网页到复杂一些的页面，慢慢熟悉基本的抓取工具和思路。</p>
<p>现在常规网站的数据抓取已经不成问题，多花点时间能搞定。但对于反爬比较厉害的网站则还不行（需要购买账号IP代理池等才能顺利抓取）。</p>
<h3 id="一些常用的参考"><a class="markdownIt-Anchor" href="#一些常用的参考"></a> 一些常用的参考</h3>
<ul>
<li>
<p>request文档：<a href="https://requests.readthedocs.io/en/latest/">requests</a></p>
</li>
<li>
<p>BeautifulSoup文档：<a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/">bs4</a></p>
</li>
<li>
<p>Selenium文档：<a href="https://selenium-python.readthedocs.io/">Selenium</a></p>
</li>
<li>
<p>Scrapy文档：<a href="https://scrapy-chs.readthedocs.io/zh_CN/0.24/intro/overview.html">Scrapy</a></p>
</li>
<li>
<p>崔庆才个人爬虫站点：<a href="https://cuiqingcai.com/">https://cuiqingcai.com/</a></p>
</li>
<li>
<p>崔书籍网页阅读版：<a href="https://github.com/Python3WebSpider/Python3WebSpider/blob/master/0-%E7%9B%AE%E5%BD%95.md">github</a>，如爬虫基本原理详细可读：<a href="https://github.com/Python3WebSpider/Python3WebSpider/blob/master/2.1-HTTP%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.md">HTTP基本原理</a>，<a href="https://github.com/Python3WebSpider/Python3WebSpider/blob/master/2.3-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.md">爬虫基本原理</a></p>
</li>
</ul>
<h2 id="补充"><a class="markdownIt-Anchor" href="#补充"></a> 补充</h2>
<p>普通网页的url提取：一些数据下载网页或者单个页面都会提供数据下载url，如果数量太大，也可以借助代码来完成(最简单的爬虫程序]),或者我们已经获取到了url，只是想批量下载并保存重命名文件，也是ok的。</p>
<ul>
<li>当然，很多时候如果是浏览器的话实际上有很多可用的插件，比如这里推荐一个我一直在用的chrome插件<a href="https://chrome.google.com/webstore/detail/simple-mass-downloader/abdkkegmcbiomijcbdaodaflgehfffed?utm_source=chrome-ntp-icon">Simple mass downloader</a>，以及这个更高级一点的免费抓取工具<a href="https://webscraper.io/">webscraper</a>，提供了<a href="https://chrome.google.com/webstore/detail/web-scraper-free-web-scra/jnhgnonknehpejjnehehllkliplmbmhn?utm_source=chrome-ntp-icon">chrome插件</a>，之前我用过，它可以同来实现多个网页的复杂的抓取，而且不需要写代码，按钮点击式</li>
</ul>
<p>API接口式抓取：比如<a href="https://lbs.amap.com/api/webservice/guide/api/newpoisearch">高德开放平台</a>提供的poi搜索，就把接口都给用户准备好了，我们只需要按流程申请key，再按照自己的需求输入参数，就可以发起请求获取poi的结果，即<strong>按要求构建url发送请求，平台服务器端会自动返给我们json数据</strong></p>
<ul>
<li>如请求的url：<a href="https://restapi.amap.com/v5/place/text?parameters">https://restapi.amap.com/v5/place/text?parameters</a></li>
<li>最终的输入实际大致会是：…place/text?key={…}&amp;types=120000&amp;…</li>
<li>然后通过代码批量自动完成该过程</li>
</ul>
]]></content>
      <categories>
        <category>Python爬虫</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>Python</tag>
        <tag>数据抓取</tag>
      </tags>
  </entry>
  <entry>
    <title>Pandas(杂)：List/pandas文本包含筛选</title>
    <url>/posts/4d972282/</url>
    <content><![CDATA[<p>处理<strong>文本或字符串</strong>数据常需要对内容进行<strong>关键词筛选</strong>，如选出表格df中包含某几个关键词的行，选出某个列表<strong>texts</strong>中所有包含某些关键词的句子<strong>keywords</strong>，或选择属于某个list的行……</p>
<span id="more"></span>
<h2 id="字符串"><a class="markdownIt-Anchor" href="#字符串"></a> 字符串</h2>
<blockquote>
<p>子串包含行筛选</p>
</blockquote>
<p>单个字符串的筛选则可以通过<code>if (substring in text)</code>进行判断</p>
<p>pandas可通过<code>df['text'].str.contains(&quot;keyword1|keyword2...&quot;)</code></p>
<p>代码举例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 表格行筛选</span></span><br><span class="line">keywords = <span class="string">&quot;天鸽|台风|hato|HATO|Hato|帕卡|Pakhar|pakhar&quot;</span></span><br><span class="line">df = df.loc[df[<span class="string">&#x27;content_cleaned&#x27;</span>].<span class="built_in">str</span>.contains(keywords)] </span><br><span class="line"><span class="comment"># 列表筛选举例，先转为列表（为了举例，实际中会采用contains()的方式）</span></span><br><span class="line">contents = df[<span class="string">&#x27;content_cleaned&#x27;</span>].to_list()</span><br><span class="line">keywords = [<span class="string">&quot;天鸽&quot;</span>,<span class="string">&quot;台风&quot;</span>,<span class="string">&quot;hato&quot;</span>,<span class="string">&quot;HATO&quot;</span>,<span class="string">&quot;Hato&quot;</span>]</span><br><span class="line">contents2 = [content <span class="keyword">for</span> content <span class="keyword">in</span> contents <span class="keyword">if</span> <span class="built_in">any</span>(w <span class="keyword">in</span> content <span class="keyword">for</span> w <span class="keyword">in</span> keywords)]</span><br></pre></td></tr></table></figure>
<p>如果是且，则改成<code>&amp;</code>;<code>all()</code></p>
<h2 id="列表包含"><a class="markdownIt-Anchor" href="#列表包含"></a> 列表包含</h2>
<p>列表推导</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">newlist = [text <span class="keyword">for</span> text <span class="keyword">in</span> texts <span class="keyword">if</span> <span class="built_in">any</span>(w <span class="keyword">in</span> text <span class="keyword">for</span> w <span class="keyword">in</span> keywords)]</span><br></pre></td></tr></table></figure>
<p>如果是列元素是否包含于<strong>list</strong>的筛选：</p>
<ul>
<li><code>df2 = df1.loc[df1['ID'].isin(keywords)]</code></li>
<li>取反则加<code>~</code>，如用户筛选：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">vipusers = [...]</span><br><span class="line">wb_vip = wb.loc[wb[<span class="string">&#x27;ID&#x27;</span>].isin(vipusers)]</span><br><span class="line"><span class="comment"># 取反则</span></span><br><span class="line">wb_vip = wb.loc[~wb[<span class="string">&#x27;ID&#x27;</span>].isin(vipusers)]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Pandas数据处理分析</category>
      </categories>
      <tags>
        <tag>Pandas</tag>
        <tag>文本筛选</tag>
      </tags>
  </entry>
  <entry>
    <title>如何快速查看或预览ipynb文件</title>
    <url>/posts/75ba419a/</url>
    <content><![CDATA[<p><code>.ipynb</code>是使用jupyter notebook/lab写代码的文件格式，最初只能在jupyter notebook中打开，不便查看，但除<a href="https://code.visualstudio.com/">vscode</a>，还可以借助一些工具/插件(<a href="https://github.com/QL-Win/QuickLook">QuickLook</a>, <a href="https://nteract.io/">nteract</a>, )<font color="#dd0000">在不打开jupyter的情况下以自带格式方便查看</font>。</p>
<span id="more"></span>
<p><strong>.ipynb</strong>后缀含义是ipython notebook, 从ipython逐渐发展起来的。这种文本与代码共存且交互式运行的模式很流行，还方便学习、共享和教学，类似的还有R中的.rmd，matlab中的.mlx。</p>
<h2 id="vscode查看及编辑"><a class="markdownIt-Anchor" href="#vscode查看及编辑"></a> vscode查看及编辑</h2>
<blockquote>
<p><a href="https://code.visualstudio.com/docs/datascience/jupyter-notebooks">具体可参考官网</a>：</p>
</blockquote>
<p>vscode十分轻巧，安装插件之后可以很方便的创建和编辑jupyter notebook文件，同时有很方便的面板视图和分屏查看等，如下是我的一个日常编辑环境距离。习惯了pycharm可能会发现vscode运行py文件不够直接，需要多几步设置</p>
<img src="/posts/75ba419a/vscode.png" class alt="vscode">
<h2 id="quicklook快速预览"><a class="markdownIt-Anchor" href="#quicklook快速预览"></a> QuickLook快速预览</h2>
<blockquote>
<p><a href="https://github.com/QL-Win/QuickLook">QuickLook</a>，一个用于window上文件快速预览的开源项目，现在也可以通过微软应用商店下载</p>
</blockquote>
<p>功能：运行后只需要按<strong>空格键</strong>就可以在<strong>不打开编辑器/app</strong>的情况下快速预览文本文件如csv txt md以及图片、压缩包、pdf等等(<a href="https://github.com/QL-Win/QuickLook/wiki/Supported-File-Types">默认支持的类型</a>)，通过下载安装<a href="https://github.com/QL-Win/QuickLook/wiki/Available-Plugins">插件</a>还可以预览office shapefile .ipynb…安装方式也很简单，下载后空格预览即执行安装。尤其查看<strong>大型的csv</strong>很方便快捷。</p>
<img src="/posts/75ba419a/csv.png" class alt="csv">
<p><strong>空格预览</strong>jupyter notebook示例：</p>
<img src="/posts/75ba419a/jupyter.png" class alt="jupyter">
<h2 id="nteract打开查看"><a class="markdownIt-Anchor" href="#nteract打开查看"></a> nteract打开查看</h2>
<p>下载软件<a href="https://nteract.io/">nteract</a>，选择打开方式即可查看</p>
<img src="/posts/75ba419a/nteract.png" class alt="nteract">
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>QuickLook</tag>
        <tag>jupyter</tag>
        <tag>VScode</tag>
        <tag>nteract</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown语法及Typora使用简介</title>
    <url>/posts/c694f527/</url>
    <content><![CDATA[<p>经常给人安利typora-markdown编辑器，遂在此放一下markdown的基本语法和typora的使用，常用的标记符号不超过十个，上手简单。</p>
<span id="more"></span>
<blockquote>
<p><a href="https://markdown.com.cn/basic-syntax/">Markdown</a>语言,使用易读易写的纯文本格式编写文档，可与HTML混编，可导出 HTML、PDF 以及本身的 .md 格式的文件。因简洁、高效、易读、易写，Markdown被大量使用，如Github、Wikipedia、简书、公众号等。</p>
</blockquote>
<p>！总之，用于书写笔记博客等均很方便，包括带公式的文档等，学习成本也很低。</p>
<h2 id="markdown语法"><a class="markdownIt-Anchor" href="#markdown语法"></a> Markdown语法</h2>
<h3 id="引入-word"><a class="markdownIt-Anchor" href="#引入-word"></a> 引入-word</h3>
<ol>
<li>确定样式：回顾一下我们用word写文档的过程，类比学习：首先新建\或使用已有的一个word模板\板式，定义好<u>文件的布局（页面尺寸、方向、分栏）、字体（中英文，大小，加粗等等）、段落（缩进，段前段后格式）、分级标题（自动编号）等</u>的样式，打开word并保存本地文件，如我本机一般会新建若干个通用/面向不同场景的文档模板(<code>.dotm</code>结尾，放在指定目录下即可，选项中可以查看并设置模板文件的默认路径。</li>
<li>创建文件并打开撰写</li>
<li>…插入图文参考等并进一步排版</li>
</ol>
<p>实际上md latex软件写文档的逻辑类似，都是定义样式→书写→渲染，最大的区别是<strong>纯文本/代码</strong>。</p>
<h3 id="md的基本使用"><a class="markdownIt-Anchor" href="#md的基本使用"></a> md的基本使用</h3>
<blockquote>
<p>实际上也可以使用文本编辑器打开word文档但是是乱码，不能识别，但是md可以</p>
</blockquote>
<p>基于一些基本的标识符撰写纯文本，然后在基于一些软件或编辑器/类比word进行样式渲染</p>
<p>主要用法举例，更多请查<a href="https://markdown.com.cn/basic-syntax/">Markdown</a>——<strong>注意空格的使用</strong>：</p>
<img src="/posts/c694f527/image-20220803224504684.png" class alt="image-20220803224504684">
<h3 id="代码及公式"><a class="markdownIt-Anchor" href="#代码及公式"></a> 代码及公式</h3>
<img src="/posts/c694f527/image-20220803225316432.png" class alt="image-20220803225316432">
<p>公式的书写和语法需要多查多熟悉，顺带推荐可以直接截图粘贴为md格式的<a href="https://mathpix.com/">Mathpix Snipping Tool</a></p>
<h3 id="md的利弊"><a class="markdownIt-Anchor" href="#md的利弊"></a> md的利弊</h3>
<p>好处</p>
<ol>
<li>熟悉了基本语法后书写快捷</li>
<li>且跨平台便于分享，且文件占用空间小，打开查看方便</li>
<li>图片与文本分离存放，以链接形式书写</li>
<li>在写代码时候可以嵌入笔记本，如Python jupyter以及R md、matlab md</li>
<li>…</li>
</ol>
<p>不便</p>
<ol>
<li>不便于进行较细致的调整</li>
<li>自定义md文件渲染的样式需要一定的学习成本（包括分级展示）</li>
<li>不足以撰写学术论文，建议使用LATEX，后续我也会更新Latex书写论文的一些笔记</li>
<li>…</li>
</ol>
<h2 id="typora使用"><a class="markdownIt-Anchor" href="#typora使用"></a> Typora使用</h2>
<blockquote>
<p>前提设置：1 在文件资源管理器处 -&gt; 查看-&gt;显示文件拓展名；2建议将md文件的默认打开方式改为typora.</p>
<p><a href="https://typora.io/">简介的软件介绍</a></p>
</blockquote>
<ul>
<li>如果不想付费永久订阅可以尝试下载旧版<a href="https://typora.io/windows/dev_release.html">&lt;1.0</a>，并在安装后设置该软件禁止使用网络</li>
<li>且markdown编辑器有挺多，可以自行尝试探索</li>
</ul>
<p><strong>md文件是纯文本文件，记事本可查看，typora等只是提供了更便捷的编辑功能以及样式功能</strong></p>
<ol>
<li>在准备用来记笔记的文件夹下新建txt并将后缀修改为<code>.md</code></li>
<li>打开软件进入偏好设置
<ol>
<li>启动选项可设置为打开指定目录</li>
<li>外观下拉可以设置主题及找新的样式</li>
<li>图片插入设置，个人需求，我的设置是
<ol>
<li>
<img src="/posts/c694f527/image-20220803225738321.png" class alt="image-20220803225738321">
</li>
</ol>
</li>
<li>导出pdf等需要下载<a href="https://pandoc.org/installing.html">pandoc</a>支持</li>
<li>
<img src="/posts/c694f527/image-20220803225709482.png" class alt="image-20220803225709482">
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Typora</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据处理相关笔记汇总】</title>
    <url>/posts/9ce60930/</url>
    <content><![CDATA[<center>持续更新...</center>
<span id="more"></span>
<h2 id="空间数据处理"><a class="markdownIt-Anchor" href="#空间数据处理"></a> 空间数据处理</h2>
<h3 id="矢量及栅格数据基础"><a class="markdownIt-Anchor" href="#矢量及栅格数据基础"></a> 矢量及栅格数据基础</h3>
<p><a href="https://hscyber.github.io/posts/54103437/">矢栅处理(1)：分区统计sjoin|zonal</a></p>
<p><a href="https://hscyber.github.io/posts/a9be2430/">矢栅处理(2)：GeoTIFF数值类型及压缩</a></p>
<p><a href="https://hscyber.github.io/posts/f61ccf5/">矢栅处理(3)：Python读写GeoTIFF</a></p>
<p><a href="https://hscyber.github.io/posts/448bb583/">矢栅处理(4)：NC文件读写</a></p>
<p><a href="https://hscyber.github.io/posts/ef2a4876/">矢栅处理(5)：R语言nc转多张Geotif</a></p>
<p><a href="https://hscyber.github.io/posts/2f2d96ec/">矢栅处理(6)：点矢量提取栅格值extract</a></p>
<p><a href="https://hscyber.github.io/posts/57d7f29/">矢栅处理(杂)：geopandas常用函数小结</a></p>
<p><a href="https://hscyber.github.io/posts/42111e30/">矢栅处理(杂)：OSM数据下载及shapefile读写</a></p>
<h3 id="pandas数据处理"><a class="markdownIt-Anchor" href="#pandas数据处理"></a> Pandas数据处理</h3>
<p><a href="https://hscyber.github.io/posts/f9c7a8a1/">Pandas(1)：数据选取/条件筛选小结</a></p>
<p><a href="https://hscyber.github.io/posts/18b022c/">Pandas(杂)：表格的各种连接方式</a></p>
<p><a href="https://hscyber.github.io/posts/4d972282/">Pandas(杂)：List/pandas文本包含筛选</a></p>
<p><a href="https://hscyber.github.io/posts/374675e0/">Pandas(杂)：字符串列拆分及合并</a></p>
<h2 id="时间序列"><a class="markdownIt-Anchor" href="#时间序列"></a> 时间序列</h2>
<h3 id="基础"><a class="markdownIt-Anchor" href="#基础"></a> 基础</h3>
<p><a href="https://hscyber.github.io/posts/6e05178d/">时间序列(1)：LOESS(STL)时间序列分解</a></p>
]]></content>
      <categories>
        <category>时空数据处理分析</category>
      </categories>
      <tags>
        <tag>GIS</tag>
      </tags>
  </entry>
  <entry>
    <title>【Python可视化相关笔记汇总】</title>
    <url>/posts/5144b1ce/</url>
    <content><![CDATA[<center>持续更新...</center>
<span id="more"></span>
<h2 id="matplotlib"><a class="markdownIt-Anchor" href="#matplotlib"></a> Matplotlib</h2>
<h3 id="基础篇"><a class="markdownIt-Anchor" href="#基础篇"></a> 基础篇</h3>
<p><a href="https://hscyber.github.io/posts/8dfff56a/">matplotlib绘图基础(1)：图的组成元素</a></p>
<p><a href="https://hscyber.github.io/posts/5524eff4/">matplotlib绘图基础(2)：绘图逻辑与输出尺寸/格式</a></p>
]]></content>
      <categories>
        <category>Python可视化</category>
      </categories>
      <tags>
        <tag>Matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title>【Python基础相关笔记汇总】</title>
    <url>/posts/feb4247b/</url>
    <content><![CDATA[<center>持续更新……Python环境及管理配置，基础模块使用等</center>
<span id="more"></span>
<h3 id="基础操作"><a class="markdownIt-Anchor" href="#基础操作"></a> 基础操作</h3>
<p><a href="https://hscyber.github.io/posts/a0dd2ef9/">Python中的时间格式(1)：详细版</a></p>
<p><a href="https://hscyber.github.io/posts/13994161/">Python中的时间格式(2)：速查版</a></p>
<p><a href="https://hscyber.github.io/posts/3c868742/">Python处理Json文件</a></p>
<p><a href="https://hscyber.github.io/posts/da405e24/">正则表达式re模块用法</a></p>
<p><a href="https://hscyber.github.io/posts/290b74f/">Python文件路径及目录批处理</a></p>
<h3 id="python环境"><a class="markdownIt-Anchor" href="#python环境"></a> Python环境</h3>
]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>订阅了Typora~</title>
    <url>/posts/34eb4d05/</url>
    <content><![CDATA[<p><a href="https://typora.io/">Topora</a>是一款简洁、优雅的markdown编辑器，加上首创的<strong>所见即所得</strong>风格，自定义主题等，我一直用来记笔记写文本，很推荐！</p>
<span id="more"></span>
<p>遗憾的是，今天下午发现typora旧的测试版已经无法打开，强制要求购买序列号。作为忠实粉的我最后尝试了一下一个翻版的开源软件<a href="https://github.com/marktext/marktext">MarkText</a>，也挺好用，能够实现一样的功能，体验上除了主题外观好像差别不大，在图片方面似乎做的更好，但我实在是习惯了Typora，所以选择了入手支持</p>
<ul>
<li>价格的话$15~￥89，支持三台设备，永久有效，可随时更换设备</li>
</ul>
<img src="/posts/34eb4d05/typora.png" class alt="激活成功">
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Typora</tag>
      </tags>
  </entry>
  <entry>
    <title>数据处理习惯及VSCode使用简介</title>
    <url>/posts/9730787a/</url>
    <content><![CDATA[<p>介绍一下Vscode Python环境配置，并小结一下自己目前<strong>基于Python的数据分析工作习惯</strong>。</p>
<p>之前的模式是基于Anaconda环境，使用Jupyter Notebook/Lab和pycharm，现在是基于Miniconda，用VSCode为主；至于涉及空间的处理，则主要是基于Python库（Gdal; geopandas…）、ArcPy以及QGIS、ArcMap等软件。</p>
<span id="more"></span>
<p>ps: QGIS在一些功能和处理速度等功能比ArcMap好用些，比如 Spatial join; Zonal statistic等，好用且速度更快，遗憾的是感觉QGIS的Python脚本功能不如ArcPy。</p>
<h2 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h2>
<blockquote>
<p>言归正传，尽管jupyter notebook/lab是广为推崇的Python数据分析利器，我也用了很长一段时间，但网页版的jupyter偶尔出bug，每次启动还需要启动浏览器，且在文件夹及数据管理等方面不太方便，在好朋友推荐下转向了支持Jupyter的开源且轻巧的vscode，上手了一段时间觉得很舒服~</p>
</blockquote>
<h2 id="vs-code的使用简介"><a class="markdownIt-Anchor" href="#vs-code的使用简介"></a> Vs Code的使用简介</h2>
<blockquote>
<p>下载链接<a href="https://code.visualstudio.com/">官网</a>，官方文档<a href="https://code.visualstudio.com/api">VSCode API</a></p>
<p>Learn:<a href="https://code.visualstudio.com/docs/datascience/jupyter-notebooks">Jupyter Notebooks in VS Code</a></p>
</blockquote>
<ol>
<li>下载软件并安装，建议勾选”将打开文件添加到右键菜单”，方便在任意文件夹右击新建脚本</li>
<li>安装插件</li>
</ol>
<h3 id="jupyter-notebook"><a class="markdownIt-Anchor" href="#jupyter-notebook"></a> jupyter notebook</h3>
<blockquote>
<p>最好是在本地预装好Miniconda 或 Anaconda，个人推荐前者</p>
</blockquote>
<h3 id="py-script"><a class="markdownIt-Anchor" href="#py-script"></a> .py script</h3>
<blockquote>
<p>运行脚本时需要配合命令行窗口~</p>
</blockquote>
<h2 id="我的工作模式"><a class="markdownIt-Anchor" href="#我的工作模式"></a> 我的工作模式</h2>
<blockquote>
<p>不论数据获取、处理还是分析，编程都只是实现任务的<strong>工具</strong>之一，所以最核心的还是目的及思路步骤。</p>
<p>好记性不如烂笔头，对我而言记录逻辑和步骤是十分重要的，这便于复用和查错。</p>
</blockquote>
<h3 id="问题思路"><a class="markdownIt-Anchor" href="#问题思路"></a> 问题思路</h3>
<p>这方面很难讲，我个人目前是习惯</p>
<ol>
<li>先捋捋问题的核心是什么，最后要得到什么样的输出和数据结果，需要兼顾的问题等等</li>
<li>然后花一段时间结合数据、经验与熟系的工具拟定初步方案（这步若卡住则需要多做功课或请教师兄师姐老师）</li>
<li>觉得想清楚了差不多了就开始动手想具体步骤，也即实现方案的具体步骤</li>
<li>开始上手，代码+软件齐上阵，过程中记录出现的问题并视情况调整</li>
<li>……</li>
</ol>
<p>如下图，这是我近期处理数据时候记录的一些笔记（基于typora），供参考，我也是最近才开始文本记录，对于一些<strong>步骤多点</strong>的任务，最好还是记录一下，当然，后续也会试情况不断调整和完善需要记录的内容，目前：</p>
<ol>
<li>输出结果，时间</li>
<li>处理思路/步骤|时间记录</li>
<li>问题记录</li>
<li>主要代码附录</li>
</ol>
<img src="/posts/9730787a/image-20220624185014513.png" class alt="image-20220624185014513">
<p>另外，实际一些<strong>小的案例</strong>，直接写在py脚本的开头简单写写就行，很多软件都有添加脚本header信息的功能，如以下案例我需要将网站抓取的原始GPS轨迹数据处理为表格，于是我的文件头是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*-coding:utf-8 -*-</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">@File    :   json2shp.py</span></span><br><span class="line"><span class="string">@Time    :   2022/04/01 19:50:21</span></span><br><span class="line"><span class="string">@Author  :   huangsh </span></span><br><span class="line"><span class="string">@Version :   1.0</span></span><br><span class="line"><span class="string">@Contact :   1126456109@qq.com</span></span><br><span class="line"><span class="string">@Desc    :   将json文件转换为geopandas csv</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">1. 导入json文件，将.json转换为csv文件，转换为列：pid,time,lng,lat,elev,speed,geometry-用wkt表示</span></span><br><span class="line"><span class="string">2. 将csv转换为line几何类型，用wkt表示</span></span><br><span class="line"><span class="string">3. 根据文件名(tid)将csv与表进行连接，得到最终的表</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">参考链接|API文档：</span></span><br><span class="line"><span class="string">1. </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> os, time, json</span><br><span class="line"><span class="keyword">from</span> multiprocessing.pool <span class="keyword">import</span> Pool</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><strong>总之</strong>，<u>在数据处理分析过程中，充分捋清并记录自己的思维逻辑和实现步骤，并记录出现得到问题，能够提高效率</u></p>
<h3 id="代码工具实现思路"><a class="markdownIt-Anchor" href="#代码工具实现思路"></a> 代码/工具实现思路</h3>
<blockquote>
<p>Python包的使用主要是依靠多看多记来熟练，此外，学会并且习惯看文档</p>
<p>通常数据量不大，不考虑效率会有很多种方法达到目的，查就好了，至于大的数据或者较慢的操作如空间处理，则需要通过多进程或者优化数据类型、代码逻辑来加速了，此处暂不展开</p>
</blockquote>
<p>在有了思路的基础上，我写代码的习惯是遵循逻辑分解，Step by Step</p>
<ul>
<li>过程中要实时记录和调整思路</li>
</ul>
<ol>
<li>
<p>然后先在IPython或者jupyter中编写并实时调试，大量的数据一般是先跑一个案例测试</p>
</li>
<li>
<p>完成调试后加循环，视情况编写函数遍历或并行，如果文件很多或很大建议循环时加try记录报错情况（避免挂着程序以为能跑一晚上结果10分钟就报错了hh）</p>
</li>
<li>
<p>最后，如果代码行数较多时或需要并行则新建‘.py’文件写一下</p>
</li>
<li>
<p>…</p>
</li>
</ol>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>VSCode</tag>
        <tag>Tools</tag>
      </tags>
  </entry>
</search>
