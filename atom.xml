<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Huangs&#39;s Notes</title>
  
  <subtitle>明天的事后天就知道了</subtitle>
  <link href="https://hscyber.github.io/atom.xml" rel="self"/>
  
  <link href="https://hscyber.github.io/"/>
  <updated>2024-01-19T12:02:19.411Z</updated>
  <id>https://hscyber.github.io/</id>
  
  <author>
    <name>huangsh</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>实验室私有云服务器(1)：初步使用及文件传输</title>
    <link href="https://hscyber.github.io/posts/43084fc1/"/>
    <id>https://hscyber.github.io/posts/43084fc1/</id>
    <published>2024-01-19T11:11:32.000Z</published>
    <updated>2024-01-19T12:02:19.411Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="1d5281e7c445ff8f67f16ffc83ce2a78fa498328ddfb0490575bdbf1fbc49dc1">105dbede25db45b7b53c9979c0915d2dcc44e47c3eae2c38c7bc0574444e4f7a75a319ac9eeb011efaf8bec65063dfe0a604271829a527fe2f81b79f22999b86a50fe360baac11a533a80b22420a0dfe8e6ed7d502da211de416433e23d2ce7bf78c2cdeb7bc52707722f3e09556322488f066ff343164d719c515fe9a6dcc002ec1c0ecd03f505e9ee016c2dbb6567697424d6df1ce67b5c200a063957034754bc6988dad22f09d784ca50a755377917908d53c25fc2497c643a4d3257f8b12f0f96fb23995ba502a8e48fa696215df66fd0fc03f6017fbd64373a8e22f2cc6f315ac0453f6ad471d05d8a3c5c293b26f263b97d29f7236fb1edfe669193a921e626e54c0bb1caad0182014a26269db0f14ec8fe694d8ed7929fa2ecf84b5019837d65d9aa315e8dd59a22fc175deb25ca11c7dd5e329fd0477cc869088fe88c04ecedecbb6b64c43b6fac1687f54522d15b29d0833d56eee091e91056a998cb850119242e2d4670644885a507a5fcab9e37736640aa4fe34ac90359e249681565815bf05efa33453e724aa5e04bc1d559c2b294b0f95cadc110ff9cdf35960d3b3e1f99ecc21d5594137751759925cfc7908c60108dc95bc59d094f7e054a6a29743d57285f1e3541f2adc7474b8232f0c06a6164e6ef7af27f695387c90a9238e3b4a66a7d16889ca150adb20870ea5cae97b30abc4568a30d92512f9ead8dfde0973de7f62767fe9cd438e7da344a1c6bfe1082ebf6ff1b523861d49f5b838a20b848e7bfd14163384dc4b6d230f7fa077be4e83747e3b9fdd1d93a3bb5530b20d06f3af8aba13736c45eb0389d199852b710ff28041d6c7dd7ac4f04dd5c39732b694e680e3808c1b9359b1705e76720ecb88bf6ea620db8c375b59775c4fd343dae3aeb1b9b70c9cbdecfd910e9ddf406ab1564ed55cb6f0f2990bf4e42d665198c2487500d8acb4412691930d4ef421f20f0c8b9dbd3a035ac9ed20742e76269f49e58764068d82e7255294c7b6f0631971b649d30138aa0c91eacf1474559df5b9b125c733f97e1b72433965c93a6c083fa89e35b0d39ba4c0b71a9dbe1cfd8a14bfd03a94cc29b1ec5e1c4037d218611fedf36a9e37b01500f92f4d917a4a49040f9c066c63e2c088b5849ad83ded65a1f16144594fe0b6f95730e6b3f8604cda66262cadf3addc9da537d453045b7eae7bacd0c7a5d7cdeec6dd2d76348daab7ae8a03de9212f838e4982c557f957be862c828d9ebefdcf9572a94679722bdc011b530310c64185d25527657c4d115f13ee3868eb3164d2195d7272177598aa109c05bbb211237053aa3e15c8d019e20224d629b24a021ee134fcdf4f182090fa62e99c5327f774a80db283a36083df23589624238e5c153ab348f310b384e5b381825d36a875ffe80b759d717ced9575260c35222d7f9726d9d1062822d1fbc83b1fba44bac40f48a4144ac0f6d3bb02504f0e8f7db3ac90c6f613a3be99530bbee941838a20e2f89a2fc6ff33934498a1014e70f98340658128a0ef597e94be7262a521e6bf249b6fa8b426f2a5ccab0e778003d331fa4a72d199e5140deb1bf713c29d5e15a34409c9eb98136a2fd36ff589b0db2c6f738267537a79b3f97b943699c17658f1ac3b6322117a7f2c4361e951852ee4c6e69b576acc7ef489c0752f1d55ecd08dc336b4bbcce926b8c15c4e0e876aa89f750189ff0ac3b8cef9938a0ab3421a82cf81956e4c7e146a8e246e5772bef8456df0558bbcab58580433056d353f0134e8838d58c83ddd6998f455cf85701575a2204aedd8e651307646a309357e1714dcd2b9eb4eb4524965162d75e8c63b8822a1f7d49a140d069bc90f44355e17839ca65fa5191868577cca8be597897d1cddd4c89613a623aa19d3841a719beb264f2de72c5bedd09a02c5caaddd7dc045687b5991f2cabc294c41ca628b3f8ef5bbf72727a903ed68198c0c77d7fd465d3ee9b44feb5edcf5b6114a8d66e8734649c08ce5d442ea41521f89e7e3b1bf84bba1f5c8168b18f217b4564079a797194b98b1f49b3f7ff58262806801ba8dfb23e54916f2d848598132bd8ed735dd4e0897844b3c1565baf4f9cf45a63d7d4410c9b2f5e4954bec126a889100b9de8422e5de7b9c60f4805149e8eb33ba25713f5c253ead31fa8fcc3a62185a529d5ad1bdfa4c24cc10943e3a69b186de71050c29750824d215dae41834decb35ee7f55df2d885a70ad893ce84f04befda08cebcdc3cecfcb8df24f428274fde0209bfb32b19ef60563c952ea965150e8e4534e172d6819616eb11a7423da93e1f0eff663dd2af1c846995a5ba5258fddf4acbce2b711c21cb5b09dde3894447c16f50ca62a0902048cef3e9d4ab42afa0e9d56ee5dba1e4dca818825796c442edc312033d379d03e82ad3027dc5c7e2a3368f7d7f7b44c20a5380b563953f896cb26f11e12bde6a7a728abac04f3acec4a5ebe4348603c8a9ca709a7873742a5dfa67eb4b07e9012083c09a1c1b2363f477812f3ef14b9a512dc789fd5dee93e314c8b9e0fac253f4cba743c7ded8801ccf2bdd1a0939f6d737551f19d336140d98487be3a4dc7c5135f85106128840cc4581edf87830f5ab6bc419e2426b43a5b28f6005e06560caf5b259624bc0ef86479d79ad1a44cc4e7487b5a9b497dca51112710015214c26260ddd07f20955ac6757417ba9b7866681a0171baed78b8afa227bb50a5d217895bf370ccbb032217616d81769c94fc8ff2496e2f66b4e6f144e4e5ae05c21482f73935a59a25f4785f7f5b5816a5fc75a2b3df17f76afeb032ff532734ea0315ba2fe2299587d139bf06c8df0775f6a624c01591cf37929b732c0d9a29562f1ab7487c7e339f702dab51d1af0cffab498919f6a3b37c47c468ab7a311639c23ce23ef34da2c9bad1764566249c738f8e52580bf49703d47ab089aa2c7800c8fb0ca99307c1d63e3095c841dcee63d3c723229463172d41a635e9df9a4c9f9ab8ef2ce84b07f6ec9180a610d230e7535ebb486d5a6aa37c05e3d82d8e71aad07fb0d1f3b39aa5a4993f3d9881e5ee417465c9f7c000d2c62ca5c0d3836cdea5836879b9d568feb2213b1de9649ea7cc625ab7f153bb86a5afc2f3ccfea8eda2f676b3f551534026c2838153ad096812cb085ac646170b7ac34aad4083f0193057f05090a1afc261026f7bc00fd5eb9f56f21c19ad9640d834a782825ee1b174a12dd300d2d55ccc1bfebbe5f6b0e252bca57c219a23147821973f73f4188305ce4d36e6382d4a08fcb0d09a4383a9af5f3e815a341a4c54ac3f94cddf1df009b9fa4a0c82df80b44bc5026cf50939b22fad10e4046f71a63ea45b38c45079444e962d430fc888bccd83454584b251168ef945261c50ba06b48537509fdb87e4fdf773bbf637815e01bc851de10cc5fa0cf6b8e351c4c6cc6c1b39f24555faf644bbbbb7b18fe78831ad1c7f7f695421872d4ffce130382d9c8b921f32ca9475ab5c0d268f52f7e7f2286328e2c8d7ea8989d8b950f2617c6f4ae9d30c452e8bd79ab75a9bbd78e190c64841f53e44c7b95b65bdf4c00d3ca151f324329dc95c8878d5d9aeb0a5f4f7ce8a9b913275f75e6b7798d30119d03d8b12e0bae7ac7db02bc828c168c3b6f79ddd10cb8d138284087498d0fffd0336945a4befedb3517facd591470a809f4929542b6fa0c0221932515f71d2274cac4f88542cdcab82b4d50f3d733195e92df06621c754d60cbb4a85d2425c5a3222b146259a8c1bfe77050a14576fbc2a683a238bf3a15f34a10279e91c5bc18c998a58ff2d14318b16e0d4ffa0ff829185383b86fb820f4992cfa7e3f62d14f01fea53dd889af148729801985de1a48cd3469ebb8b8164bbcbedfd3c77fb0a5ec414d6078206ee53b63a93c46af419a905676b11cd0bf1d2a5dab22153ec61aed5ffa97ce81068a3f7967ce2fbdfebe7db24eba5ddf1c770c5235e638271e713244166a07c860070df38c6ad86771acd2fcdebe65918643561bfef55f607e940ea2ed467bfe889de39194b15456172f59b306821e58d6b1888f3be6a439d2dd7f49d6803d92</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Here&#39;s something encrypted, password is required to continue reading.</summary>
    
    
    
    <category term="Lreis" scheme="https://hscyber.github.io/categories/Lreis/"/>
    
    
    <category term="server" scheme="https://hscyber.github.io/tags/server/"/>
    
  </entry>
  
  <entry>
    <title>python性能(4)：Pandas和Geopandas读写大文件加速</title>
    <link href="https://hscyber.github.io/posts/7188d134/"/>
    <id>https://hscyber.github.io/posts/7188d134/</id>
    <published>2023-12-24T15:23:03.000Z</published>
    <updated>2024-01-11T08:55:52.129Z</updated>
    
    <content type="html"><![CDATA[<p>在处理和分析大量大型的csv文件时（尤其是Geopandas）会遇到读写速度过慢的问题，因此一直想补充一个关于<strong>表格型文件读写</strong>步骤优化的讨论，此处对主要的结果进行了整理。</p><span id="more"></span><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><p><strong>数据的读写效率对实验的推进及迭代效率影响很大</strong>，针对大型数据已经开发了很多数据存储格式，尤其是Arrow存储的各种二进制文件如<a href="https://arrow.apache.org/docs/index.html">Apache Arrow</a>平台的ORC 和 Parquet，这些格式<strong>读写远比csv、shp格式更为高效的数据格式</strong>。但是这两种格式在软件和处理的通用性、共享协作等方面根深蒂固，依旧较为流行，因此我们需要<font color="#dd0000">根据实际的需求及情况进行选择</font>。此外，还有XML和JSON文件则广泛用于网页信息存储共享等，暂不列入本文的表格型数据讨论之内</p><p>实操建议：</p><ul><li>如果是<strong>小文件</strong>，或者需要考虑到不同用户之间的<strong>协作</strong>以及<strong>快速预览或制图</strong>等，建议用常规格式；</li><li>若涉及较大数据处理、中间过程文件以及单个数据集的处理流程等，推荐使用二进制格式如<strong>Parquet和feather格式</strong>。</li><li>只考虑速度，使用——feather，兼顾存储空间和共享——Parquet</li><li>对于Geopandas数据——<u>强烈建议使用feather</u>，中间的过程文件尤建议以Parquet&#x2F;feather文件存储【<strong>QGIS可以直接查看feather文件</strong>】。读写速度差异见下文</li><li>考虑到文件的大小，则优先使用Parquet，且使用<strong>列筛选 columns</strong>可以加速读取时间</li></ul><h2 id="pandas读写"><a href="#pandas读写" class="headerlink" title="pandas读写"></a>pandas读写</h2><p>参考：</p><ul><li>官方文档<a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#performance-considerations">参考</a>、公众号<a href="ttps://mp.weixin.qq.com/s/izqOl8bzjHqn2duVpn7mzA">尤尔小屋</a></li><li>API：<ul><li><a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_feather.html">pd.read_feather()</a>，参数——<strong>columns</strong>，<strong>use_threadsbool</strong>, 默认Ture-多线程</li><li><a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.to_feather.html">df.to_feature()</a>：参数——<strong>compression</strong>&#x3D;{“zstd”, “<strong>lz4</strong>”, “uncompressed”}, <strong>compression_level</strong>&#x3D;None, <strong>chunksize</strong>&#x3D;None…)</li><li><a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_parquet.html">read_parquet()</a>：<strong>columns</strong>, <strong>engine</strong>&#x3D;{‘auto’, ‘pyarrow’, ‘fastparquet’},<strong>filters</strong>:[[(column, op, val), …],…]，如‘[(‘adcode’,’&gt;’,410900)]等</li><li><a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.to_parquet.html">to_parquet()</a>:<strong>partition_cols</strong> 列表，按列分区，<strong>compressionstr&#x3D;{‘snappy’, ‘gzip’, ‘brotli’, ‘lz4’, ‘zstd’, None}</strong></li></ul></li></ul><p>结论：优先使用Parquet和feather，加速显著，<font color="#dd0000">此处我csv正常读写分别为2.5s和1min25s，feature则为0.7&#x2F;1.6s，Parquet为1.5&#x2F;2.1s</font>，考虑到存储空间的问题，更推荐选<strong>Parquet</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">&quot;./data/pois.csv&quot;</span>,encoding=<span class="string">&quot;utf-8&quot;</span>,sep=<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">df.info()</span><br><span class="line"></span><br><span class="line">df.to_feather(outdir+<span class="string">&quot;pois.feather&quot;</span>)</span><br><span class="line">df2 = pd.read_feather(outdir+<span class="string">&quot;pois.feather&quot;</span>)</span><br><span class="line"></span><br><span class="line">df.to_parquet(outdir+<span class="string">&quot;pois.parquet&quot;</span>,index=<span class="literal">False</span>)</span><br><span class="line">df2 = pd.read_parquet(outdir+<span class="string">&quot;pois.parquet&quot;</span>)</span><br><span class="line">df2 = pd.read_parquet(outdir+<span class="string">&quot;pois.parquet&quot;</span>,columns=[<span class="string">&#x27;adcode&#x27;</span>, <span class="string">&#x27;pname&#x27;</span>, <span class="string">&#x27;cityname&#x27;</span>],filters=[(<span class="string">&#x27;adcode&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="number">410900</span>),(<span class="string">&#x27;cityname&#x27;</span>,<span class="string">&#x27;==&#x27;</span>,<span class="string">&#x27;濮阳市&#x27;</span>)])</span><br></pre></td></tr></table></figure><img src="/posts/7188d134/image-20231224235322916.png" class title="image20231224235322916"><h2 id="Geopandas读写"><a href="#Geopandas读写" class="headerlink" title="Geopandas读写"></a>Geopandas读写</h2><blockquote><p>feather文件可以在qgis中直接打开查看</p></blockquote><p>参考：geopandas官方文档<a href="https://geopandas.org/en/stable/docs/user_guide/io.html">参考</a>，</p><ul><li><a href="https://geopandas.org/en/stable/docs/reference/api/geopandas.read_parquet.html#geopandas.read_parquet">gpd.read_parquet(): 参数</a>：columns&#x3D;None*，来自pyarrow的参数<a href="https://arrow.apache.org/docs/python/generated/pyarrow.parquet.read_table.html">read_table()</a>如filters</li><li><a href="https://geopandas.org/en/stable/docs/reference/api/geopandas.read_parquet.html#geopandas.read_parquet">gpd.read_feather(): 参数</a>：同上</li><li><a href="https://geopandas.org/en/stable/docs/reference/api/geopandas.GeoDataFrame.to_parquet.html">gpd.to_parquet(): 参数</a>：path,index,compression&#x3D;{‘snappy’, ‘gzip’, ‘brotli’, None}, schema_version&#x3D;{‘0.1.0’, ‘0.4.0’, None},来自pyarrow的参数<a href="https://arrow.apache.org/docs/python/generated/pyarrow.parquet.write_table.html#pyarrow.parquet.write_table">write_table()</a>如coerce_timestamps</li><li><a href="https://geopandas.org/en/stable/docs/reference/api/geopandas.GeoDataFrame.to_feather.html">gpd.to_feature(): 参数</a>：compression&#x3D;{‘zstd’, ‘lz4’, ‘uncompressed’},其余同上</li></ul><p>结论：优先使用feather，加速尤其显著，如果兼顾<strong>存储空间</strong>小使用Parquet（如此处<font color="#dd0000">读写一个200w行的poi shp文件分别需要4min和2min43s，改成feather是1.2s和4s，parquet则读写都是3s</font>），完整的测试结果后续有时间补充。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据测试</span></span><br><span class="line">gdf = gpd.read_file(<span class="string">&quot;./data/pois.shp&quot;</span>,encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"></span><br><span class="line">gdf.to_parquet(outdir+<span class="string">&quot;pois.parquet&quot;</span>)</span><br><span class="line">gdf2 = gpd.read_parquet(outdir+<span class="string">&quot;pois.parquet&quot;</span>)</span><br><span class="line"></span><br><span class="line">gdf.to_feather(outdir+<span class="string">&quot;pois.feather&quot;</span>)</span><br><span class="line">gdf2 = gpd.read_feather(outdir+<span class="string">&quot;pois.feather&quot;</span>)</span><br><span class="line"><span class="comment"># 只选取特定列也会显著加快速度</span></span><br><span class="line">gdf2 = gpd.read_feather(outdir+<span class="string">&quot;pois.feather&quot;</span>,columns=[<span class="string">&#x27;adname&#x27;</span>, <span class="string">&#x27;cityname&#x27;</span>,<span class="string">&#x27;geometry&#x27;</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="实验补充"><a href="#实验补充" class="headerlink" title="实验补充"></a>实验补充</h2><p>待续……</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在处理和分析大量大型的csv文件时（尤其是Geopandas）会遇到读写速度过慢的问题，因此一直想补充一个关于&lt;strong&gt;表格型文件读写&lt;/strong&gt;步骤优化的讨论，此处对主要的结果进行了整理。&lt;/p&gt;</summary>
    
    
    
    <category term="Python性能" scheme="https://hscyber.github.io/categories/Python%E6%80%A7%E8%83%BD/"/>
    
    
    <category term="Geopandas" scheme="https://hscyber.github.io/tags/Geopandas/"/>
    
    <category term="Pandas" scheme="https://hscyber.github.io/tags/Pandas/"/>
    
    <category term="大数据处理" scheme="https://hscyber.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    
    <category term="Feature" scheme="https://hscyber.github.io/tags/Feature/"/>
    
    <category term="Parquet" scheme="https://hscyber.github.io/tags/Parquet/"/>
    
  </entry>
  
  <entry>
    <title>近期生活小结 Why we need vocation?</title>
    <link href="https://hscyber.github.io/posts/ba8d790f/"/>
    <id>https://hscyber.github.io/posts/ba8d790f/</id>
    <published>2023-12-16T15:45:01.000Z</published>
    <updated>2023-12-17T12:24:46.500Z</updated>
    
    <content type="html"><![CDATA[<p>一晃已经接近年底，马上到了快要年终总结的时候……</p><span id="more"></span><blockquote><p>一晃已经接近年底，马上到了快要年终总结的时候，可我已经有很长一段时间没有写小结了，学习笔记也停了好一阵子了，趁着这周末天气恶劣不愿出门（北京当日温度-7~-15，重点是刮风），便想着收拾收拾心绪写点什么</p></blockquote><p>我们是需要假期的，不仅是缓冲消除一下工作的疲倦，丰富一下生活娱乐，在我，还有一个尤为重要的功能是定期整理生活和清理心绪里的“垃圾”。生活自然不必说，隔一段时间东西总是会越来越乱，稍花时间规整即能让心情愉悦，至于心绪，实在是每天都会有很多各种各样杂乱的情绪和未尽的思路，生活感悟糟糕情绪人际关系过错诸如此类，这时候，就需要借助一些时间静心梳理，回归澄清和平静。</p><p>今天做了不少事，除开动笔写这个文和清垃圾，也久违地和家人尤其刚上大学的弟弟聊了一下近期的生活，不赖。过去我是个很少主动联系家里的“懒人”（频率可能几个月一次），也算是某种对亲密关系的回避，问题确实不少，这一年开始正视之后有了好转，也成了父母和弟弟的某种支撑，也作为了弟弟和家里沟通的桥梁，也都很乐于和我说话谈心。一切安好。</p><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><blockquote><p>近期及后续核心内容——准备大论文的开题</p></blockquote><p>言归正传，回顾一下近期看似忙碌也漏洞百出的生活。</p><p>由于年底开题，工作的主线很明确，最近的时间也都堆在了这上面。由于在这个选题上尚未开展足够的相关工作（甚至还没看到数据e），因此时间显得有些紧凑，加上又会抽出一些时间来学习一下新的必要的东西，总是会感觉时间不够用。这样时间的流逝明明感觉很缓慢，每天都有不少收获，但是一天天接近deadline又会让人感觉挺焦灼，看来还是力有不逮。</p><p>焦灼的一个重要方面应该是论文的产出。近期也把积攒了很久的一个工作投了出去，在写cover letter的时候看到了上一次的抬头十分恍惚，距离上一次投稿已经过了刚好2年。这让我不得不反思这两年时间花在了何处，包括研究工作的停滞的原因……此处省略1万字。客观环境和资源的状态和变化，自身心境&#x2F;情绪&#x2F;情感的状态与调整，自我的约束和控制，都是事情发生的根源。当然，有些东西不受我的控制，很多事情没有捷径，我们需要不断地不断地从过去学习，才能更好的往前走。</p><p>在科研之外，关于阅读，关于行路，关于拍照，其实也有很多值得说道一二的地方，毕竟我好像花了不少时间在这些所谓的“不务正业”的事情上。但一写总会觉得空洞无物，想起上次读书日的时候还写了个长文谈阅读，谈感悟谈收获，可说到底，这些都是过于自我的东西，是没法清楚地描绘出来，也难以感同身受。只不过，这些确确实实也化作了我的养分，滋养且丰富了我社会人之外的世界。阅读减少了我在手机上的时间，“认识”更多的人和事之余，也常常激起我的思考和反省；拍照是源于兴趣，拿起相机是让自己多了一个迈出脚步的理由，更加贴近自然和感受真实的生活，认识更多朴实有趣的人，让我对自己多了更多的包容。生活不应该成为工作的避难所，当然，工作也是，工作也不应该作为逃避生活的借口。积极主动的态度，迎接、拥抱和转变，生活即是生活，都自有其法。</p><p>我们周围有太多的模样，我们也会听到太多的声音，这很容易让人无所适从，疲于奔命，也让人疲于思考自己的状态倾听内心的想法，人们也总是被无处不在充斥着的思想潮流裹挟着往前走。我们已经分不清什么是自己想去做愿意去做，什么又是所谓的应该和不应该，还总有人告诉我们现实就是怎样，告诉我如果不，以后我就怎么样。而每个人的路，都只能自己走一遭，而下一站是哪，无人能预见。</p><p>言多必失，说到底，于我个人，当保持清醒和温暖，主动思考并付诸行动，常反省多尝试新甚至敢于“革命”，一步一步……即是我力求的状态。</p><p>最后就把备忘录的待办内容清一清也即<strong>清垃圾</strong>。</p><h2 id="附-碎念"><a href="#附-碎念" class="headerlink" title="附-碎念"></a>附-碎念</h2><blockquote><p>每一天，看到什么，想到什么，好像常常有些东西会进到我的脑子让我想说点什么，就形成了一个长长的备忘录。定期清理，倒序删除2023&#x2F;12–2023&#x2F;3。</p></blockquote><ul><li>看到一个人在对着发球机苦练发球，我想有人看到定会觉得无意义。打球，跑步，过程，一小段，如果是找结果，都没意义。但是对于打球的人，那一刻他只是一次次看怎么发怎么调整，才不需要管你什么意义。所以时间啊，也该短视一些看。</li><li>不要过多的为未来着想，因为你不知道之后自己是不是会需要，就和买衣服一样。</li><li>少一分期许，多一点自由</li><li>talk is cheap</li><li>不成熟的内容就不要讲了，容易挨批</li><li>消极很简单，摆烂也很简单，但是如何跨过自己心里的坎，并不容易，当现实摆在这里的时候，怎么去面对，是一种选择，你说这是自我pua？我想说这是做自己的主人。</li><li>在一个漆黑的平地上，没有任何阻拦的地方，肆无忌惮的往前，闭着眼睛走路，奔跑。我害怕吗，会害怕吗？会的，这个时候如果有一个人可以看着你或者告诉你，这是不是会好一些呢？这是不是就是所谓的安全感呢？</li><li>今天看了一下文心一言的发布会，百度，很有感触，外界已经潮流汹涌，创新，竞争，前进，战场。与此相比，科研领域却是另外一翻景象，我应该做些什么，才能让自己更有创造力？</li><li>结果和过程，生命的历程和感受，选择与态度。</li><li>人的价值来源于外在的肯定，还是来源于自己的评价？人本人！</li><li>有太多的声音，不应让工作成为生活的避难所，看见可能，我们本能的向往，欣赏美看山是山，不止山</li><li>地铁，有人走，有人跑，有人拐着脚，看到一个自身白衣，白发苍苍目光依旧坚定望着前方的老者，他会是一个医生吗？他在想什么呢？</li><li>为什么经历可以丰富我们的生命体验？因为有时候一个关键词都可以引发我们千丝万缕的联想</li><li>或许他没有消失，而是换了种形式流淌。这里是宁夏，银川</li><li>是是两个人不应该是三个人，四个人，或者两个人和两个人，</li><li>太多的东西和事物短暂且易逝，我们需要思考，什么是重要的，什么是长久能够存于心化于我的。随着时间的流走，有些东西越加珍贵</li><li>分别总是在九月，开始，才意味着结束，七天，亲人，伙伴，同学朋友的笑脸。一周，不长，可以去很多地方，走很远的路，看很多的人，讲很多话，听很多故事。愿天涯若比邻，期下一站再会。高温假，去最热烈的地方，喧嚣，沉静与烟火，去看见，聆听不一样的可能</li><li>人生，情感，陌生人，亲密，过去，珍贵，伤感，孤独，携手，喜乐，对错，种种，同经历过一些事，人，化成记忆，血肉，永存</li><li>总有人在做着没人做过的事，总有人在做着有价值的事情。那些在后来被众人视为壮举亦或是有力量的行动，常常源于某一刻的善念，执着与无畏。小与大，平凡与不凡</li><li>心情，决定了很多事情，音乐也是如此，心情烦躁的时候，让我们沉下来的不是音乐，而且内心思考之后的平静。我们可以通过听歌来判断和察觉当下的情绪，状态，心境。smooth，安静听完一首歌，而不是切歌，顺着歌词和旋律神游或是回想，而不是沉浸在其他事情的负面影响之中。所以，让一个人更好的喜欢和记住一首歌的方式，应该是让他在心情很好的时候，听</li><li>奥森的向日葵很快就成果实了，但明年的这个季节又会有新的盛开，但像向日葵一样阳光的小男孩，明年还遇得到吗？</li><li>做研究，有明确的目标和参考准则是很重要的</li><li>有时候爱情不是因为看到了才相信，而是因为相信才看得到。</li><li>物质的不停息的追逐，人的物化，都是游戏，人，浅薄和空虚，深沉的生命情感，大悲大喜，生命无意义</li><li>想写首诗，印象山南，难忘错那。一片净土，一片圣地，谁的故土，谁的乐园，它们的，他们的。高原之广阔，人点之渺小。夜空的辽阔与生命的渺小，是山川雪域，转山人，朝拜者。冰雪与林草的交织。云朵，列日与寒冷的交响。层峦叠嶂，云端与分界线。红黄蓝的编织绳，五星红旗，白与绿。巨石与古树，透蓝的天与静谧的湖泊。千沟万壑，道路延伸。千年文化，古今一瞬</li><li>科研人员有个毛病，都有强迫症。这样就导致会把时间花在一些没有意义的事情上，即使明知道这个对结果影响不大，做了一些精致但是不顶用的东西，这样子</li><li>一半的风景都在心里</li><li>太多的美好体验和感悟，其实来源于臆想和幻想。论想象力的好坏，如何利用？好的和坏的想象会导向完全不同的思维习惯和心态，包括第一次的体验，也因此，第一次常常是无可替代的，偏见？</li><li>求知若渴</li><li>真理其实是老套的</li><li>当你发自内心想做一下事情的时候，周边的一切都可以是我们的动力源泉</li><li>承认自己的无知</li><li>这个时代下，我们清醒地认识到自己的无力</li><li>音乐永远同在</li><li>过度刺激之后的枯燥感，peace</li><li>生活要做减法</li><li>余华是仁慈的，摇摇欲坠就是没写死。人物和历史，小人物，先读小说再读历史再读哲学？过程。</li><li>书有很多种，有人可以从书本，有人可以从历史，有人可以从大自然中读出人生，哲理，这都是相通的，每个人都有自己的缘分和感悟</li><li>其实人也就像是一个生成式模型，输入大量，然后可以生成，在讲话思考的时候可以排列组合碰撞产生新的东西</li><li>我们愿意几分钟听一首歌，几分钟看一个小视频，甚至看电视剧，但是却并不愿意每天花上一点时间，一天天读完一个完整的故事。</li><li>关于成长，我们不可避免只能通过经历去感悟和思考，以及痛苦。但是我们也可以切实的真切的从过去中汲取养分，学习到很多，毕竟关于人生，关于爱情…我们还有多少新的东西呢？时刻感受着自己的贫瘠和有限</li><li>青草湖畔，歌声摇曳，没有太阳，但阳光，其实一直在</li><li>爱情，留下了更多的，是遗憾，是痛苦，才被写下来了。</li><li>挪威的森林，纯写爱情的，关于亲情涉及很少</li><li>把一切献给现在，此刻是不会再拥有的此刻</li><li>表达和创造，是为人的天性，我始终对爱尤爱情致以崇高敬意，在爱中收获持续的力量，</li><li>Per aspera ad astra</li><li>严格来讲，我不是一个喜欢看书的人，驱使我看书的动力，知识，好奇心和一点无聊，以及虚荣</li><li>Thinking is cheap</li><li>每个人都在以自己的经历和方式学习，成长和磨炼</li><li>团队，相信和互相帮助，尽管各自有目的</li><li>人是很容易无聊的，我们需要工作需要旅行，因为总是要去创造点什么东西，表达与抒发</li><li>路飞传递出来的是信念，在不可战胜的战斗中成长和突破</li><li>对于一个全新的观点和概念，对于第一次看到的解释我们倾向于全盘接受，即便是有了深入思考</li><li>快乐建立在比较和张扬中，就会陷入虚无，要和自己比</li><li>不需要偶像，需要榜样</li><li>我们会本能抗拒和抵触做没有准备好的事情，甚至谈恋爱也是如此</li><li>意义非凡的事情，总是碰巧发生的，只有不重要的事，才有周全的计划。 </li><li>歌手用音乐创作，画家用画笔表达，“普通”人呢？</li><li>眼高手低，期望与落差</li><li>道阻且长，行则将至</li><li>法国小说家福楼拜说：人的一生中，最光辉的一天并非是功成名就那天，而是在悲叹与绝望中，产生对人生挑战的欲望，并勇敢地迈向意志那天。</li><li>不要在个别的人和事上寄托太多的希望</li><li>永远不要等准备好才能干但是要时刻准备着，不要急于输出，沉淀，等待机会</li><li>假使做事要面面顾到，那就什么事都不能做了。——鲁迅</li><li>一个品尝过自由滋味的小鸟，你再也无法把它关在笼中。</li><li>把工作也当修行</li><li>有时候好像需要跑的越来越快，才能保持原地不动</li><li>其实人和树是一样的越是向往高处的阳光它的根就越要伸向黑暗的地底</li><li>不要用立场替代和思考</li><li>工具确实不是重点，但是因为工具影响了工作的速度实际上是令人烦躁的</li><li>脱离实际的描述与灌输是如此无力。﻿有些东西讲出来，列出来就成了条条框框，让人难以理解接受，实际上应该自己主动地思考和阅读，结合自身的体会和经历思考和揣摩…</li><li>对于养成习惯而言，目的反而是最重要的，而不是习惯本身</li><li>见贤思齐焉，见不贤而内自省也</li><li>脑子里两个声音，第二个声音就是多了一层思考，多了一层良莠和利益的抉择</li><li>应该是从喜欢里得到力量和快乐</li><li>要更加清楚地知道并定义我们是在做什么事情，阅读，刷微信，刷资讯？</li><li>少发点朋友圈</li><li>要去相信相信的力量</li><li>常总结与思考言行，技能的习得与提高亦如此。警惕自欺、自我麻痹偏见和对自我的过度迷信。</li><li>多读书，无数前人的思考与智慧可以扩展我们对世界，对自我的认识的角度，对自我的剖析和人性的直面，可以激发我们的潜能，也可以让我们更好的借助人的心理特性增强行动力。</li><li>爱和情感是需要终生修习的能力，而我很多时候往往忽略或是主动逃避</li><li>今年的我会更有动力去做好能做的事和自己想做的事</li><li>慢慢会发现一个简单的道理，其实没有什么是我本来就是这样无法改变的，多的是“我不愿”改变，人们总是本能走向安稳，回避痛苦，顶多改良，更别说革命</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;一晃已经接近年底，马上到了快要年终总结的时候……&lt;/p&gt;</summary>
    
    
    
    <category term="生活漫步" scheme="https://hscyber.github.io/categories/%E7%94%9F%E6%B4%BB%E6%BC%AB%E6%AD%A5/"/>
    
    
  </entry>
  
  <entry>
    <title>Windows安装ubuntu子系统及python环境</title>
    <link href="https://hscyber.github.io/posts/d9c0291/"/>
    <id>https://hscyber.github.io/posts/d9c0291/</id>
    <published>2023-11-22T14:41:21.000Z</published>
    <updated>2024-01-10T11:51:23.616Z</updated>
    
    <content type="html"><![CDATA[<p>此处记录在本地Windows10&#x2F;11环境中安装ubuntu环境及Python conda环境安装的过程，可便于后续私有云服务器Python包环境的离线迁移及部署。</p><span id="more"></span><h2 id="系统安装"><a href="#系统安装" class="headerlink" title="系统安装"></a>系统安装</h2><blockquote><p><a href="https://ubuntu.com/tutorials/install-ubuntu-on-wsl2-on-windows-11-with-gui-support#1-overview">ubuntu官方教程</a></p></blockquote><p>！由于所里私有云不支持公网的访问，且缺乏相关完备的镜像源，因此需要离线迁移环境到服务器，经过查询发现window目前提供了较好的基于WSL的解决方案，配置步骤：</p><ol><li>启用windows虚拟机功能，重启电脑</li><li>官方渠道下载并安装 <a href="https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi">WSL2 Linux kernel update package for x64 machines</a>. 更多可见<a href="https://learn.microsoft.com/zh-cn/windows/wsl/install">wsl install</a>。</li><li>打开微软应用商店并搜索ubuntu，此处我选择安装18.04版本</li><li>打开并进入，<code>sudo apt update</code>更新apt源，<code>sudo apt full-upgrade</code>，此时已经完成安装</li><li><code>pwd</code>(present working directory) 显示当前ubuntu子系统的工作目录&#x2F;路径，此外，</li><li>系统路径位于：<a href="https://askubuntu.com/questions/759880/where-is-the-ubuntu-file-system-root-directory-in-windows-subsystem-for-linux-an">参考</a>，</li></ol><ul><li>C:\Users\huangs\AppData\Local\Packages\CanonicalGroupLimited.Ubuntu18.04LTS_79rhkp1fndgsc\LocalState\rootfs\home</li><li>在window11上可能略有不同可自行查询</li></ul><img src="/posts/d9c0291/image-20231128224838590.png" class title="image-20231128224838590"><img src="/posts/d9c0291/image-20231128225006701.png" class title="image-20231128225006701"><h2 id="Python的Conda环境配置"><a href="#Python的Conda环境配置" class="headerlink" title="Python的Conda环境配置"></a>Python的Conda环境配置</h2><blockquote><p>此处我使用miniconda3，创建3.9的环境用于使用，geop为环境名</p></blockquote><h3 id="安装miniconda"><a href="#安装miniconda" class="headerlink" title="安装miniconda"></a>安装miniconda</h3><p><a href="https://docs.conda.io/projects/miniconda/en/latest/index.html#quick-command-line-install">参考</a>，首先进入用户目录，<code>cd ./huangsh/</code>依次执行如下命令。相关的命令可自行查阅文档熟悉。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在根目录下创建文件夹miniconda3用于安装</span></span><br><span class="line">mkdir -p ~/miniconda3</span><br><span class="line">wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh -O ~/miniconda3/miniconda.sh</span><br><span class="line">bash ~/miniconda3/miniconda.sh -b -u -p ~/miniconda3</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装完成后删除安装文件</span></span><br><span class="line">rm -rf ~/miniconda3/miniconda.sh</span><br></pre></td></tr></table></figure><img src="/posts/d9c0291/image-20231122153314987.png" class title="image-20231122153314987"><h3 id="环境配置与迁移"><a href="#环境配置与迁移" class="headerlink" title="环境配置与迁移"></a>环境配置与迁移</h3><p>创建环境<code>conda create -n &lt;env_name&gt; python=3.9</code>、激活环境并安装包，更多可参考<a href="https://hscyber.github.io/posts/42743416/">Python环境(3)：环境及包管理Conda+pypi</a>,<a href="https://hscyber.github.io/posts/911c717a/">Python环境(4)：环境迁移及共享</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">conda create -n geop python=3.9</span><br><span class="line">conda activate geop</span><br><span class="line">conda install geopandas rasterio scikit-learn</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>打包压缩供迁移：<code>tar -zcvf geop.tar.gz directory_to_compress</code></p><p>本地解压缩：<code>tar -zxvf geop.tar.gz  -C /tmp/extract/</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-c 压缩文件内容</span><br><span class="line">-x 解压文件中的内容</span><br><span class="line">-z 使用gzip来解压或压缩.tar.gz格式的文件</span><br><span class="line">-v 压缩过程中显示文件</span><br><span class="line">-f 置顶文件名，f 后面立刻紧跟文件名，不能接受其他参数</span><br></pre></td></tr></table></figure><h2 id="linux常用指令"><a href="#linux常用指令" class="headerlink" title="linux常用指令"></a>linux常用指令</h2><p><a href="https://www.runoob.com/linux/linux-command-manual.html">Linux 命令大全</a>，<a href="https://www.runoob.com/linux/linux-tutorial.html">linux快速入门参考1</a>，<code>/</code>代表根目录，<code>.</code>代表当前目录，<code>..</code>上级目录，<code>tab</code>键自动补全文件(夹)名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入home路径，<span class="built_in">cd</span>代表改变路径，~指代家目录。？home/用户名</span></span><br><span class="line">cd ~</span><br><span class="line">cd /home/huangsh/</span><br><span class="line">ls # 列出当前目录下的文件</span><br><span class="line">cd ./miniconda3  #切换到当前目录下的miniconda目录内</span><br><span class="line">cd ..  #返回上级目录</span><br></pre></td></tr></table></figure><p><code>mkdir</code>, <code>rmdir</code>, <code>rm</code>, <code>sudo(以超级用户权限执行)</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir</span><br><span class="line">rmdir  #只能删除空文件夹</span><br><span class="line">rm -rf #删除文件或文件夹及其内的文件/夹</span><br><span class="line">rm -rf /  #删除全部文件</span><br></pre></td></tr></table></figure><p><code>cp</code>：文件复制，<code>cp -rf</code>：文件夹复制，<code>mv</code>：移动&#x2F;剪切文件或文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cp ~/Downloads/a.txt ~Downloads/b.txt</span><br><span class="line">cd ./Downloads</span><br><span class="line">cp a.txt b.txt</span><br><span class="line">ls</span><br><span class="line">mv a.pdf b.pdf  #文件重命名</span><br><span class="line"></span><br><span class="line">clear  #清屏</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;此处记录在本地Windows10&amp;#x2F;11环境中安装ubuntu环境及Python conda环境安装的过程，可便于后续私有云服务器Python包环境的离线迁移及部署。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux及服务器相关" scheme="https://hscyber.github.io/categories/Linux%E5%8F%8A%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="Ubuntu" scheme="https://hscyber.github.io/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>强化学习入门（2）</title>
    <link href="https://hscyber.github.io/posts/d205f64e/"/>
    <id>https://hscyber.github.io/posts/d205f64e/</id>
    <published>2023-11-17T13:10:20.000Z</published>
    <updated>2023-11-17T13:19:41.072Z</updated>
    
    <content type="html"><![CDATA[<p>学习task02，关于模型的建立和训练，<strong>免模型预测和控制</strong>，预测此处指学习环境的状态转移矩阵，控制则是得到并改进策略并输出最佳结果。</p><span id="more"></span><blockquote><p>这一次的task方法的推导部分不少地方暂未走通，简单模型的搭建和运行未开展，后续填坑hh</p></blockquote><h2 id="免模型预测"><a href="#免模型预测" class="headerlink" title="免模型预测"></a>免模型预测</h2><blockquote><p><a href="https://johnjim0816.com/joyrl-book/#/ch4/main">https://johnjim0816.com/joyrl-book/#/ch4/main</a></p></blockquote><p>本章介绍常见的两种<strong>免模型预测</strong>方法，<strong>蒙特卡洛方法(MC)<strong>和</strong>时序差分方法(TD)<strong>。除动态规划之外，基础的强化学习算法都是</strong>免模型的</strong>。</p><p>有模型与免模型？预测与控制？</p><ul><li><p>有模型强化学习指“有环境模型”的强化学习，即状态转移概率已知或预先学习到。优点是节约成本，可以在<strong>不与真实环境交互</strong>的情况下进行学习。</p></li><li><p>免模型则直接从与环境的交互中学习，在学习过程中需要与真实环境进行大量的交互。</p></li><li><p>预测：免模型事先不知道环境的状态转移概率，因此需要先去<strong>近似环境的状态价值函数——预测过程</strong></p></li><li><p>控制：找到一个最优策略，过程通常涉及策略评估和策略改进</p></li></ul><p>待预测的<strong>状态价值函数</strong>，最优策略、累积回报的<strong>期望</strong>：<br>$$<br>\begin{aligned}<br>V_\pi(s) &amp; &#x3D;\mathbb{E}<em>\pi\left[R</em>{t+1}+\gamma R_{t+2}+\gamma^2 R_{t+3}+\cdots \mid S_t&#x3D;s\right] \<br>&amp; &#x3D;\mathbb{E}_\pi\left[G_t \mid S_t&#x3D;s\right]<br>\end{aligned}<br>$$</p><h3 id="蒙特卡洛模拟估计"><a href="#蒙特卡洛模拟估计" class="headerlink" title="蒙特卡洛模拟估计"></a>蒙特卡洛模拟估计</h3><p>一种<font color="#dd0000">统计模拟方法</font>，通过多次重复的采样观测来逼近实际状态价值函数</p><ul><li><p>蒙特卡洛方法的思路是我们可以采样大量的轨迹，对于每个轨迹计算对应状态的回报然后取平均近似，称之为经验平均回报。根据大数定律，只要采样的轨迹数量足够多，计算出的经验平均回报就能趋近于实际的状态价值函数。</p></li><li><p>蒙特卡洛方法有一定的局限性，即只适用于有终止状态的马尔可夫决策过程。</p></li></ul><p><font color="#dd0000">显然，当可能的状况和情况很多的情况下不能直接暴力模拟</font>，实际使用主要包括两种，首次访问蒙特卡洛和每次访问蒙特卡洛。</p><ul><li>FVMC，先模拟一个完整的回合，然后走一遍t并计算每个状态的回报，只在<strong>第一次遍历到某个状态时</strong>会记录并计算对应的回报</li><li>EVMC，每次经过计算都会会记录状态的回报</li><li>FVMC 是一种基于回合的增量式方法，具有无偏性和收敛快的优点，但是在状态空间较大的情况下，依然需要训练很多个回合才能达到稳定的结果。而 EVMC 则是更为精确的预测方法，但是<strong>计算的成本相对也更高</strong>。</li></ul><p>估计值的<strong>迭代更新</strong>：新的估计值&lt;—旧的估计值+步长×（目标值-旧的估计值），表达为公式如下，此处的$\alpha$相当于深度学习中的<strong>学习率</strong>，G-V即为回报估计的误差error。<br>$$<br>V\left(s_t\right) \leftarrow V\left(s_t\right)+\alpha\left[G_t-V\left(s_t\right)\right]<br>$$</p><h3 id="时序差分估计"><a href="#时序差分估计" class="headerlink" title="时序差分估计"></a>时序差分估计</h3><p> 一种<font color="#dd0000">基于经验的动态规划方法</font>，它结合了蒙特卡洛和动态规划的思想。</p><ul><li>奖励更新过程中使用了<strong>当前</strong>奖励和<strong>后继</strong>状态的估计，因此终止状态需要单独考虑</li><li>0步自举（bootstrap）——$TD(0)$：使用一个状态的估计值来更新该状态的估计值，没有再利用后续状态信息，$r_{t+1}-V\left(s_t\right)$</li></ul><p>$$<br>\begin{cases}V\left(s_t\right) \leftarrow V\left(s_t\right)+\alpha\left[r_{t+1}-V\left(s_t\right)\right] &amp; \text { 对于终止状态 } V\left(s_t\right) \ V\left(s_t\right) \leftarrow V\left(s_t\right)+\alpha\left[r_{t+1}+\gamma V\left(s_{t+1}\right)-V\left(s_t\right)\right] &amp; \text { 对于非终止状态 } V\left(s_t\right)\end{cases}<br>$$<br><strong>n 步</strong>时序差分:时序差分方法进一步拓展，自举的步数从0步拓展到n步</p><ul><li><font color="#dd0000">和蒙特卡洛的联系</font>：<strong>趋近无穷时，就变成了蒙特卡洛方法，因此可以通过调整n实现两种方法的权衡</strong></li><li>这个$n$值具体情况需要具体选取和实验，常见方法：网格搜索、随机搜索、训练自适应选择、交叉验证、经验取值</li></ul><h3 id="两种方法的比较"><a href="#两种方法的比较" class="headerlink" title="两种方法的比较"></a>两种方法的比较</h3><p><font color="#dd0000">时序差分效率更高，受条件的限制更少更灵活，且在马尔可夫环境下有更高的学习效率</font></p><ul><li>效率：时序差分方法可以在线学习，每走一步就可以更新，效率高。蒙特卡洛方法必须等游戏结束时才可以学习。</li><li>时序差分方法可以从不完整序列上进行学习。蒙特卡洛方法只能从完整的序列上进行学习。</li><li>时序差分方法可以在连续的环境下（没有终止）进行学习。蒙特卡洛方法只能在有终止的情况下学习。</li><li>时序差分方法利用了马尔可夫性质，在马尔可夫环境下有更高的学习效率。蒙特卡洛方法没有假设环境具有马尔可夫性质，利用采样的价值来估计某个状态的价值，在不是马尔可夫的环境下更加有效。</li></ul><img src="/posts/d205f64e/image-20231117204142158.png" class title="image2"><h2 id="免模型控制"><a href="#免模型控制" class="headerlink" title="免模型控制"></a>免模型控制</h2><blockquote><p>控制，即给定一个马尔可夫决策过程，输出<u>最优策略以及对应的最优价值函数</u></p></blockquote><h3 id="Q-learning-算法"><a href="#Q-learning-算法" class="headerlink" title="Q-learning 算法"></a>Q-learning 算法</h3><h3 id="强化学习训练过程"><a href="#强化学习训练过程" class="headerlink" title="强化学习训练过程"></a>强化学习训练过程</h3><p>首先我们会迭代很多个回合，在每回合中，首先重置环境回到初始化的状态，智能体根据状态选择动作，然后环境反馈中下一个状态和对应的奖励，同时智能体会更新策略，直到回合结束。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i_ep <span class="keyword">in</span> <span class="built_in">range</span>(train_eps): <span class="comment"># 遍历每个回合</span></span><br><span class="line">    <span class="comment"># 重置环境，获取初始状态</span></span><br><span class="line">    state = env.reset()  <span class="comment"># 重置环境,即开始新的回合</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>: <span class="comment"># 对于比较复杂的游戏可以设置每回合最大的步长，例如while ep_step&lt;100，即最大步长为100。</span></span><br><span class="line">        <span class="comment"># 智能体根据策略采样动作</span></span><br><span class="line">        action = agent.sample_action(state)  <span class="comment"># 根据算法采样一个动作</span></span><br><span class="line">        <span class="comment"># 与环境进行一次交互，得到下一个状态和奖励</span></span><br><span class="line">        next_state, reward, terminated, _ = env.step(action)  <span class="comment"># 智能体将样本记录到经验池中</span></span><br><span class="line">        agent.memory.push(state, action, reward, next_state, terminated) </span><br><span class="line">        <span class="comment"># 智能体更新策略</span></span><br><span class="line">        agent.update(state, action, reward, next_state, terminated)  </span><br><span class="line">        <span class="comment"># 更新状态</span></span><br><span class="line">        state = next_state  </span><br><span class="line">        <span class="comment"># 如果终止则本回合结束</span></span><br><span class="line">        <span class="keyword">if</span> terminated:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 强化学习中有几个要素，<font color="#dd0000">智能体、环境、经验池（经回放）</font>，还要考虑一下智能体在强化学习中主要负责哪些工作。</p><h3 id="定义智能体"><a href="#定义智能体" class="headerlink" title="定义智能体"></a>定义智能体</h3><ul><li>采样动作</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Agent</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>():</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sample_action</span>(<span class="params">self, state</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27; 采样动作，训练时用</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        self.sample_count += <span class="number">1</span></span><br><span class="line">        <span class="comment"># epsilon是会递减的，这里选择指数递减</span></span><br><span class="line">        self.epsilon = self.epsilon_end + (self.epsilon_start - self.epsilon_end) * math.exp(- self.sample_count / self.epsilon_decay) </span><br><span class="line">        <span class="comment"># e-greedy 策略</span></span><br><span class="line">        <span class="keyword">if</span> np.random.uniform(<span class="number">0</span>, <span class="number">1</span>) &gt; self.epsilon:</span><br><span class="line">            action = np.argmax(self.Q_table[<span class="built_in">str</span>(state)]) <span class="comment"># 选择Q(s,a)最大对应的动作</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            action = np.random.choice(self.n_actions) <span class="comment"># 随机选择动作</span></span><br><span class="line">        <span class="keyword">return</span> action     </span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>预测动作，测试不需要额外探索，直接输出Q值对应最大的动作</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Agent</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>():</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict_action</span>(<span class="params">self,state</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27; 预测或选择动作，测试时用</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        action = np.argmax(self.Q_table[<span class="built_in">str</span>(state)])</span><br><span class="line">        <span class="keyword">return</span> action</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>更新方法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, state, action, reward, next_state, terminated</span>):</span><br><span class="line">    Q_predict = self.Q_table[<span class="built_in">str</span>(state)][action] </span><br><span class="line">    <span class="keyword">if</span> terminated: <span class="comment"># 终止状态</span></span><br><span class="line">        Q_target = reward  </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        Q_target = reward + self.gamma * np.<span class="built_in">max</span>(self.Q_table[<span class="built_in">str</span>(next_state)]) </span><br><span class="line">    self.Q_table[<span class="built_in">str</span>(state)][action] += self.lr * (Q_target - Q_predict)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="定义环境"><a href="#定义环境" class="headerlink" title="定义环境"></a>定义环境</h3><blockquote><p>当然大多数情况下需要根据需求建立我们自己的环境，这时我们也可以仿照 Gym 的模式来做</p></blockquote><p>我们选择的环境是 OpenAI Gym 开发的，它提供了一套标准化的环境，包括经典的控制理论问题和游戏，代码封装得也比较好，只需要一行代码就能定义好环境，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">env = gym.make(<span class="string">&#x27;CliffWalking-v0&#x27;</span>)  </span><br></pre></td></tr></table></figure><p>获取环境的状态数和动作数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n_states = env.observation_space.n <span class="comment"># 状态数</span></span><br><span class="line">n_actions = env.action_space.n <span class="comment"># 动作数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;状态数：<span class="subst">&#123;n_states&#125;</span>， 动作数：<span class="subst">&#123;n_actions&#125;</span>&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="设参数"><a href="#设参数" class="headerlink" title="设参数"></a>设参数</h3><p> Q-learning 算法的超参数（需要人工调整的参数）比较少，其中 折扣因子比较固定，设置在 0.9 到 0.999 之间，一般设置成 0.99 即可。而学习率 在本章节中设置的比较大，为 0.1，实际更复杂的环境和算法中学习率是小于 0.01，因为太大很容易发生过拟和的问题，只是本节的环境和算法都比较简单，为了收敛得更快点所以设置得比较大。此外由于我们探索策略中的$\epsilon$是会随着采样步数衰减的，在实践过程中既不能让它衰减得太快也不能让它衰减得太慢，因此需要合理设置如下参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self.epsilon_start = <span class="number">0.95</span> <span class="comment">#  e-greedy策略中epsilon的初始值</span></span><br><span class="line">self.epsilon_end = <span class="number">0.01</span> <span class="comment">#  e-greedy策略中epsilon的最终值</span></span><br><span class="line">self.epsilon_decay = <span class="number">200</span> <span class="comment">#  e-greedy策略中epsilon的衰减率</span></span><br></pre></td></tr></table></figure><h3 id="开始训练并分析结果"><a href="#开始训练并分析结果" class="headerlink" title="开始训练并分析结果"></a>开始训练并分析结果</h3><p>Q-learning</p><p>Sarsa</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;学习task02，关于模型的建立和训练，&lt;strong&gt;免模型预测和控制&lt;/strong&gt;，预测此处指学习环境的状态转移矩阵，控制则是得到并改进策略并输出最佳结果。&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习与深度学习" scheme="https://hscyber.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="强化学习" scheme="https://hscyber.github.io/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>强化学习入门（1）</title>
    <link href="https://hscyber.github.io/posts/bcf963a4/"/>
    <id>https://hscyber.github.io/posts/bcf963a4/</id>
    <published>2023-11-15T15:39:55.000Z</published>
    <updated>2023-11-17T13:14:54.879Z</updated>
    
    <content type="html"><![CDATA[<p>近期计划开始上手一些深度学习相关的内容，刚好看到DataWhale发布的友好的“小白”组队学习计划，便跟随<a href="https://johnjim0816.com/joyrl-book/#/">教材任务</a>学习并定期记录学习过程，首先是第一部分，包含<strong>基本概念、马尔可夫过程和动态规划</strong>三部分的内容学习。</p><span id="more"></span><h2 id="概念整理"><a href="#概念整理" class="headerlink" title="概念整理"></a>概念整理</h2><blockquote><p>需要说明的是，非CS专业在学习相关内容时会有些难度，因此有些地方浅尝辄止记录用法和结论，后续再补充完善。教程主页：<a href="https://johnjim0816.com/joyrl-book/#/">https://johnjim0816.com/joyrl-book/#/</a></p></blockquote><h3 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h3><p><strong>强化学习？</strong>，结合<a href="https://en.wikipedia.org/wiki/Reinforcement_learning">维基百科</a>的定义</p><ul><li>是机器学习和最优控制的一个跨学科领域，涉及<strong>智能代理</strong>如何在<strong>动态环境</strong>中采取<strong>行动</strong>以<strong>最大化累积奖励</strong>。</li><li>强化学习是三种基本机器学习范式之一，与监督学习和无监督学习并列。强化学习与监督学习的不同之处在于不需要呈现标记的输入&#x2F;输出对，并且不需要显式纠正次优动作。相反，重点是在<font color="#dd0000">探索（未知领域）和利用（当前知识）之间找到平衡</font>。</li><li>该环境通常以<a href="https://en.wikipedia.org/wiki/Markov_decision_process">马尔可夫决策过程</a>(MDP) 的形式表示的形式表示，因为这种环境的许多强化学习算法都使用动态编程技术。</li><li>基本强化学习被建模为<a href="https://en.wikipedia.org/wiki/Markov_decision_process">马尔可夫决策过程</a></li><li>典型应用：游戏领域如典型的AlphaGo、机器人领域</li></ul><h3 id="一些特点"><a href="#一些特点" class="headerlink" title="一些特点"></a>一些特点</h3><ol><li><p>试错学习（trial and error learning），尝试–结果–学习–再尝试–</p></li><li><p>决策Decision–反馈&#x2F;结果（reward or punishment）；多次组合即序列决策过程，公式表达：$D_1+D_2+…+D_n\stackrel{累积奖励}{\longrightarrow}目标$</p></li><li><p>对于任意问题，只要能够建模成<strong>序列决策问题</strong>或者带有鲜明的<strong>试错学习特征</strong>，就可以使用强化学习来相对较好地解决。</p></li><li><p>强化学习方式，从数据中学习：</p><ol><li><p>模仿学习（从专家数据中学习策略）</p></li><li><p>逆强化学习IRL（从人类数据中学习奖励函数）</p></li><li><p>从人类反馈中学习（人类标注的数据中学习奖励模型来进行微调fine-tune）</p></li></ol></li></ol><h3 id="其他概念"><a href="#其他概念" class="headerlink" title="其他概念"></a>其他概念</h3><ul><li>实时环境（ real-time environment ）：离线强化学习、世界模型（离线训练、在线推理决策）</li><li>分布漂移（distribution shift），即学习的场景和真实场景分布不同，导致结果的偏差</li><li>探索策略（ exploration strategy ）：强化学习过程需要在探索和利用之间做出权衡，前者会尝试未知动作，后者选择已有动作</li><li>多智能体强化学习（ multi-agent reinforcement learning，MARL ），智能体之间存在交互和互相影响</li><li>多任务强化学习，需要在多个任务及目标之前权衡。</li></ul><h2 id="马尔可夫决策过程"><a href="#马尔可夫决策过程" class="headerlink" title="马尔可夫决策过程"></a>马尔可夫决策过程</h2><blockquote><p>使用数学形式化表达序列决策序列决策过程——马尔可夫决策过程（Markov decision process，MDP）</p></blockquote><h3 id="表达过程"><a href="#表达过程" class="headerlink" title="表达过程"></a>表达过程</h3><p>将对象和交互过程抽象为——智能体+环境，每一步$t$，智能体“观测”当前状态$S_t$，根据状态执行动作$a_t$，执行完收到奖励$r_t$，同时环境受动作影响到了下个状态$s_{t+1}$</p><ul><li>注意，$t&#x3D;0和t&#x3D;1$之间与现实时间无关的，取决于智能体每次交互并获得反馈所需要的时间</li></ul><p>目标：最大化累积奖励$G_t &#x3D; r_1+r_2+\cdots+r_T$，从 $t&#x3D;0 $和$ t+T$ 这一段时步我们称为一个回合（ episode ），如游戏中的一局。</p><img src="/posts/bcf963a4/image-20231112225501720.png" class title="image1"><h3 id="马尔可夫性"><a href="#马尔可夫性" class="headerlink" title="马尔可夫性"></a>马尔可夫性</h3><blockquote><p>某个状态的未来只与当前状态$s_t$有关，与<strong>历史的状态无关</strong>。</p></blockquote><p><font color="#dd0000">问题1：不满足马尔可夫性怎么办</font></p><p>而实际问题中，如棋类游戏其实不符合马尔可夫性，因为在我们决策的过程需要考虑历史走子的位置例如吃子等。实际中这类情况可以结合其他的方法来辅助强化学习进行决策，如</p><ul><li>可以用深度学习神经网络来表示当前的棋局，并用蒙特卡洛搜索树等技术来模拟玩家的策略和未来可能的状态，来构建一个新的决策模型，这就是著名的 AlphaGO 算法。</li></ul><p><font color="#dd0000">问题2：如何考虑未来的回报即未来对当前的影响？</font></p><p><strong>引入折扣因子$\gamma$，通过系数来调整我们对未来回报的关注</strong>：智能体会持续与环境交互，此时$T&#x3D;\infty$，如下，$G_t$，$R_{t+1}$即表示t时刻之后的回报<br>$$<br>G_t&#x3D;R_{t+1}+\gamma R_{t+2}+\gamma^2 R_{t+3}+\cdots&#x3D;\sum_{k&#x3D;0}^{\infty} \gamma^k R_{t+k+1}<br>$$</p><p>推导可得$G_t&#x3D;R_{t+1} +\gamma G_{t+1}$</p><h3 id="状态转移矩阵"><a href="#状态转移矩阵" class="headerlink" title="状态转移矩阵"></a>状态转移矩阵</h3><p>马尔可夫链（Markov Chain）&#x2F;离散时间的马尔可夫过程（Markov Process）</p><img src="/posts/bcf963a4/image-20231116005619927.png" class title="image2"><p>状态转移概率和矩阵：智能体或环境状态数通常是有限的，因此可以用一种<strong>状态流向图</strong>来表示智能体与环境交互过程中的走向。</p><ul><li>对于同一个状态所有状态转移概率加起来是等于 1 的</li><li>状态转移矩阵是环境的一部分，跟智能体无关，智能体会根据状态转移矩阵来做出决策；有时智能体和环境的角色是能相互对调的，只要能各自建模成马尔可夫决策过程即可。</li></ul><p>此外：</p><p>在马尔可夫链（马尔可夫过程）的基础上</p><ul><li>+<strong>奖励元素</strong>就会形成马尔可夫<strong>奖励过程</strong>（MRP）</li><li>+<strong>增加动作</strong>的元素就会形成马尔可夫<strong>决策过程</strong>。</li><li>马尔可夫链和马尔可夫奖励过程在其他领域例如金融分析会用的比较多，<strong>强化学习则重在决策</strong></li></ul><h2 id="动态规划（Dynamic-Programming）"><a href="#动态规划（Dynamic-Programming）" class="headerlink" title="动态规划（Dynamic Programming）"></a>动态规划（Dynamic Programming）</h2><blockquote><p>强化学习中最基础的算法之一，动态规划被用于求解值函数和最优策略。常见的动态规划算法包括值迭代（Value Iteration）、策略迭代（Policy Iteration）和 Q-learning 算法等。</p></blockquote><h3 id="定义及性质"><a href="#定义及性质" class="headerlink" title="定义及性质"></a>定义及性质</h3><p>动态规划具体指的是：在某些复杂问题中，<font color="#dd0000">将问题转化为若干个子问题</font>，并在求解每个子问题的过程中保存已经求解的结果，以便后续使用。</p><p>动态规划问题的性质：</p><ul><li>无后效性：某状态以后的过程不会影响以前的状态，只与当前状态有关，即马尔可夫性质</li><li>最优化原理：问题的最优解所包含的<strong>子问题的解也是最优的</strong>，就称该问题具有最优子结构<ul><li>如前面提到的回报受未来汇报的影响的问题，可以通过动态规划来拆解计算，即可以将$G_{t+1}$拆解为$$G_t,G_{t-1},\cdots,G_1$的问题，</li></ul></li></ul><p>$$<br>G_t&#x3D;R_{t+1} +\gamma G_{t+1}<br>$$</p><p>具体的解决方法</p><ol><li>价值迭代算法Value Iteration</li><li>策略迭代算法Policy Iteration</li></ol><h3 id="状态和动作的价值计算"><a href="#状态和动作的价值计算" class="headerlink" title="状态和动作的价值计算"></a>状态和动作的价值计算</h3><ol><li>状态价值函数$V\pi(s)$：计算从特定状态出发在某种策略$\pi$下进行决策所能得到的<strong>回报期望值</strong></li><li>动作价值函数$Q\pi(s,a)$：计算引入一个动作后的期望回报价值</li><li>贝尔曼方程：由于目标即是<font color="#dd0000">累积回报期望</font>，在最优策略下，状态价值函数也是最优的，相应的动作价值函数也最优，经过一系列推导可以得到<strong>最优策略下的状态价值函数</strong>,公式表达为贝尔曼最优方程（Bellman optimality equation)——$V_{\pi^*}(s)$</li></ol><img src="/posts/bcf963a4/image-20231116213901245.png" class title="image-20231116213901245"><p>对于动作价值函数也是同理可以推导一个公式计算$Q_{\pi^*}(s,a)$</p><h3 id="如何求解和优化？"><a href="#如何求解和优化？" class="headerlink" title="如何求解和优化？"></a>如何求解和优化？</h3><p>实际求解中在优化策略的过程中，需要<strong>同时优化</strong>状态和动作价值函数，这是一个多目标优化的问题</p><ol><li>策略迭代算法（能<strong>更快</strong>接近最优解，见下图）<ul><li>策略估计：首先固定策略$\pi$不变，然后估计对应的状态价值函数$V$</li><li>策略改进：根据$V$,结合策略推导出$Q$，然后优化$Q$并改进$\pi$</li></ul></li><li>价值迭代算法<ul><li>将所有的状态价值初始化，然后不停地对每个状态迭代，直到收敛到最优价值$V^*$</li><li>根据最优价值推算出最优策略$\pi^*$。</li></ul></li></ol><img src="/posts/bcf963a4/image-20231116011623798.png" class title="image3"><p>额外补充：在本章的算法中，其实默认状态转移概率$\sum_{s^{\prime} \in S} p\left(s^{\prime} \mid s, a\right)$已知，但状态转移概率是环境本身的性质，通常未知，因此最基本的策略迭代和价值迭代难以直接应用，这时通常会对先<strong>状态转移概率或者状态（动作）价值函数进行预测估计</strong>。</p><p>以上，后续继续推进……</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;近期计划开始上手一些深度学习相关的内容，刚好看到DataWhale发布的友好的“小白”组队学习计划，便跟随&lt;a href=&quot;https://johnjim0816.com/joyrl-book/#/&quot;&gt;教材任务&lt;/a&gt;学习并定期记录学习过程，首先是第一部分，包含&lt;strong&gt;基本概念、马尔可夫过程和动态规划&lt;/strong&gt;三部分的内容学习。&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习与深度学习" scheme="https://hscyber.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="强化学习" scheme="https://hscyber.github.io/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>基于Hexo与Github搭建静态个人博客网站</title>
    <link href="https://hscyber.github.io/posts/1fb16b0c/"/>
    <id>https://hscyber.github.io/posts/1fb16b0c/</id>
    <published>2023-10-29T02:40:02.000Z</published>
    <updated>2023-10-29T08:00:17.515Z</updated>
    
    <content type="html"><![CDATA[<p>如题，抽空记录了一下本网站的构建过程以供查阅。这里我基于Github提供的免费网站，并基于<a href="https://hexo.io/index.html">Hexo框架</a>在本地构建并部署，使用的渲染主题是<a href="https://theme-next.js.org/">Next</a>。</p><span id="more"></span><h2 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h2><p>首先需要说明的是，对于博客搭建，这里提供的是一个可选项，但<strong>重要的事把事情做起来而不在于使用什么技术或形式</strong>。有很多开源的框架，如Hugo、Jekyll，也有很多免费或付费的网站搭建平台，比如流行的WordPress，可以一键构建好博客网站，有兴趣可自行探索</p><hr><p>回归正题，为什么会有这个站？——（目前）个人认为博客网站是作为集内容<strong>存档、查阅及分享</strong>为一体的十分便捷的笔记仓库的最佳工具。我主要用来记录什么？</p><ul><li>定期记录和分类整理自己常用的一些<strong>代码</strong>，以便随查随用，因为经历过那种哪里写过但是代码找不到的情况</li><li>阅读和学习笔记，通过<strong>写</strong>的方式来促使自己完成进一步的<strong>思考和总结</strong></li><li>记录和<strong>分享</strong>经验，不论是工具类的还是非工具类的。</li></ul><h2 id="快速了解"><a href="#快速了解" class="headerlink" title="快速了解"></a>快速了解</h2><ol><li>Github是一个免费的云端的代码托管平台（远程服务器），我们可以连接该服务器将本地的代码同步上传到其上。它还提供了Github Pages，可以将托管的<strong>网站源码</strong>自动发布成可以被公众访问的<strong>网站</strong>。</li><li>Hexo是一个基于Node.js的博客框架（类似的还有很多包括Jekyll及Hogo等），可将用 Markdown 文档转换为预设好主题样式的 <strong>html 页面</strong>，并可以一键部署到Github等平台<ul><li>Node.js是一种开源且跨平台的 JavaScript 运行时环境，允许我们在Web 浏览器之外执行 JavaScript 代码（包括前中后端），Node.js默认使用npm——包管理器，拥有超多软件包的库 。</li></ul></li></ol><p>因此，通过二者结合，我们可以将<strong>本地的笔记文档（用markdown格式撰写）即使转换为网页并部署到Github</strong>，也就形成了一个简约的博客网站。静态是指内容依赖于html文件而不是根据数据库等动态生成内容。</p><h2 id="部署过程"><a href="#部署过程" class="headerlink" title="部署过程"></a>部署过程</h2><ol><li>本地安装<a href="https://git-scm.com/">Git</a>，一个代码&#x2F;项目管理软件，此处用于本地与Github“沟通”，同步传输文件</li><li>下载<a href="https://nodejs.org/en">Node.js</a>，<a href="https://www.npmjs.com/">npm</a>是Node.js 的默认程序包管理器，<a href="https://www.freecodecamp.org/chinese/news/what-is-npm-a-node-package-manager-tutorial-for-beginners/">More</a></li><li>使用npm安装<a href="https://hexo.io/docs/index.html">Hexo</a>，初始化文件夹并预览本地网页，我将文件夹放置于<strong>Onedriver</strong>目录下定期同步</li><li>切换Hexo的主题并根据个人喜好修改样式，完成本地初步设置（推荐主题：Next, Maupassant, 3hexo）</li><li>创建Github账号及存储库Repository，库名{username}.github.io即为初始Page地址（一个账号通常只有一个page网页），此处设置需同名。</li><li>创建密匙以自由访问github,连接到Github，本地撰写笔记，即时上传至云端即可</li><li>【可选】创建私有库自动同步备份文件</li></ol><h2 id="步骤参考"><a href="#步骤参考" class="headerlink" title="步骤参考"></a>步骤参考</h2><blockquote><p><a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a></p><p><a href="https://hexo.io/zh-cn/docs/github-pages.html">https://hexo.io/zh-cn/docs/github-pages.html</a></p></blockquote><h3 id="安装hexo并连接github"><a href="#安装hexo并连接github" class="headerlink" title="安装hexo并连接github"></a>安装hexo并连接github</h3><p>安装hexo，安装完hexo后即可本地预览初始化网页<a href="http://localhost:4000/">http://localhost:4000/</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">hexo init blog   #再当前目录下创建博客根文件夹</span><br><span class="line">cd blog   # 进入目录</span><br><span class="line">hexo server   # http://localhost:4000/</span><br></pre></td></tr></table></figure><p>安装完成后，目录下有如下文件夹，<a href="https://hexo.io/zh-cn/docs/setup">详见</a>：</p><ol><li>_config.yml：Hexo配置文件，设置关于网站的各种信息</li><li>package.json：已安装包的信息</li><li>source：存放推文及草稿等信息，博客文档均位于.&#x2F;source&#x2F;_posts，这里可以看到初始网页</li><li>scaffolds：关于网页及默认草稿模板的文件，当新建文章时，Hexo 会根据 scaffold 来创建文件.</li><li>themes：主题文件夹，Hexo 会根据主题来生成静态页面，可自行切换修改,下文详细介绍</li></ol><p>配置github</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">git config --global user.name &quot;GitHub用户名&quot;</span><br><span class="line">git config --global user.email &quot;GitHub注册邮箱&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建公钥用于建立和github的连接</span></span><br><span class="line">cat ~/.ssh/id_rsa.pub</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装依赖部署hexo</span></span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo deploy</span><br></pre></td></tr></table></figure><p>创建同名存储库</p><img src="/posts/1fb16b0c/image-20231029155216880.png" class title="image-20231029155216880"><img src="/posts/1fb16b0c/image-20231029155709062.png" class title="image-20231029155709062"><p>在设置中（注意是账户设置不是仓库设置）添加ssh key用于连接</p><img src="/posts/1fb16b0c/image-20231029155525664.png" class title="image-20231029155525664"><p>最后在_config文件中修改为仓库链接</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># _config.yml 文件最底部</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/one-command-deployment</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">https://github.com/hhsgis/hhsgis.github.io</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure><h3 id="主题详细设置"><a href="#主题详细设置" class="headerlink" title="主题详细设置"></a>主题详细设置</h3><blockquote><p>以最流行的Next为例，主页：<a href="https://theme-next.js.org/">https://theme-next.js.org/</a></p><p>文档: <a href="https://theme-next.js.org/docs/getting-started/">https://theme-next.js.org/docs/getting-started/</a></p><p>选择流行的主题可以减少很多不必要的麻烦，维护更新快。</p></blockquote><p>Next安装，也可手动到对应的github下载文件夹放置在blog根目录下的theme目录下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/next-theme/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><p>在themes主题下可以找到主题文件，通常包含以下文件&#x2F;文件夹：</p><ul><li><strong>_config.yml</strong>：主题的配置文件，设置主题的样式等等</li><li>languages：语言设置</li><li>layout：主题的布局模板文件</li><li>scripts：脚本文件夹。在启动时，Hexo 会加载此文件夹内的 JavaScript 文件</li><li><strong>source</strong>：主题的资源、样式渲染等的文件存放，包括js css等</li></ul><p>实际上，主要通过_config.yml及source对主题进行进一步的自定义调整。</p><ul><li>关于大部分的设置，都可以借助如下文档的说明以及_config.yml的修改实现，如果一九不满意，则可以借助外部插件并自行编写修改。<ul><li>比如，通过设置<code>scheme: Gemini</code>就可以修改布局为多列的布局</li><li>更多的可以自行探索和尝试，以上</li></ul></li></ul><img src="/posts/1fb16b0c/image-20231025004228891.png" class title="image-20231025004228891"><h3 id="撰写及发布"><a href="#撰写及发布" class="headerlink" title="撰写及发布"></a>撰写及发布</h3><p>完成上述步骤之后，就可以进入到对应的文件夹目录，使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;mypost&quot;</span><br></pre></td></tr></table></figure><p>创建一个新的md文件，并在&#x2F;source&#x2F;_posts&#x2F;路径下找到对应的,md文件撰写自己的笔记了，撰写完成后，在命令行执行生成并发布，即完成了上传，但是通常延迟才能看到效果，也可以直接使用<code>hexo s</code>并打开本地站点预览结果并调试，默认<a href="http://localhost:4000/%E3%80%82">http://localhost:4000/。</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>关闭预览使用以下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl c</span><br></pre></td></tr></table></figure><p>后续内容预告：md文件中的图片上传显示问题的解决，以及本地typora编辑器的联动</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;如题，抽空记录了一下本网站的构建过程以供查阅。这里我基于Github提供的免费网站，并基于&lt;a href=&quot;https://hexo.io/index.html&quot;&gt;Hexo框架&lt;/a&gt;在本地构建并部署，使用的渲染主题是&lt;a href=&quot;https://theme-next.js.org/&quot;&gt;Next&lt;/a&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="Hexo建博客" scheme="https://hscyber.github.io/categories/Hexo%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="Hexo" scheme="https://hscyber.github.io/tags/Hexo/"/>
    
    <category term="GitPage" scheme="https://hscyber.github.io/tags/GitPage/"/>
    
    <category term="Github" scheme="https://hscyber.github.io/tags/Github/"/>
    
    <category term="博客" scheme="https://hscyber.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>Pandas(杂)：将多列变量值堆叠为一列以便于matplotlib及seaborn制图</title>
    <link href="https://hscyber.github.io/posts/837ccaeb/"/>
    <id>https://hscyber.github.io/posts/837ccaeb/</id>
    <published>2023-09-06T04:21:05.000Z</published>
    <updated>2023-09-06T06:55:12.827Z</updated>
    
    <content type="html"><![CDATA[<p>在绘图时有时需要将本地的表格转换为目标接口要求的格式 -&gt; reshape。以seaborn绘制多变量箱线图为例，其默认数据接口需要的是<strong>一列数值加一列类型，但是本地通常是多列</strong>，因此需要转换，此外如果涉及到<strong>排序</strong>也需要自行调整，以下为案例代码记录以供复用：</p><span id="more"></span><h2 id="DataFrame格式转换"><a href="#DataFrame格式转换" class="headerlink" title="DataFrame格式转换"></a>DataFrame格式转换</h2><p>比如我的表格为如下的，n行6列的表格，其中5列代表五个不同的变量，需要将其转换为三列:UID, Typename, Value</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;UID&quot;</span>: <span class="built_in">range</span>(<span class="number">12</span>),</span><br><span class="line">        <span class="string">&quot;x1&quot;</span>: np.random.randn(<span class="number">12</span>),</span><br><span class="line">        <span class="string">&quot;x2&quot;</span>: np.random.randn(<span class="number">12</span>),</span><br><span class="line">        <span class="string">&quot;x3&quot;</span>: np.random.randn(<span class="number">12</span>),</span><br><span class="line">        <span class="string">&quot;x4&quot;</span>: np.random.randn(<span class="number">12</span>),</span><br><span class="line">        <span class="string">&quot;x5&quot;</span>: np.random.randn(<span class="number">12</span>),</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><img src="/posts/837ccaeb/image-20230906144957498.png" class title="image-20230906144957498"><p>使用<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.stack.html">pd.stack()</a>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">df2 = df.set_index(<span class="string">&quot;UID&quot;</span>)</span><br><span class="line">df2 = df2.stack().reset_index()</span><br><span class="line">df2.columns = [<span class="string">&quot;UID&quot;</span>,<span class="string">&quot;typaneme&quot;</span>,<span class="string">&quot;y&quot;</span>]</span><br><span class="line">df2</span><br></pre></td></tr></table></figure><p>不使用函数自行定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">stack_data</span>(<span class="params">datatable, typenames, col_id</span>):</span><br><span class="line">    uids = []</span><br><span class="line">    names = []</span><br><span class="line">    values = []</span><br><span class="line">    <span class="keyword">for</span> col <span class="keyword">in</span> typenames:</span><br><span class="line">        value = <span class="built_in">list</span>(datatable[col])</span><br><span class="line">        names.extend([col]*<span class="built_in">len</span>(value))</span><br><span class="line">        values.extend(value)</span><br><span class="line">        uids.extend(datatable[col_id])</span><br><span class="line">    df_temp = pd.DataFrame(&#123;col_id:uids,<span class="string">&quot;typename&quot;</span>:names, <span class="string">&quot;y&quot;</span>:values&#125;)</span><br><span class="line">    <span class="keyword">return</span> df_temp</span><br><span class="line"><span class="comment"># 选定要堆叠的变量</span></span><br><span class="line">cols = <span class="built_in">list</span>(df.columns[<span class="number">1</span>:])</span><br><span class="line">typenames = cols</span><br><span class="line"><span class="comment"># [&#x27;x1&#x27;, &#x27;x2&#x27;, &#x27;x3&#x27;, &#x27;x4&#x27;, &#x27;x5&#x27;]</span></span><br><span class="line">df_temp = stack_data(df,typenames,<span class="string">&quot;UID&quot;</span>)</span><br><span class="line">df_temp</span><br></pre></td></tr></table></figure><p>如果不需要UID列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">stack_data</span>(<span class="params">datatable, typenames</span>):</span><br><span class="line">    names = []</span><br><span class="line">    values = []</span><br><span class="line">    <span class="keyword">for</span> col <span class="keyword">in</span> typenames:</span><br><span class="line">        value = <span class="built_in">list</span>(datatable[col])</span><br><span class="line">        names.extend([col]*<span class="built_in">len</span>(value))</span><br><span class="line">        values.extend(value)</span><br><span class="line">    df_temp = pd.DataFrame(&#123;<span class="string">&quot;typename&quot;</span>:names, <span class="string">&quot;y&quot;</span>:values&#125;)</span><br><span class="line">    <span class="keyword">return</span> df_temp</span><br><span class="line"><span class="comment"># 选定要堆叠的变量</span></span><br><span class="line">cols = <span class="built_in">list</span>(df.columns[<span class="number">1</span>:])</span><br><span class="line">typenames = cols</span><br><span class="line"></span><br><span class="line">df_temp = stack_data(df,typenames)</span><br><span class="line">df_temp</span><br></pre></td></tr></table></figure><h2 id="按照统计值排序"><a href="#按照统计值排序" class="headerlink" title="按照统计值排序"></a>按照统计值排序</h2><blockquote><p>如果是直接排序，直接对得到的表格进行排序即可，df.sort_values(by&#x3D;[“y”], scending&#x3D;False,ignore_index&#x3D;False)</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#直接对堆叠后的值排序如下， 也可多列进行排序，也可以结合set_index();sort_index()函数操作</span></span><br><span class="line">df_temp.sort_values(by=[<span class="string">&quot;y&quot;</span>], ascending=[<span class="literal">False</span>],ignore_index=<span class="literal">False</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>有时候需要先<strong>对列进行排序</strong>再进行堆叠，比如按照中位数或者均值排列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">df3 = df[df.columns[<span class="number">1</span>:]]</span><br><span class="line">meds = df3.median()</span><br><span class="line">meds = meds.sort_values(ascending=<span class="literal">False</span>)</span><br><span class="line">cols_sort = <span class="built_in">list</span>(meds.index)</span><br><span class="line"><span class="comment"># cols_sort即为按照列的中位数调整顺序后的列名[&#x27;x2&#x27;, &#x27;x5&#x27;, &#x27;x1&#x27;, &#x27;x4&#x27;, &#x27;x3&#x27;]</span></span><br><span class="line">cols_sort.insert(<span class="number">0</span>,<span class="string">&quot;UID&quot;</span>)</span><br><span class="line">df3 = df[cols_sort]</span><br><span class="line"></span><br><span class="line">....</span><br><span class="line"><span class="comment"># 再进行堆叠即可得到新的按照变量的中值进行排序的结果</span></span><br></pre></td></tr></table></figure><h2 id="Seaborn绘图示意"><a href="#Seaborn绘图示意" class="headerlink" title="Seaborn绘图示意"></a>Seaborn绘图示意</h2><blockquote><p>seaborn.boxplot(data&#x3D;None, *, x&#x3D;None, y&#x3D;None, hue&#x3D;None, order&#x3D;None, hue_order&#x3D;None, orient&#x3D;None, color&#x3D;None, palette&#x3D;None, saturation&#x3D;0.75, width&#x3D;0.8, dodge&#x3D;True, fliersize&#x3D;5, linewidth&#x3D;None, whis&#x3D;1.5, ax&#x3D;None, **kwargs)</p></blockquote><p>实际上我们可以对该图进行定制，包括颜色，文字，线和箱等等，后续单独记一下boxplot的调参</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">sns.set_theme(style=<span class="string">&quot;ticks&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Initialize the figure with a logarithmic x axis</span></span><br><span class="line">f, ax = plt.subplots(figsize=(<span class="number">7</span>, <span class="number">6</span>))</span><br><span class="line">ax.set_xscale(<span class="string">&quot;log&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load the example planets dataset</span></span><br><span class="line">planets = sns.load_dataset(<span class="string">&quot;planets&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot the orbital period with horizontal boxes</span></span><br><span class="line">sns.boxplot(x=<span class="string">&quot;distance&quot;</span>, y=<span class="string">&quot;method&quot;</span>, data=planets,</span><br><span class="line">            whis=[<span class="number">0</span>, <span class="number">100</span>], width=<span class="number">.6</span>, palette=<span class="string">&quot;vlag&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add in points to show each observation</span></span><br><span class="line">sns.stripplot(x=<span class="string">&quot;distance&quot;</span>, y=<span class="string">&quot;method&quot;</span>, data=planets,</span><br><span class="line">              size=<span class="number">4</span>, color=<span class="string">&quot;.3&quot;</span>, linewidth=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Tweak the visual presentation</span></span><br><span class="line">ax.xaxis.grid(<span class="literal">True</span>)</span><br><span class="line">ax.<span class="built_in">set</span>(ylabel=<span class="string">&quot;&quot;</span>)</span><br><span class="line">sns.despine(trim=<span class="literal">True</span>, left=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><img src="/posts/837ccaeb/box.jpeg" class title="image"><h2 id><a href="#" class="headerlink" title></a></h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/reshaping.html#reshaping-stacking">pandas-reshape</a></li><li><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.sort_values.html">pandas.DataFrame.sort_values</a></li><li><a href="https://seaborn.pydata.org/generated/seaborn.boxplot.html#seaborn.boxplot">seaborn boxplot</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在绘图时有时需要将本地的表格转换为目标接口要求的格式 -&amp;gt; reshape。以seaborn绘制多变量箱线图为例，其默认数据接口需要的是&lt;strong&gt;一列数值加一列类型，但是本地通常是多列&lt;/strong&gt;，因此需要转换，此外如果涉及到&lt;strong&gt;排序&lt;/strong&gt;也需要自行调整，以下为案例代码记录以供复用：&lt;/p&gt;</summary>
    
    
    
    <category term="Pandas数据处理分析" scheme="https://hscyber.github.io/categories/Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Pandas" scheme="https://hscyber.github.io/tags/Pandas/"/>
    
  </entry>
  
  <entry>
    <title>重装或者新装windows系统</title>
    <link href="https://hscyber.github.io/posts/aee76f8e/"/>
    <id>https://hscyber.github.io/posts/aee76f8e/</id>
    <published>2023-08-14T05:12:41.000Z</published>
    <updated>2024-01-10T11:51:38.627Z</updated>
    
    <content type="html"><![CDATA[<p>近期准备把旧电脑给弟用，游戏本，之前装的ubuntu系统，现在重装回windows10，现在装系统之类的事情都十分便捷，此处简单记录一下步骤</p><span id="more"></span><h2 id="U盘安装win"><a href="#U盘安装win" class="headerlink" title="U盘安装win"></a>U盘安装win</h2><blockquote><p>如果是在原本就是window系统电脑上升级或者重装，直接安装即可</p></blockquote><p>准备一个U盘（大于8G），步骤（制作驱动–重启进入启动项–安装）如下：</p><ol><li>下载window官方安装工具<a href="https://www.microsoft.com/zh-cn/software-download/windows10">地址</a>，一路next</li><li>安装方式选择选择安装iso镜像</li><li>创建完之后会选择路径下载一个iso文件</li><li>等待下载完成，下载工具进行USB驱动器创建，我用的是<a href="https://rufus.ie/en/">Rufus</a></li><li>添加镜像并完成驱动器创建</li><li>在目标电脑上安装即可：<ol><li>重启&#x2F;关机，打开启动项，惠普是F9，联想默认F9，工作中好像是F12</li><li>切换启动项，选择从U盘启动（即刚刚插入的U盘）</li><li>然后安装系统即可，必要时删除原分区或者格式化</li><li>安装过程需要选择登录微软账户，如果有则直接登录即可，也可以注册再登，用QQ邮箱即可</li></ol></li></ol><img src="/posts/aee76f8e/image-20230814131816766.png" class title="image-20230814131816766"><img src="/posts/aee76f8e/image-20230814131947964.png" class title="image-20230814131947964"><img src="/posts/aee76f8e/image-20230814132421537.png" class title="image-20230814132421537"><h2 id="系统选择和激活"><a href="#系统选择和激活" class="headerlink" title="系统选择和激活"></a>系统选择和激活</h2><p>选择的时候可以选择家庭版或者专业版，我选的是专业版，权限回多一点</p><ol><li>激活的时候可以直接t宝或者拼dd买一个激活码激活windows，10块钱</li><li>然后如果需要office，再几十块钱买一个office绑定微软账户即可</li><li>官网下载并完成office安装</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;近期准备把旧电脑给弟用，游戏本，之前装的ubuntu系统，现在重装回windows10，现在装系统之类的事情都十分便捷，此处简单记录一下步骤&lt;/p&gt;</summary>
    
    
    
    <category term="Tools" scheme="https://hscyber.github.io/categories/Tools/"/>
    
    
    <category term="Windows" scheme="https://hscyber.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>R语言可视化基础(1)：初识ggplot2</title>
    <link href="https://hscyber.github.io/posts/f16647ba/"/>
    <id>https://hscyber.github.io/posts/f16647ba/</id>
    <published>2023-05-11T13:07:53.000Z</published>
    <updated>2023-05-12T01:41:01.159Z</updated>
    
    <content type="html"><![CDATA[<p>初始R语言ggplot2绘图包，了解其绘图逻辑</p><span id="more"></span><h2 id="ggplot2的一些术语"><a href="#ggplot2的一些术语" class="headerlink" title="ggplot2的一些术语"></a>ggplot2的一些术语</h2><blockquote><p>绘图是一种数据属性到视觉属性的“映射”(mapping)，或者说对应</p></blockquote><p>Plot(图)&#x3D; data(数据集)+ Aesthetics(美学映射)+ Geometry(几何对象)。</p><ol><li>数据(data): 用于可视化的对象，包含变量(variables)，变量存储在数据库(dataframe)的每一列。<font color="#dd0000">ggplot2要求数据必须存储在数据框中，且每个属性变量必须独立集中存储在一列。</font></li><li>变量类型：类别型变量称为离散型变量，数值型则称为连续型变量</li><li>几何对象 (geom)：用于呈现数据的几何图形，如点、线、多边形等，如geom_point，geom_bar，geom_line，geom_histogram，geom_boxplot，geom_density等用来绘制散点图、柱状图、折线图等等</li><li>图形属性 (aesthetic)：几何对象的视觉属性，如x yzuobiao ,线的颜色</li><li>映射函数（aes）：数据中的变量值与图形的映射，如 aes(x &#x3D;变量1 , y &#x3D; 变量2,col&#x3D;变量3）</li><li>标度 (scale)：从值到图形的转换关系，一般使用三个单词用_连接，如scale_fill_gradient和cale_x_continuous第一个都是scale，第二个是color fill x y linetype shape size等可更改的参数，第三个是具体的类型</li><li>统计变换（Statistics）：如 stat_summary(fun.y &#x3D; mean, geom &#x3D; “line”)计算均值并添加线，stat_smooth添加拟合曲线。</li><li>分面 (facet)：将数据拆开，进行分层画图</li><li>主题 (theme)：主题设定，与数据无关的很多属性可以通过这个函数实现。如边距等，ggplot默认有两个主题theme_grey()和theme_bw(), 设置当前主题的函数是theme_set()<ol><li>根据需求对图的外观、属性等进行精细调节，详细<a href="https://r-graphics.org/recipe-appearance-theme-modify">参考</a></li></ol></li><li>引导元素 (guide)：向看图者将视觉属性<strong>映射回</strong>数据空间，常用的引导元素包括刻度线、标签等</li><li>注释 (annotate): 在图上增增加的注释，文字、线、框等</li></ol><p>ggplot2采用了<strong>图层</strong>的概念进行画图，先画好基础图，然后再往上一层一层叠加图层，所以在进行ggplot2画图的时候，代码中会有大量的“+”，这就是对于图层的叠加。</p><h2 id="绘图步骤"><a href="#绘图步骤" class="headerlink" title="绘图步骤"></a>绘图步骤</h2><p><a href="https://zhuanlan.zhihu.com/p/581073260">参考</a>，导入包及数据，然后设置数据集映射指标，然后进行各种图层的叠加和属性的修改，最后导出图片,</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">library<span class="punctuation">(</span>ggplot2<span class="punctuation">)</span></span><br><span class="line">data<span class="punctuation">(</span><span class="string">&quot;diamonds&quot;</span><span class="punctuation">)</span></span><br><span class="line">set.seed<span class="punctuation">(</span><span class="number">300</span><span class="punctuation">)</span> <span class="comment">#设置种子，保证可重复</span></span><br><span class="line">diamonds<span class="operator">=</span>sample_n<span class="punctuation">(</span>diamonds<span class="punctuation">,</span>size <span class="operator">=</span> <span class="number">300</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 开始绘图</span></span><br><span class="line">dev.new<span class="punctuation">(</span><span class="punctuation">)</span><span class="comment"># 新建独立窗口</span></span><br><span class="line">p <span class="operator">=</span> ggplot<span class="punctuation">(</span>data<span class="operator">=</span>diamonds<span class="punctuation">,</span>aes<span class="punctuation">(</span>x<span class="operator">=</span>carat<span class="punctuation">,</span>y<span class="operator">=</span>price<span class="punctuation">)</span><span class="punctuation">)</span><span class="operator">+</span></span><br><span class="line">  geom_point<span class="punctuation">(</span>size<span class="operator">=</span><span class="number">3</span><span class="punctuation">,</span>shape<span class="operator">=</span><span class="number">23</span><span class="punctuation">,</span>aes<span class="punctuation">(</span>fill<span class="operator">=</span>cut<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">p <span class="operator">=</span> p<span class="operator">+</span> geom_smooth<span class="punctuation">(</span>method <span class="operator">=</span> <span class="string">&quot;lm&quot;</span><span class="punctuation">)</span><span class="operator">+</span></span><br><span class="line">  labs<span class="punctuation">(</span>y<span class="operator">=</span><span class="string">&quot;price&quot;</span><span class="punctuation">,</span>x<span class="operator">=</span><span class="string">&quot;carct&quot;</span><span class="punctuation">)</span><span class="operator">+</span></span><br><span class="line">  annotate<span class="punctuation">(</span><span class="string">&quot;text&quot;</span><span class="punctuation">,</span>x<span class="operator">=</span><span class="number">2</span><span class="punctuation">,</span>y<span class="operator">=</span><span class="number">20000</span><span class="punctuation">,</span>size<span class="operator">=</span><span class="number">5</span><span class="punctuation">,</span>label<span class="operator">=</span><span class="built_in">expression</span><span class="punctuation">(</span>paste<span class="punctuation">(</span>italic<span class="punctuation">(</span><span class="string">&quot;p_value&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span><span class="string">&quot;=0.005&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">p <span class="operator">=</span> p<span class="operator">+</span>scale_y_continuous<span class="punctuation">(</span>expand <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">)</span><span class="punctuation">,</span>limits <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span><span class="number">20000</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="operator">+</span> </span><br><span class="line">  scale_x_continuous<span class="punctuation">(</span>expand <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">)</span><span class="punctuation">,</span>limits <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="operator">+</span> <span class="comment">#设置值的范围，同时让点与x，y轴没有间隙</span></span><br><span class="line">  scale_fill_manual<span class="punctuation">(</span>values <span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="string">&#x27;#B4B4B4&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;#F7BC08&#x27;</span><span class="punctuation">,</span><span class="string">&quot;#E94335&quot;</span><span class="punctuation">,</span><span class="string">&quot;#1194C2&quot;</span><span class="punctuation">,</span><span class="string">&quot;#954B98&quot;</span><span class="punctuation">)</span> <span class="punctuation">)</span><span class="comment">#设置点的颜色范围</span></span><br><span class="line"></span><br><span class="line">p <span class="operator">=</span> p<span class="operator">+</span>theme_classic<span class="punctuation">(</span><span class="punctuation">)</span><span class="operator">+</span></span><br><span class="line">  theme<span class="punctuation">(</span>axis.title<span class="operator">=</span> element_text<span class="punctuation">(</span>size<span class="operator">=</span><span class="number">20</span><span class="punctuation">,</span>color<span class="operator">=</span><span class="string">&quot;black&quot;</span><span class="punctuation">,</span>face<span class="operator">=</span><span class="string">&quot;bold&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">        axis.text <span class="operator">=</span> element_text<span class="punctuation">(</span>size<span class="operator">=</span><span class="number">15</span><span class="punctuation">,</span>color<span class="operator">=</span><span class="string">&quot;black&quot;</span><span class="punctuation">,</span>face<span class="operator">=</span><span class="string">&quot;bold&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">        axis.line <span class="operator">=</span> element_line <span class="punctuation">(</span>color <span class="operator">=</span> <span class="string">&quot;black&quot;</span><span class="punctuation">,</span>size <span class="operator">=</span> <span class="number">1</span><span class="punctuation">,</span> linetype <span class="operator">=</span> <span class="string">&quot;solid&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="comment">#线的类型粗细和颜色，这里的线只有两个轴</span></span><br><span class="line">        axis.ticks <span class="operator">=</span> element_line<span class="punctuation">(</span>color <span class="operator">=</span> <span class="string">&quot;black&quot;</span><span class="punctuation">,</span>size <span class="operator">=</span> <span class="number">1</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">        axis.ticks.length <span class="operator">=</span> unit<span class="punctuation">(</span><span class="number">5</span><span class="punctuation">,</span> <span class="string">&quot;pt&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">        legend.position <span class="operator">=</span> <span class="string">&quot;top&quot;</span><span class="punctuation">,</span>  <span class="comment">#图例的位置</span></span><br><span class="line">        legend.text <span class="operator">=</span> element_text<span class="punctuation">(</span>size<span class="operator">=</span><span class="number">15</span><span class="punctuation">,</span>color<span class="operator">=</span><span class="string">&quot;black&quot;</span><span class="punctuation">,</span>face<span class="operator">=</span><span class="string">&quot;bold&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">        legend.title <span class="operator">=</span> element_blank<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line">  <span class="punctuation">)</span></span><br><span class="line">p</span><br></pre></td></tr></table></figure><p>了解初步思路之后视情况进行对应图形的调整即可</p><h2 id="输出文件-ggsave"><a href="#输出文件-ggsave" class="headerlink" title="输出文件-ggsave"></a>输出文件-ggsave</h2><h3 id="pdf"><a href="#pdf" class="headerlink" title="pdf"></a>pdf</h3><p>参考-<a href="https://r-graphics.org/recipe-output-vector">https://r-graphics.org/recipe-output-vector</a></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 快捷使用。</span></span><br><span class="line"><span class="comment"># 生成图形</span></span><br><span class="line">plot1 <span class="operator">&lt;-</span> ggplot<span class="punctuation">(</span>mtcars<span class="punctuation">,</span> aes<span class="punctuation">(</span>x <span class="operator">=</span> wt<span class="punctuation">,</span> y <span class="operator">=</span> mpg<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_point<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># Default is inches, but you can specify unit</span></span><br><span class="line">ggsave<span class="punctuation">(</span><span class="string">&quot;myplot.pdf&quot;</span><span class="punctuation">,</span> plot1<span class="punctuation">,</span> width <span class="operator">=</span> <span class="number">8</span><span class="punctuation">,</span> height <span class="operator">=</span> <span class="number">8</span><span class="punctuation">,</span> units <span class="operator">=</span> <span class="string">&quot;cm&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下方式可以可以多页绘图</span></span><br><span class="line"><span class="comment"># width and height are in inches. 创建并打开一个文件</span></span><br><span class="line">pdf<span class="punctuation">(</span><span class="string">&quot;myplot.pdf&quot;</span><span class="punctuation">,</span> width <span class="operator">=</span> <span class="number">4</span><span class="punctuation">,</span> height <span class="operator">=</span> <span class="number">4</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 如果按尺寸转换，8x8 cm，这里和Python中是一样的</span></span><br><span class="line">pdf<span class="punctuation">(</span><span class="string">&quot;myplot.pdf&quot;</span><span class="punctuation">,</span> width <span class="operator">=</span> <span class="number">8</span><span class="operator">/</span><span class="number">2.54</span><span class="punctuation">,</span> height <span class="operator">=</span> <span class="number">8</span><span class="operator">/</span><span class="number">2.54</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 绘图</span></span><br><span class="line">plot<span class="punctuation">(</span>mtcars<span class="operator">$</span>wt<span class="punctuation">,</span> mtcars<span class="operator">$</span>mpg<span class="punctuation">)</span></span><br><span class="line">print<span class="punctuation">(</span>ggplot<span class="punctuation">(</span>mtcars<span class="punctuation">,</span> aes<span class="punctuation">(</span>x <span class="operator">=</span> wt<span class="punctuation">,</span> y <span class="operator">=</span> mpg<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span> geom_point<span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 结束绘图并写出</span></span><br><span class="line">dev.off<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="svg"><a href="#svg" class="headerlink" title="svg"></a>svg</h3><p>参考-<a href="https://r-graphics.org/recipe-output-vector-svg">https://r-graphics.org/recipe-output-vector-svg</a></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">library<span class="punctuation">(</span>svglite<span class="punctuation">)</span></span><br><span class="line">svglite<span class="punctuation">(</span><span class="string">&quot;myplot.svg&quot;</span><span class="punctuation">,</span> width <span class="operator">=</span> <span class="number">4</span><span class="punctuation">,</span> height <span class="operator">=</span> <span class="number">4</span><span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span>...<span class="punctuation">)</span></span><br><span class="line">dev.off<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># With ggsave()</span></span><br><span class="line">ggsave<span class="punctuation">(</span><span class="string">&quot;myplot.svg&quot;</span><span class="punctuation">,</span> width <span class="operator">=</span> <span class="number">8</span><span class="punctuation">,</span> height <span class="operator">=</span> <span class="number">8</span><span class="punctuation">,</span> units <span class="operator">=</span> <span class="string">&quot;cm&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><h3 id="png"><a href="#png" class="headerlink" title="png"></a>png</h3><p>参考-<a href="https://r-graphics.org/recipe-output-bitmap">https://r-graphics.org/recipe-output-bitmap</a></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ggplot<span class="punctuation">(</span>mtcars<span class="punctuation">,</span> aes<span class="punctuation">(</span>x <span class="operator">=</span> wt<span class="punctuation">,</span> y <span class="operator">=</span> mpg<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span> geom_point<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># Default dimensions are in inches, but you can specify the unit</span></span><br><span class="line">ggsave<span class="punctuation">(</span><span class="string">&quot;myplot.png&quot;</span><span class="punctuation">,</span> width <span class="operator">=</span> <span class="number">8</span><span class="punctuation">,</span> height <span class="operator">=</span> <span class="number">8</span><span class="punctuation">,</span> unit <span class="operator">=</span> <span class="string">&quot;cm&quot;</span><span class="punctuation">,</span> dpi <span class="operator">=</span> <span class="number">300</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p>ggplot2|详解八大基本绘图要素：<a href="https://zhuanlan.zhihu.com/p/77875382">https://zhuanlan.zhihu.com/p/77875382</a></p></li><li><p>R数据可视化手册：<a href="https://r-graphics.org/index.html">https://r-graphics.org/index.html</a></p></li><li><p>ggplot2的绘图逻辑：<a href="https://zhuanlan.zhihu.com/p/581073260">其他1</a>，<a href="https://www.sohu.com/a/397306897_120233365">其他2</a></p></li><li><p>如何在论文中画出漂亮的插图？<a href="https://www.zhihu.com/question/21664179/answer/2747278312">https://www.zhihu.com/question/21664179/answer/2747278312</a></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;初始R语言ggplot2绘图包，了解其绘图逻辑&lt;/p&gt;</summary>
    
    
    
    
    <category term="R语言" scheme="https://hscyber.github.io/tags/R%E8%AF%AD%E8%A8%80/"/>
    
    <category term="ggplot" scheme="https://hscyber.github.io/tags/ggplot/"/>
    
  </entry>
  
  <entry>
    <title>R语言基础(2)：Python与R</title>
    <link href="https://hscyber.github.io/posts/366e33e8/"/>
    <id>https://hscyber.github.io/posts/366e33e8/</id>
    <published>2023-05-11T12:38:05.000Z</published>
    <updated>2023-05-11T15:12:57.421Z</updated>
    
    <content type="html"><![CDATA[<p>上一次用R语言已经是去年的事情了，最近想用R进行制图（在涉及统计和统计图表方面还得是R），R的图表和配色也都很好看，便开始再来学一学R。</p><span id="more"></span><h2 id="R-Python-conversion-guide"><a href="#R-Python-conversion-guide" class="headerlink" title="R-Python conversion guide"></a>R-Python conversion guide</h2><p>直接跳转到这位前辈的博客：</p><p><a href="https://www.mit.edu/~amidi/teaching/data-science-tools/">Data Science Tools</a></p><p><a href="https://www.mit.edu/~amidi/teaching/data-science-tools/conversion-guide/r-python-data-manipulation/">Data manipulation R-Python conversion guide</a></p><p><a href="https://www.mit.edu/~amidi/teaching/data-science-tools/conversion-guide/r-python-data-visualization/">Data visualization</a></p><h2 id="R的便捷与缺点"><a href="#R的便捷与缺点" class="headerlink" title="R的便捷与缺点"></a>R的便捷与缺点</h2><blockquote><p>从Python到R会觉得R的格式不规范</p></blockquote><p>接触过一点时间会发现R语言在某种程度上用起来比R方便，功能的实现只需要找到一个响应的函数，传入参数，得到相应的输出，也就是<font color="#dd0000">封装地更“好”</font>，用起来更简单(傻瓜)了，但是对我来说，便捷之处我感觉就是引出了它的一些缺点：</p><ol><li>包与函数之间缺乏&#x3D;&#x3D;逻辑&#x3D;&#x3D;，不便于查文档和学习包。距离来说，Python中处理文件目录路径相关的操作，都在os中就可以完成，只需要import os，然后通过os.path.split(), os.listdir()等调用即可，&#x3D;&#x3D;Python的包查看文档和接口说明十分方便&#x3D;&#x3D;，R语言则不是，<font color="#dd0000">看到一个R的函数，我都不知道它是否是内置函数，也不知道它属于哪个包，给我的感觉很不好</font>，这可能需要更多的时间来熟悉和查询</li><li>文档不友好。包带来的问题是文档的杂乱，平时我一般通过API文档来查看函数细节，但是R的网页版不方便，而且还存在重名函数等问题，看的很不习惯</li><li>不方便查看和debug，首先是代码不好看（这个还能忍），可读性不佳，另一个是不好改和参考别人的代码，函数和包给人的感觉总是比较乱，想用前辈的代码比较痛苦，相较于Python。</li><li>此外，用的时候发现R不支持中文字符串；</li></ol><p>所以还是不便于用它进行数据处理而仅作为统计分析建模以及可视化工具</p><ul><li>最近开始专门学习一下R的&#x3D;&#x3D;ggplot2&#x3D;&#x3D;制图</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一次用R语言已经是去年的事情了，最近想用R进行制图（在涉及统计和统计图表方面还得是R），R的图表和配色也都很好看，便开始再来学一学R。&lt;/p&gt;</summary>
    
    
    
    <category term="R语言" scheme="https://hscyber.github.io/categories/R%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="R语言" scheme="https://hscyber.github.io/tags/R%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>GIS基础(杂)：自相关/热点/异常分析，Moran&#39;s I和Gets-Ord Gi对比</title>
    <link href="https://hscyber.github.io/posts/51a1b003/"/>
    <id>https://hscyber.github.io/posts/51a1b003/</id>
    <published>2023-03-23T03:07:51.000Z</published>
    <updated>2024-01-10T12:04:31.927Z</updated>
    
    <content type="html"><![CDATA[<p><strong>空间自相关强度计算、热点分析与异常值分析</strong>是空间分析中的常用工具，在此简单辨析一下空间自相关等相关工具的差异和用法。主要对比的是全局和局部的&#x3D;&#x3D;Moran‘s I&#x3D;&#x3D;以及&#x3D;&#x3D;Getis-Ord General G&#x3D;&#x3D;。</p><span id="more"></span><h2 id="实际使用指南"><a href="#实际使用指南" class="headerlink" title="实际使用指南"></a>实际使用指南</h2><ol><li>方法的使用有前提假设，具体可以查看-<a href="https://pro.arcgis.com/en/pro-app/latest/tool-reference/spatial-statistics/what-is-a-z-score-what-is-a-p-value.htm">参考</a></li><li>使用方法前，一定要明确分析的目标以及对应冷点热点或者聚集区的&#x3D;&#x3D;物理含义及解释&#x3D;&#x3D;</li><li>需要使用投影坐标系，单位为m或km</li><li>全局的Moran指数和Gets G都只能从整体上推断数据特征的<strong>空间分布</strong>，前者是判断随机还是分散还是聚集，当然，值的大小也可以指示强度；后者是给出高值或低值是否聚集，聚集程度。</li><li>对于距离阈值的判断可以采用遍历的方式寻找阈值，ArcGIS&#x2F;Pro提供了工具<a href="https://pro.arcgis.com/en/pro-app/latest/tool-reference/spatial-statistics/incremental-spatial-autocorrelation.htm">增量空间自相关分析——寻找距离阈值</a>，或者也可以使用R语言实现&#x2F;Spatial Correlograms，此处的阈值也即是观测的尺度。</li><li>采用的是常用的Z-score进行统计显著性检验，因为只涉及单个数值的检验。</li></ol><table><thead><tr><th align="center">方法</th><th align="center">尺度</th><th align="center">用途</th><th align="center">取值</th></tr></thead><tbody><tr><td align="center">Moran’s I</td><td align="center">Global</td><td align="center">整体上是聚集还是发散，也可以给出程度</td><td align="center">-1，0，1</td></tr><tr><td align="center">Getis-Ord Gi</td><td align="center">Global</td><td align="center">高低值聚集程度</td><td align="center">&gt;0</td></tr><tr><td align="center">Local Moran’s I</td><td align="center">Local&#x2F;逐对象</td><td align="center">高&#x2F;低值聚类探测，异常值分析</td><td align="center">HH;LL;HJ;LH;不显著区（5类）</td></tr><tr><td align="center">Getis-Ord Gi*</td><td align="center">Local&#x2F;逐对象</td><td align="center">高&#x2F;低值聚集区（热点区域）探测</td><td align="center">±90 95 99%显著;不显著区（7类）</td></tr></tbody></table><h2 id="Global尺度"><a href="#Global尺度" class="headerlink" title="Global尺度"></a>Global尺度</h2><blockquote><p>全局Moran’s I 是在假定均质的情况下给出变量总体自相关程度的统计量</p></blockquote><p>空间自相关(Spatial autocorrelation)，空间自相关用来刻画一个对象与其临近对象的<strong>相似</strong>程度。<font color="#dd0000">Moran’s I是用于推断变量“整体”的聚集程度，是倾向于聚集分布还是随机分布，而General G是判断变量中的“高值或低值”的聚集程度。</font></p><img src="/posts/51a1b003/image-20230323113652065.png" class title="image-20230323113652065"><h3 id="Moran’s-I"><a href="#Moran’s-I" class="headerlink" title="Moran’s I"></a>Moran’s I</h3><p>Moran’s I衡量区域 (Global)尺度上某空间随机变量整体自相关的程度，这里比较的对象为&#x3D;&#x3D;整体的均值&#x3D;&#x3D;</p><ul><li>通俗理解：协方差矩阵为正，代表“同方向变化”，为负则说明领域周围有的大于<strong>整体均值</strong>，有的比均值小。</li><li>Moran’s I 取值范围：[-1, 0, +1]，对应表明：负自相关-随机分布-正自相关，结果<strong>解释</strong>：<ul><li>显著的&#x3D;&#x3D;正&#x3D;&#x3D;Z(+1.65, 单侧0.05)表明变量空间分布比期望的随机分布更加&#x3D;&#x3D;聚集&#x3D;&#x3D;(正相关)</li><li>显著的&#x3D;&#x3D;负&#x3D;&#x3D;Z( -1.65, 单侧0.05)表明变量空间分布比期望的随机分布更加&#x3D;&#x3D;分散&#x3D;&#x3D;(负相关)</li></ul></li></ul><img src="/posts/51a1b003/image-20230323112814561.png" class title="image-20230323112814561"><h3 id="Getis-Ord-General-G"><a href="#Getis-Ord-General-G" class="headerlink" title="Getis-Ord General G"></a>Getis-Ord General G</h3><p>Getis-Ord General G 是衡量区域(Global)尺度上某空间随机变量高值&#x2F;低值的聚集程度的统计量, a measure of High&#x2F;Low clustering。General G为正值&gt;0，但对于一个二值(0&#x2F;1)的wij来说，G取值[0, +1]</p><ul><li>显著的&#x3D;&#x3D;正&#x3D;&#x3D;Z(+1.65, 单侧0.05)表明&#x3D;&#x3D;高值&#x3D;&#x3D;变量空间分布比期望的随机分布更加聚集</li><li>显著的&#x3D;&#x3D;负&#x3D;&#x3D;Z( -1.65, 单侧0.05)表明&#x3D;&#x3D;低值&#x3D;&#x3D;变量空间分布比期望的随机分布更加聚集</li></ul><h2 id="Local尺度——聚类及异常分析"><a href="#Local尺度——聚类及异常分析" class="headerlink" title="Local尺度——聚类及异常分析"></a>Local尺度——聚类及异常分析</h2><p>以下两种方式的差异，<a href="https://www.mattpeeples.net/modules/LISA.html">具体可参考</a>。简单来说，局部莫兰指数除了可以进行高低值聚类分析，还可以用于异常值分析，而Getis-Ord Gi* 则主要用于高高值或低低值的聚团发现，如下图我选一个区域，同时在30km的范围内计算二者的值，结果：</p><img src="/posts/51a1b003/%E6%96%B9%E6%B3%95%E5%AF%B9%E6%AF%94.png" class title="方法对比"><h3 id="Local-Moran’s-I"><a href="#Local-Moran’s-I" class="headerlink" title="Local Moran’s I"></a>Local Moran’s I</h3><p>实际上Moran’s I可以拆成n个Moran’s $I_i$的相乘，个体单元尺度上的空间自相关程度Local indicators of spatial association (LISA)。即使不存在显著的全局自相关&#x2F;聚集，局部尺度也可能存在。<strong>对于每个对象</strong>，我们都计算它与周边对象的相似程度（周围的也都是高值还是都是低值，还是有高有低），注意，此处的高低是相对于全局均值而言。</p><p><strong>解释</strong>：</p><ul><li>显著的正Zi(+1.65, 单侧0.05)表明i单元与邻居有相似的值(高-高&#x2F;低-低)-即聚集(Clusters)</li><li>显著的负Zi( -1.65, 单侧0.05)表明i单元与邻居有相异的值(高-低&#x2F;低-高)-即异常(Outliers)</li><li>由此可以识别高-高(HH)和低-低(LL)聚集，以及高-低(HL)和低-高(LH)异常</li></ul><h3 id="Getis-Ord-Gi"><a href="#Getis-Ord-Gi" class="headerlink" title="Getis-Ord Gi*"></a>Getis-Ord Gi*</h3><p>高值对象很重要，但可能不是具有统计意义的热点。要成为统计上显着的热点，一个对象将具高值并且被其他高值对象包围。一个对象及其邻居的<strong>局部总和</strong>与所有对象的<strong>总和</strong>成比例地进行比较；当局部总和与预期的局部总和有很大差异时，并且当该差异太大以至于不是随机机会的结果时，会产生具有统计显着性的z 分数。</p><ul><li>显著正 z 分数，z 分数越大，高值（热点）的聚类就越强烈</li><li>显著负 z 分数，z 分数越小，低值（冷点）的聚类就越强烈。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>空间统计分析 R 语言 &#x2F; 马廷编著. ——北京：科学出版社，2022.10</li><li><a href="https://pro.arcgis.com/en/pro-app/latest/tool-reference/spatial-statistics/h-how-spatial-autocorrelation-moran-s-i-spatial-st.htm">全局Moran指数计算及其原理</a></li><li><a href="https://pro.arcgis.com/en/pro-app/latest/tool-reference/spatial-statistics/cluster-and-outlier-analysis-anselin-local-moran-s.htm">局部Moran指数计算及其原理</a></li><li><a href="https://pro.arcgis.com/en/pro-app/latest/tool-reference/spatial-statistics/incremental-spatial-autocorrelation.htm">增量空间自相关分析——寻找距离阈值</a></li><li><a href="https://pro.arcgis.com/en/pro-app/latest/tool-reference/spatial-statistics/hot-spot-analysis.htm">Gets-G热点分析</a>，<a href="https://pro.arcgis.com/en/pro-app/latest/tool-reference/spatial-statistics/h-how-hot-spot-analysis-getis-ord-gi-spatial-stati.htm">原理</a></li><li><a href="https://pro.arcgis.com/en/pro-app/latest/tool-reference/spatial-statistics/optimized-hot-spot-analysis.htm">优化-自适应的热点分析</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;空间自相关强度计算、热点分析与异常值分析&lt;/strong&gt;是空间分析中的常用工具，在此简单辨析一下空间自相关等相关工具的差异和用法。主要对比的是全局和局部的&amp;#x3D;&amp;#x3D;Moran‘s I&amp;#x3D;&amp;#x3D;以及&amp;#x3D;&amp;#x3D;Getis-Ord General G&amp;#x3D;&amp;#x3D;。&lt;/p&gt;</summary>
    
    
    
    
    <category term="空间自相关" scheme="https://hscyber.github.io/tags/%E7%A9%BA%E9%97%B4%E8%87%AA%E7%9B%B8%E5%85%B3/"/>
    
    <category term="空间热点分析" scheme="https://hscyber.github.io/tags/%E7%A9%BA%E9%97%B4%E7%83%AD%E7%82%B9%E5%88%86%E6%9E%90/"/>
    
    <category term="Moran&#39;s I" scheme="https://hscyber.github.io/tags/Moran-s-I/"/>
    
    <category term="Getis-Ord Gi" scheme="https://hscyber.github.io/tags/Getis-Ord-Gi/"/>
    
  </entry>
  
  <entry>
    <title>栅格处理(杂)：计算多边形内的点数/线长度/面面积</title>
    <link href="https://hscyber.github.io/posts/e57ebaa5/"/>
    <id>https://hscyber.github.io/posts/e57ebaa5/</id>
    <published>2023-03-15T08:37:20.000Z</published>
    <updated>2023-03-15T08:53:30.692Z</updated>
    
    <content type="html"><![CDATA[<p>在进行指标计算时，尤其是格网数据的数值汇总，经常需要<font color="#dd0000">统计汇总面内（区域&#x2F;研究单元）的点的个数、道路的长度、面的面积</font>，对于点数的统计可以直接spatial join或者count，后者则需要多几步操作。</p><span id="more"></span><h2 id="实际操作案例"><a href="#实际操作案例" class="headerlink" title="实际操作案例"></a>实际操作案例</h2><h3 id="计算各区域内路网的长度"><a href="#计算各区域内路网的长度" class="headerlink" title="计算各区域内路网的长度"></a>计算各区域内路网的长度</h3><blockquote><p>计算各区域内&#x2F;格网&#x2F;缓冲区内湖泊的面积等，类似</p></blockquote><p>ArcGIS Pro提供了一个很好用的工具<a href="https://pro.arcgis.com/en/pro-app/latest/tool-reference/geoanalytics-desktop/summarize-within.htm">Summarize Within (GeoAnalytics Desktop)</a>，使用按照参数传入即可，计算完再基于ID将结果表格连接一下。</p><img src="/posts/e57ebaa5/image-20230315165154558.png" class title="image-20230315165154558"><img src="/posts/e57ebaa5/image-20230315165006403.png" class title="image-20230315165006403"><p>如果是使用ArcGIS，步骤如下,<a href="https://gis.stackexchange.com/questions/98518/calculate-line-distances-inside-of-polygons-using-arcgis-for-desktop">参考</a>：</p><ol><li><p>使用<a href="https://desktop.arcgis.com/en/arcmap/latest/tools/coverage-toolbox/identity.htm">Identity</a>，用面打断路网</p></li><li><p>使用<a href="https://desktop.arcgis.com/en/arcmap/latest/tools/analysis-toolbox/summary-statistics.htm">Summary Statistics</a>基于面FID或其他唯一字段统计长度</p></li><li><p>连接表格</p></li></ol><img src="/posts/e57ebaa5/image-20230315165245144.png" class title="image-20230315165245144">]]></content>
    
    
    <summary type="html">&lt;p&gt;在进行指标计算时，尤其是格网数据的数值汇总，经常需要&lt;font color=&quot;#dd0000&quot;&gt;统计汇总面内（区域&amp;#x2F;研究单元）的点的个数、道路的长度、面的面积&lt;/font&gt;，对于点数的统计可以直接spatial join或者count，后者则需要多几步操作。&lt;/p&gt;</summary>
    
    
    
    <category term="时空数据处理分析" scheme="https://hscyber.github.io/categories/%E6%97%B6%E7%A9%BA%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%88%86%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>栅格处理(杂)：添加空间索引显著加快矢量定位及运算</title>
    <link href="https://hscyber.github.io/posts/6f6e706b/"/>
    <id>https://hscyber.github.io/posts/6f6e706b/</id>
    <published>2023-03-15T07:36:37.000Z</published>
    <updated>2023-03-15T07:58:59.361Z</updated>
    
    <content type="html"><![CDATA[<p>这几天在处理格网内点统计（面上的点），缓冲区内统计等，会遇到特别慢的情况，这时候对点图层添加&#x3D;&#x3D;空间索引&#x3D;&#x3D;（几秒完成）之后，再进行处理，从几十分钟的操作降至十几秒。</p><span id="more"></span><p><a href="https://gistbok.ucgis.org/bok-topics/spatial-indexing">空间索引</a>是一种允许有效访问空间对象的数据结构。这是空间数据库常用的技术。如果没有索引，任何对特征的搜索都需要对数据库中的每条记录进行“顺序扫描”，从而导致处理时间更长。在空间索引构建过程中，最小外接矩形作为对象的近似。跨商业和开源数据库的各种类型的空间索引产生可衡量的性能差异。空间索引技术在时间关键型应用程序和空间<strong>大数据</strong>处理中发挥着核心作用。</p><p>小数据影响不大，主要是量大些的数据</p><ol><li>如果是使用&#x3D;&#x3D;ArcGIS或Pro&#x3D;&#x3D;，使用Add Spatial Index工具完成快速定位和汇总统计。<a href="https://desktop.arcgis.com/en/arcmap/latest/tools/data-management-toolbox/add-spatial-index.htm">描述</a>：Adds a spatial index to a <strong>shapefile, file geodatabase, or enterprise geodatabase feature class</strong>. Use this tool to either add a spatial index to a shapefile or feature class that does not already have one or to re-create an existing spatial index。ArcGIS uses spatial indexes to <font color="#dd0000">quickly locate features</font> in feature classes. <strong>Identifying</strong> a feature, <strong>selecting</strong> features by pointing or <strong>dragging</strong> a box, and <strong>panning and zooming</strong> all require ArcMap to use the spatial index to locate features. </li><li>如果是使用&#x3D;&#x3D;QGIS&#x3D;&#x3D;，工具名称是<strong>创建空间索引(Create Spatial Index)</strong></li><li>如果使用&#x3D;&#x3D;Geopandas&#x3D;&#x3D;，它也提供了基于树结构的索引，构建索引的时间基本上为0ns，在使用空间连接的时候会用到，但通常geopandas在执行空间连接时，会自动构建所需的索引。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>df = gpd.read_file(<span class="string">&quot;..shp&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df.has_sindex</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rst.sindex</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rst.has_sindex</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>更多比较，可以查看<a href="https://aetperf.github.io/2021/09/10/Spatial-Join-with-GeoPandas-and-GEOS.html">ref</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这几天在处理格网内点统计（面上的点），缓冲区内统计等，会遇到特别慢的情况，这时候对点图层添加&amp;#x3D;&amp;#x3D;空间索引&amp;#x3D;&amp;#x3D;（几秒完成）之后，再进行处理，从几十分钟的操作降至十几秒。&lt;/p&gt;</summary>
    
    
    
    <category term="时空数据处理分析" scheme="https://hscyber.github.io/categories/%E6%97%B6%E7%A9%BA%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%88%86%E6%9E%90/"/>
    
    
    <category term="ArcGIS" scheme="https://hscyber.github.io/tags/ArcGIS/"/>
    
    <category term="空间索引" scheme="https://hscyber.github.io/tags/%E7%A9%BA%E9%97%B4%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>关于ChatGPT热潮的一点思考</title>
    <link href="https://hscyber.github.io/posts/3dfd2cc1/"/>
    <id>https://hscyber.github.io/posts/3dfd2cc1/</id>
    <published>2023-03-15T03:27:08.000Z</published>
    <updated>2024-01-10T12:06:52.186Z</updated>
    
    <content type="html"><![CDATA[<p>这是一个之前就想写一写的话题，昨晚奥特曼发布了GPT-4，继而又引发了一大波转发。其实，从它最开始到现在，我只在测试的时候用过，所以并未在我个人的工作中体会到它的声势所应有的价值，但我对于它是持一个积极的态度，或者说我对GPT模型的应用有一些&#x3D;&#x3D;期待&#x3D;&#x3D;。</p><span id="more"></span><blockquote><p>关于注册，1. 上梯；2. <a href="https://chat.openai.com/auth/login">网站sign up</a>，建议谷歌邮箱；3. <a href="https://sms-activate.org/">此处</a>注册充值1美元，搜索openai，购买虚拟号码（记住选择的国家）； 4. 按流程发送验证码完成注册</p></blockquote><p>这样一个身处热潮中心的“大家伙”，能否同时兼具深度（专业性）和广度，能否切实在一些行业产生持久且颠覆性的改变，不好去预料，尤其是像我这样的很多还在学校看热闹的<strong>外行</strong>。但从我研究生的角度，我希望它能够给我提供一些<strong>切实的辅助工具</strong>，<font color="#dd0000">比如能让它帮忙查找、帮忙整合、帮忙筛帮忙看、帮忙翻译、帮忙找错帮忙写……我就够满意了</font>【大的改变是不敢奢求也不敢用的，科学研究这种需要严谨，涉及小、专、深、反复的思考是不易代劳的】。</p><h3 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a>搜索引擎</h3><p>&#x3D;&#x3D;搜索&#x3D;&#x3D;本身即是十分重要的技能：一个搜索框和回车键的诞生算是一种&#x3D;&#x3D;理念&#x3D;&#x3D;上的革新，而从庞杂的互联网搜索出一系列的结果供人查看 -&gt; 到直接搜索并&#x3D;&#x3D;给出&#x3D;&#x3D;<strong>一些最佳</strong>的可供参考的答案，我觉得也是一个大的飞跃和进步。</p><ul><li><p>&#x3D;&#x3D;优化搜索效率和结果&#x3D;&#x3D;，这是很容易想到的点，显然，微软也正在推进这样的事（new bing）。时间的推移和技术的进步，互联网上互联网下都积累了大量的<font color="#dd0000">“知识”和“经验”</font>，各行各业，包括针对科研领域，<strong>入行和入门</strong>需要学习的知识技能只会越来越多，重复的工作和问题也很多，把这些更好更高效地利用起来服务使用者，是很有价值的事情。迄今为止我的学习和进步很多也得益于互联网的资源[Google]。</p></li><li><p>尤其是技术相关的问题，比如写&#x3D;&#x3D;代码&#x3D;&#x3D;跑数据，期待进一步优化（Ctrl+C +V的效率）。以前有人说，我平时遇到的99%（绝大部分）的问题，前人可能都已经遇到过且有了解决的方案和经验，但实际中找起答案来不尽人意，以至于消磨了额外的时间甚至是重复“造轮子”，尽管自己折腾的过程也挺有营养，但是能少还是可以少。</p></li></ul><h3 id="文本翻译"><a href="#文本翻译" class="headerlink" title="文本翻译"></a>文本翻译</h3><p>不否认学习外语的必要性及其诸多好处，但是还是有很多想要偷懒读写英文论文或材料的时候，所以期待相关翻译工具能够早日达到——差不多改改能够直接出版的专业润色水平。最好是免费的，当然，如果收费便宜点也能接受。</p><ul><li>尚未讨论图像绘画音频相关的东西，但这些方面肯定也是随着文本一同进步的领域。</li></ul><h3 id="错误发现与校正"><a href="#错误发现与校正" class="headerlink" title="错误发现与校正"></a>错误发现与校正</h3><p>期待能够辅助我从大篇幅的文档中、数据中，按照我的要求准确地进行错误提示并给出校正建议，不限于翻译和文体格式调整。小到错别字和标点，大到格式样式调整和各种纠错，很多能想到的平时涉及重复性劳作又容易疏忽的东西，期待逐渐有更好的解决方案。</p><ul><li>此外，关于一条“知识”的正确与否、可信度，包括谣言判别，也需要更好的辅助手段。</li></ul><h3 id="数据-知识抽取和整合"><a href="#数据-知识抽取和整合" class="headerlink" title="数据&#x2F;知识抽取和整合"></a>数据&#x2F;知识抽取和整合</h3><p>这有点像知识图谱的构建过程了，网页搜索等很多技术领域背后本身就依托了一个巨大的知识图谱。基于大量的文本（如扫描的书籍、电子书、论文等）来针对一些特定的&#x3D;&#x3D;主题&#x3D;&#x3D;或者内容完成知识的抽取、整合及呈现，这也能为一些繁杂的事情节省一点力气。</p><h3 id="让子弹飞一会"><a href="#让子弹飞一会" class="headerlink" title="让子弹飞一会"></a>让子弹飞一会</h3><p>……</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这是一个之前就想写一写的话题，昨晚奥特曼发布了GPT-4，继而又引发了一大波转发。其实，从它最开始到现在，我只在测试的时候用过，所以并未在我个人的工作中体会到它的声势所应有的价值，但我对于它是持一个积极的态度，或者说我对GPT模型的应用有一些&amp;#x3D;&amp;#x3D;期待&amp;#x3D;&amp;#x3D;。&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习与深度学习" scheme="https://hscyber.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="AI" scheme="https://hscyber.github.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>计算机软硬件(杂)：硬盘文件系统（NTFS/FAT32/exFAT）</title>
    <link href="https://hscyber.github.io/posts/d360117d/"/>
    <id>https://hscyber.github.io/posts/d360117d/</id>
    <published>2023-03-12T13:07:47.000Z</published>
    <updated>2024-01-10T11:58:06.472Z</updated>
    
    <content type="html"><![CDATA[<p>计算机系统的外部存储器有内置的硬盘、移动硬盘和U盘等，经常会注意到不同的硬盘文件类型不一样，做一些简单了解。以及，为什么有时候数据的实际大小和占据的内存不一致？</p><span id="more"></span><h2 id="类型及区别"><a href="#类型及区别" class="headerlink" title="类型及区别"></a>类型及区别</h2><blockquote><p><a href="https://www.easeus.com/diskmanager/file-system.html">参考</a></p></blockquote><p>&#x3D;&#x3D;文件系统&#x3D;&#x3D;是操作系统管理和操作存储器内的数据和文件的方式&#x2F;数据结构。通常来说：</p><ul><li>window装系统完成后磁盘类型都是默认NTFS，大型移动硬盘或者移动固态硬盘通常为exFAT。</li><li>选择的区别主要在于<strong>文件的大小</strong>，如传输的单个最大文件大于4G，或磁盘总空间大于16T，则需要选择exFAT<ul><li>还有一个额外的点可以注意一下，计算机<strong>磁盘分区表</strong>有MBr和GPT(GUID)，如果硬盘大于<strong>2T</strong>，需要格式化为GPT，这一点在之前我用<strong>服务器</strong>的时候踩过坑，如果一开始选择了MBR，但是想扩容到2T以上，就可能需要格式化才行（磁盘的分区表类型在电脑管理-&gt;磁盘管理可以看到）。</li></ul></li></ul><img src="/posts/d360117d/image-20230312212452652.png" class title="image-20230312212452652"><h2 id="实际空间"><a href="#实际空间" class="headerlink" title="实际空间"></a>实际空间</h2><blockquote><p><a href="https://support.microsoft.com/en-us/topic/default-cluster-size-for-ntfs-fat-and-exfat-9772e6f1-e31a-00d7-e18f-73169155af95">NTFS、FAT 和 exFAT 的默认簇大小</a></p></blockquote><p>比如有时候会发现这种情况，这是我一个移动硬盘内的一个文件，因为有&#x3D;&#x3D;大量只有1kb的文件&#x3D;&#x3D;，导致空间浪费，其原因是不同文件系统的默认最小单元造成的。如exFAT 默认簇大小是 128 KB，1 B ~ 128 KB 大小的文件占用空间都是 128 KB，128 KB + 1 B ~ 256 KB 大小的文件占用空间都是 256 KB,<a href="https://www.zhihu.com/question/446551421">ref</a>。</p><ul><li>此时可以进行数据清理或者移动到其他格式的硬盘</li></ul><img src="/posts/d360117d/image-20230312212759049.png" class title="image-20230312212759049">]]></content>
    
    
    <summary type="html">&lt;p&gt;计算机系统的外部存储器有内置的硬盘、移动硬盘和U盘等，经常会注意到不同的硬盘文件类型不一样，做一些简单了解。以及，为什么有时候数据的实际大小和占据的内存不一致？&lt;/p&gt;</summary>
    
    
    
    <category term="计算机软硬件知识" scheme="https://hscyber.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E7%A1%AC%E4%BB%B6%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="文件存储" scheme="https://hscyber.github.io/tags/%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8/"/>
    
    <category term="文件系统" scheme="https://hscyber.github.io/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>需要克制</title>
    <link href="https://hscyber.github.io/posts/23ea2b62/"/>
    <id>https://hscyber.github.io/posts/23ea2b62/</id>
    <published>2023-03-01T14:21:42.000Z</published>
    <updated>2023-04-14T09:47:22.508Z</updated>
    
    <content type="html"><![CDATA[<p>2023-04-13，不去做一些事情，有时候比去做一件事情还难。</p><span id="more"></span><p>毫不怀疑我有足够的能力和精力去做很多很多的事情，也毫无意外我常常因此落入快乐的陷阱。</p><p>人的欲望有时候是收不住的。饭后刷手机，看小红书的时候，系统开始给我推乒乓的视频，看来是前天京东下单买乒乓球的信息又被它知道了，看的饶有兴致，因为确实最近打球激起了多年的胜负欲，竟然又有些开始想练练球的心思。再猛然发现，最近想的，在进行的东西已经有点多了。</p><p>工作之外，想继续好好地看书，好好健身好好跑步，想拍照想旅游想登山，想看展想听音乐会，想打好羽毛球打好乒乓，想提升一下游泳，想提升一下写作，提升一下Coding，想抽时间整理笔记清单，想经营公号，想写读书笔记，想练英语……诸如此类。当然，我相信，如果真的想，在当下这个状态，很多事情都可以做到，毫不怀疑，每件事都能找到圈子，都能轻松愉快地地开始，不说别的，光是音乐会或者livehouse疫情后每周都有数不清的场子hh，可多少有些不务正业亦或是捉襟见肘了。所以，我想我该收收一些该死的虚荣心和胜负欲，而逐渐收缩到简单纯粹的工作、学习、运动、休憩中，聚焦好注意力，收收欲望，也分配好时间。</p><p>我特别敬佩一些人，那些可以专心致志心无旁骛做着简单的几件事情的人，尤其是在当下这个眼花缭乱的、浮躁的、处处充满“刺激”和诱惑的时代。就像一些专心做音乐写小说的人（每每这种时候我第一眼浮现的都是那些小说家和艺术创作者），我觉得它们应该有着对抗无聊和无意义的绝佳方式。这样的人想必是不少的，有的人搞研究做技术，有的人创业或做工作，有的人搞运动搞竞技等等，不管是因为纯粹的热爱、兴趣，还是因为无奈（但不能是讨厌）。</p><p>生活需要希望，需要劳动，需要放松，也需要时时的<font color="#dd0000">克制</font>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;2023-04-13，不去做一些事情，有时候比去做一件事情还难。&lt;/p&gt;</summary>
    
    
    
    <category term="生活漫步" scheme="https://hscyber.github.io/categories/%E7%94%9F%E6%B4%BB%E6%BC%AB%E6%AD%A5/"/>
    
    
  </entry>
  
  <entry>
    <title>这周又是一个新的节点</title>
    <link href="https://hscyber.github.io/posts/df93ef6f/"/>
    <id>https://hscyber.github.io/posts/df93ef6f/</id>
    <published>2023-03-01T13:12:58.000Z</published>
    <updated>2023-04-14T09:46:24.237Z</updated>
    
    <content type="html"><![CDATA[<p>2023-03-17，从1月29返京，到2月3组会+元宵节和老师一起庆祝开工，再到2月9日北京下雪，再到2月16号开学注册，再到今天的组会+课题组聚餐，一个多月的时间过得匆忙但也丰富，当然，也得益于似乎远去的疫情。</p><span id="more"></span><p>到这周忙完了项目申请和一些杂七杂八的活，开始捡起之前的工作继续推进，长舒一口气的同时，生活学习仿佛也跟着舒展开来。就像北京雾霾被春天的清风吹散，在公园大吸一口新鲜空气，也想起有时带着满身疲惫下班，看到惹人留步的西山上耀眼的落日，或是深蓝夜空中西边最亮的那个星，些许治愈。</p><p>研究生第三年的下半年，按照硕士的时间算，今年是毕业的年级。所以我的同级的很多朋友们，包括组里今年毕业的师姐，这段时间也都在忙着盲审稿的准备，截止时间也是这周，我的忙里偷闲摸鱼和他们的忙碌有些格格不入。师兄终于在等待签证出国交流，也看到朋友圈不少朋友顺利收到了所里或者国外的博士offer，由衷地表示祝贺。春天，是个很美好的季节，是播种的季节，也是“收获”的季节，还有免费的阳光，空气和迎面来的风，除了雾霾和扬沙。</p><p>平时聊的最多的，还是本科时候的同学们。熟悉的几个小伙伴们，他们倒是都找好了去处，有留北京的，也有在京外公司的，都还不赖。昨天本科导师北京开会，特地来所里找他的同学吃饭，也特地来看了看我和同级的两个在所里的同学，感觉和陈老师已经好几年没见面了，一起聊了得有半个多小时，很亲切，很怀念。也感慨时间流逝，当时的班上很多同学如今也都是天各一方，有的读研有的工作，有的准备继续读博，有的也还在看，最后都汇成一句话，“都挺好的，哈哈”，生活没那么如意，但也没多糟糕。和陈老师一起来北京的，还有更是“多年”未见的本科室友，只是不知道明天有没有时间和健健完成这历史性的会面。</p><p>还有很多故事想讲，手机里也还留下了很多值得纪念的时刻。和老同学老朋友的短剧闲聊，课题组的聚餐，办公室10多号人的初次聚餐，和实验室学生会同志们的首次饭桌会面，和所里的一众小伙伴们、摄友们的一起听的八卦，讲的笑话……都是以后美好的燃料。</p><p>倘若这寥寥几句就作为一个多月的总结好像过于短了，可一天的会下来-我的眼皮已经在打架了，到了该下班期待明天的时候了，也就到此歇菜了，没说完的话就留在梦里了。</p><p>2023&#x2F;3&#x2F;17 22:20</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;2023-03-17，从1月29返京，到2月3组会+元宵节和老师一起庆祝开工，再到2月9日北京下雪，再到2月16号开学注册，再到今天的组会+课题组聚餐，一个多月的时间过得匆忙但也丰富，当然，也得益于似乎远去的疫情。&lt;/p&gt;</summary>
    
    
    
    <category term="生活漫步" scheme="https://hscyber.github.io/categories/%E7%94%9F%E6%B4%BB%E6%BC%AB%E6%AD%A5/"/>
    
    
  </entry>
  
  <entry>
    <title>Pandas(杂)：拼接多张表为一张表concat</title>
    <link href="https://hscyber.github.io/posts/2178bf2d/"/>
    <id>https://hscyber.github.io/posts/2178bf2d/</id>
    <published>2023-02-27T14:22:37.000Z</published>
    <updated>2023-11-29T02:16:10.732Z</updated>
    
    <content type="html"><![CDATA[<p>将文件夹下的所有相同格式的文本文件csv&#x2F;txt&#x2F;xlsx等，&#x3D;&#x3D;合并或者拼接&#x3D;&#x3D;为一张表的代码，代码很简单，因为经常用到所以放在这里以便用的时候直接粘贴复用：</p><span id="more"></span><p>函数具体说明可以查看文档 <a href="https://pandas.pydata.org/docs/reference/api/pandas.concat.html">pd.concat</a>，<a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.drop_duplicates.html">df.drop_duplicates</a>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> glob <span class="keyword">import</span> glob</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入参数</span></span><br><span class="line">indir = <span class="string">r&quot;&quot;</span></span><br><span class="line">outfile = <span class="string">&quot;....csv&quot;</span></span><br><span class="line">filetype = <span class="string">&quot;csv&quot;</span></span><br><span class="line"><span class="comment"># pandas文件遍历及合并</span></span><br><span class="line">files = glob(indir+<span class="string">&quot;\\*.&quot;</span>+filetype)</span><br><span class="line">tables = [] <span class="comment"># 确保文件总大小不会溢出内存，否则需分组处理</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">    df = pd.read_csv(file)</span><br><span class="line">    tables.append(df)</span><br><span class="line"><span class="comment"># 表格拼接及写出,axis=0表示按行拼接</span></span><br><span class="line">result = pd.concat(tables,axis=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># result.drop_duplicates(subset=[&quot;fid&quot;], keep=&#x27;first&#x27;, inplace=True) #去重复列</span></span><br><span class="line">result.to_csv(outfile,encoding = <span class="string">&#x27;utf-8&#x27;</span>,index=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># 导出可以用excel打开的文件</span></span><br><span class="line">result.to_csv(outfile,encoding = <span class="string">&#x27;utf-8-sig&#x27;</span>,index=<span class="literal">False</span>)</span><br><span class="line">result.to_excel(outfile,encoding = <span class="string">&#x27;utf-8&#x27;</span>,index=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># 其他导出选项</span></span><br><span class="line">result.to_csv(outfile,encoding = <span class="string">&#x27;utf-8&#x27;</span>,index=<span class="literal">False</span>, sep=<span class="string">&quot;\t&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;将文件夹下的所有相同格式的文本文件csv&amp;#x2F;txt&amp;#x2F;xlsx等，&amp;#x3D;&amp;#x3D;合并或者拼接&amp;#x3D;&amp;#x3D;为一张表的代码，代码很简单，因为经常用到所以放在这里以便用的时候直接粘贴复用：&lt;/p&gt;</summary>
    
    
    
    <category term="Pandas数据处理分析" scheme="https://hscyber.github.io/categories/Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Pandas" scheme="https://hscyber.github.io/tags/Pandas/"/>
    
  </entry>
  
  <entry>
    <title>python性能(2)：multiprocessing多个参数怎么用</title>
    <link href="https://hscyber.github.io/posts/e4ebeda1/"/>
    <id>https://hscyber.github.io/posts/e4ebeda1/</id>
    <published>2023-02-26T13:38:19.000Z</published>
    <updated>2024-01-11T08:30:20.365Z</updated>
    
    <content type="html"><![CDATA[<p>承接上节<a href="https://hscyber.github.io/posts/4b434785/">python性能(1)：multiprocessing多进程</a>，使用多进程经常会遇到多个参数的问题，此时pool.map()略显麻烦，可以使用&#x3D;&#x3D;pool.starmap&#x3D;&#x3D;</p><span id="more"></span><h2 id="starmap用法"><a href="#starmap用法" class="headerlink" title="starmap用法"></a>starmap用法</h2><p>用法与<a href="https://hscyber.github.io/posts/4b434785/">之前类似</a>，只不过提供了一个更加方便的参数打包和完成自动解析的步骤</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing.pool <span class="keyword">import</span> Pool</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">myfunction</span>(<span class="params">outpath,x,y,z</span>):</span><br><span class="line">     <span class="comment"># 此处是处理操作</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">outpath =  <span class="string">&quot;C:\Users\huangs\Desktop&quot;</span>   </span><br><span class="line">outpaths = [outpath]*<span class="number">4</span></span><br><span class="line">X = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">Y = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">Z = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="comment"># X,Y,Z为参数集合，也可以用元组包装，如X = (1,2,3,4)</span></span><br><span class="line">paras = [outpaths,X, Y, Z]</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> Pool(<span class="number">8</span>) <span class="keyword">as</span> pool:</span><br><span class="line">    pool.starmap(myfunction, paras)</span><br></pre></td></tr></table></figure><p>这样实际上就会多进程执行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myfunction(outpaths[<span class="number">0</span>],X[<span class="number">0</span>],Y[<span class="number">0</span>],Z[<span class="number">0</span>])</span><br><span class="line">myfunction(outpaths[<span class="number">1</span>],X[<span class="number">1</span>],Y[<span class="number">1</span>],Z[<span class="number">1</span>])</span><br><span class="line">......</span><br><span class="line">myfunction(outpaths[i],X[i],Y[i],Z[i])</span><br></pre></td></tr></table></figure><h2 id="pandas多行并行"><a href="#pandas多行并行" class="headerlink" title="pandas多行并行"></a>pandas多行并行</h2><p>如果能够直接构造一个函数使用pandas apply函数即可，有时候pandas的多行提取得到一些结果，不方便直接apply，可以&#x3D;&#x3D;将表拆分成多个表完成并行操作&#x3D;&#x3D;，记录一下刚刚完成的实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">tids, track_ids, user_ids, cities</span>):</span><br><span class="line">    <span class="comment"># 此处是操作</span></span><br><span class="line">    newrows = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(tids)):</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:    </span><br><span class="line">    <span class="comment"># 原始轨迹数据表</span></span><br><span class="line">    tf = pd.read_csv(trackinfo, header=<span class="number">0</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    paras = []</span><br><span class="line">    <span class="comment"># 按照城市拆分成367个表格，每组数据作为paras的一个元素</span></span><br><span class="line">    <span class="keyword">for</span> city,table <span class="keyword">in</span> tf.groupby(<span class="string">&#x27;city&#x27;</span>):</span><br><span class="line">        tids = <span class="built_in">list</span>(table[<span class="string">&#x27;tid&#x27;</span>])</span><br><span class="line">        track_ids = <span class="built_in">list</span>(table[<span class="string">&#x27;track_id&#x27;</span>])</span><br><span class="line">        user_ids = <span class="built_in">list</span>(table[<span class="string">&#x27;user_id&#x27;</span>])</span><br><span class="line">        cities = <span class="built_in">list</span>(table[<span class="string">&#x27;city&#x27;</span>])</span><br><span class="line">        paras.append((tids,track_ids,user_ids,cities))</span><br><span class="line">    <span class="comment"># 此时paras是一个包含367个元组的列表，每个元素是一组输入</span></span><br><span class="line">    <span class="comment"># 遍历处理，函数内设循环</span></span><br><span class="line">    <span class="keyword">with</span> Pool(<span class="number">8</span>) <span class="keyword">as</span> pool:</span><br><span class="line">        pool.starmap(main, paras)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;承接上节&lt;a href=&quot;https://hscyber.github.io/posts/4b434785/&quot;&gt;python性能(1)：multiprocessing多进程&lt;/a&gt;，使用多进程经常会遇到多个参数的问题，此时pool.map()略显麻烦，可以使用&amp;#x3D;&amp;#x3D;pool.starmap&amp;#x3D;&amp;#x3D;&lt;/p&gt;</summary>
    
    
    
    <category term="Python性能" scheme="https://hscyber.github.io/categories/Python%E6%80%A7%E8%83%BD/"/>
    
    
    <category term="Python" scheme="https://hscyber.github.io/tags/Python/"/>
    
    <category term="multiprocessing" scheme="https://hscyber.github.io/tags/multiprocessing/"/>
    
  </entry>
  
</feed>
